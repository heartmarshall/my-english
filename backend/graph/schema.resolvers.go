package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/transport"
)

// Examples is the resolver for the examples field.
func (r *meaningResolver) Examples(ctx context.Context, obj *Meaning) ([]*Example, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	examples, err := LoadExamplesForMeaning(ctx, meaningID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return ToGraphQLExamples(examples), nil
}

// Tags is the resolver for the tags field.
func (r *meaningResolver) Tags(ctx context.Context, obj *Meaning) ([]*Tag, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	tags, err := LoadTagsForMeaning(ctx, meaningID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return ToGraphQLTags(tags), nil
}

// CreateWord is the resolver for the createWord field.
func (r *mutationResolver) CreateWord(ctx context.Context, input AddWordInput) (*Word, error) {
	result, err := r.words.Create(ctx, ToCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return WordWithRelationsToGraphQL(result), nil
}

// UpdateWord is the resolver for the updateWord field.
func (r *mutationResolver) UpdateWord(ctx context.Context, id string, input AddWordInput) (*Word, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	result, err := r.words.Update(ctx, wordID, ToUpdateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return WordWithRelationsToGraphQL(result), nil
}

// ReviewMeaning is the resolver for the reviewMeaning field.
func (r *mutationResolver) ReviewMeaning(ctx context.Context, meaningID string, grade int) (*Meaning, error) {
	mID, err := FromGraphQLID(meaningID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	meaning, err := r.study.ReviewMeaning(ctx, mID, grade)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers
	return ToGraphQLMeaningBasic(meaning), nil
}

// DeleteWord is the resolver for the deleteWord field.
func (r *mutationResolver) DeleteWord(ctx context.Context, id string) (bool, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return false, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	if err := r.words.Delete(ctx, wordID); err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// Words is the resolver for the words field.
func (r *queryResolver) Words(ctx context.Context, filter *WordFilter, limit *int, offset *int) ([]*Word, error) {
	l, o := database.NormalizePagination(ptrToInt(limit), ptrToInt(offset))

	words, err := r.words.List(ctx, ToWordFilter(filter), l, o)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Используем ToGraphQLWordBasic — meanings загрузятся через field resolver
	result := make([]*Word, 0, len(words))
	for _, w := range words {
		result = append(result, ToGraphQLWordBasic(w))
	}

	return result, nil
}

// Word is the resolver for the word field.
func (r *queryResolver) Word(ctx context.Context, id string) (*Word, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	wordWithRelations, err := r.words.GetByID(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return WordWithRelationsToGraphQL(wordWithRelations), nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*Meaning, error) {
	l := database.NormalizeLimit(ptrToInt(limit), database.DefaultSRSLimit)

	meanings, err := r.study.GetStudyQueue(ctx, l)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers с DataLoader
	result := make([]*Meaning, 0, len(meanings))
	for _, m := range meanings {
		result = append(result, ToGraphQLMeaningBasic(m))
	}

	return result, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*DashboardStats, error) {
	stats, err := r.study.GetStats(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLStats(stats), nil
}

// Meanings is the resolver for the meanings field.
func (r *wordResolver) Meanings(ctx context.Context, obj *Word) ([]*Meaning, error) {
	wordID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	meanings, err := LoadMeaningsForWord(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Конвертируем в GraphQL тип (без examples и tags — они загрузятся через field resolvers)
	result := make([]*Meaning, 0, len(meanings))
	for _, m := range meanings {
		result = append(result, ToGraphQLMeaningBasic(m))
	}

	return result, nil
}

// Meaning returns MeaningResolver implementation.
func (r *Resolver) Meaning() MeaningResolver { return &meaningResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Word returns WordResolver implementation.
func (r *Resolver) Word() WordResolver { return &wordResolver{r} }

type meaningResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type wordResolver struct{ *Resolver }
