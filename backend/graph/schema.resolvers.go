package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"log/slog"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/transport"
	ctxlog "github.com/heartmarshall/my-english/pkg/context"
)

// Examples is the resolver for the examples field.
func (r *meaningResolver) Examples(ctx context.Context, obj *Meaning) ([]*Example, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	examples, err := LoadExamplesForMeaning(ctx, meaningID)
	if err != nil {
		// Логируем ошибку, но возвращаем пустой массив вместо ошибки
		// чтобы не ломать весь запрос
		// TODO: исправить причину ошибки в DataLoader
		return make([]*Example, 0), nil
	}

	return ToGraphQLExamples(examples), nil
}

// Tags is the resolver for the tags field.
func (r *meaningResolver) Tags(ctx context.Context, obj *Meaning) ([]*Tag, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	tags, err := LoadTagsForMeaning(ctx, meaningID)
	if err != nil {
		// Логируем ошибку, но возвращаем пустой массив вместо ошибки
		// чтобы не ломать весь запрос
		// TODO: исправить причину ошибки в DataLoader
		return make([]*Tag, 0), nil
	}

	return ToGraphQLTags(tags), nil
}

// AddToInbox is the resolver for the addToInbox field.
func (r *mutationResolver) AddToInbox(ctx context.Context, text string, sourceContext *string) (*InboxItem, error) {
	item, err := r.inbox.Create(ctx, text, sourceContext)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLInboxItem(item), nil
}

// DeleteInboxItem is the resolver for the deleteInboxItem field.
func (r *mutationResolver) DeleteInboxItem(ctx context.Context, id string) (bool, error) {
	itemID, err := FromGraphQLID(id)
	if err != nil {
		return false, transport.NewGraphQLError(ctx, "Invalid inbox item ID", transport.CodeInvalidInput)
	}

	if err := r.inbox.Delete(ctx, itemID); err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// ConvertInboxItem is the resolver for the convertInboxItem field.
func (r *mutationResolver) ConvertInboxItem(ctx context.Context, inboxID string, input CreateWordInput) (*CreateWordPayload, error) {
	itemID, err := FromGraphQLID(inboxID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid inbox item ID", transport.CodeInvalidInput)
	}

	// Получаем inbox item
	inboxItem, err := r.inbox.GetByID(ctx, itemID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Если sourceContext не указан в input, используем из inbox item
	if input.SourceContext == nil && inboxItem.SourceContext != nil {
		input.SourceContext = inboxItem.SourceContext
	}

	// Создаём слово
	result, err := r.words.Create(ctx, ToCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Удаляем inbox item
	if err := r.inbox.Delete(ctx, itemID); err != nil {
		// Логируем ошибку, но не возвращаем её, так как слово уже создано
		// TODO: добавить логирование
		_ = err
	}

	return &CreateWordPayload{
		Word: WordWithRelationsToGraphQL(result),
	}, nil
}

// CreateWord is the resolver for the createWord field.
func (r *mutationResolver) CreateWord(ctx context.Context, input CreateWordInput) (*CreateWordPayload, error) {
	result, err := r.words.Create(ctx, ToCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return &CreateWordPayload{
		Word: WordWithRelationsToGraphQL(result),
	}, nil
}

// UpdateWord is the resolver for the updateWord field.
func (r *mutationResolver) UpdateWord(ctx context.Context, id string, input CreateWordInput) (*UpdateWordPayload, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	result, err := r.words.Update(ctx, wordID, ToUpdateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return &UpdateWordPayload{
		Word: WordWithRelationsToGraphQL(result),
	}, nil
}

// DeleteWord is the resolver for the deleteWord field.
func (r *mutationResolver) DeleteWord(ctx context.Context, id string) (bool, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return false, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	if err := r.words.Delete(ctx, wordID); err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// ReviewMeaning is the resolver for the reviewMeaning field.
func (r *mutationResolver) ReviewMeaning(ctx context.Context, meaningID string, grade int) (*Meaning, error) {
	mID, err := FromGraphQLID(meaningID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	meaning, err := r.study.ReviewMeaning(ctx, mID, grade)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers
	return ToGraphQLMeaningBasic(&meaning), nil
}

// Words is the resolver for the words field.
func (r *queryResolver) Words(ctx context.Context, filter *WordFilter, first *int, after *string) (*WordConnection, error) {
	// Логируем входные параметры для отладки
	ctxlog.L(ctx).Info("Words resolver called",
		slog.Any("filter", filter),
		slog.Any("first", first),
		slog.Any("after", after),
	)

	// Парсинг cursor в offset
	offset := 0
	if after != nil && *after != "" {
		decodedOffset, err := DecodeCursor(*after)
		if err != nil {
			return nil, transport.NewGraphQLError(ctx, "Invalid cursor", transport.CodeInvalidInput)
		}
		offset = decodedOffset
	}

	// Нормализация first (limit)
	limit := 20
	if first != nil {
		limit = *first
	}
	limit = database.NormalizeLimit(limit, database.DefaultLimit)

	// Получение данных
	wordFilter := ToWordFilter(filter)
	ctxlog.L(ctx).Info("Calling words.List",
		slog.Any("filter", wordFilter),
		slog.Int("limit", limit),
		slog.Int("offset", offset),
	)
	words, err := r.words.List(ctx, wordFilter, limit, offset)
	if err != nil {
		// Логируем ошибку перед обработкой
		ctxlog.L(ctx).Error("words.List error",
			slog.String("error", err.Error()),
			slog.Any("filter", filter),
		)
		return nil, transport.HandleError(ctx, err)
	}

	// Подсчет totalCount
	ctxlog.L(ctx).Info("Calling words.Count",
		slog.Any("filter", wordFilter),
	)
	totalCount, err := r.words.Count(ctx, wordFilter)
	if err != nil {
		// Логируем ошибку перед обработкой
		ctxlog.L(ctx).Error("words.Count error",
			slog.String("error", err.Error()),
			slog.Any("filter", filter),
		)
		return nil, transport.HandleError(ctx, err)
	}

	// Создание edges
	edges := make([]*WordEdge, 0, len(words))
	for i := range words {
		cursor := EncodeCursor(offset + i)
		edges = append(edges, &WordEdge{
			Cursor: cursor,
			Node:   ToGraphQLWordBasic(&words[i]),
		})
	}

	// Вычисление pageInfo
	hasNextPage := offset+len(words) < totalCount
	var endCursor *string
	if len(edges) > 0 {
		lastCursor := edges[len(edges)-1].Cursor
		endCursor = &lastCursor
	}

	return &WordConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			HasNextPage: hasNextPage,
			EndCursor:   endCursor,
		},
		TotalCount: totalCount,
	}, nil
}

// Word is the resolver for the word field.
func (r *queryResolver) Word(ctx context.Context, id string) (*Word, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	wordWithRelations, err := r.words.GetByID(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return WordWithRelationsToGraphQL(wordWithRelations), nil
}

// InboxItems is the resolver for the inboxItems field.
func (r *queryResolver) InboxItems(ctx context.Context) ([]*InboxItem, error) {
	items, err := r.inbox.List(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLInboxItems(items), nil
}

// Suggest is the resolver for the suggest field.
func (r *queryResolver) Suggest(ctx context.Context, query string) ([]*Suggestion, error) {
	suggestions, err := r.words.Suggest(ctx, query)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLSuggestions(suggestions), nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*Meaning, error) {
	l := database.NormalizeLimit(ptrToInt(limit), database.DefaultSRSLimit)

	meanings, err := r.study.GetStudyQueue(ctx, l)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers с DataLoader
	result := make([]*Meaning, 0, len(meanings))
	for i := range meanings {
		result = append(result, ToGraphQLMeaningBasic(&meanings[i]))
	}

	return result, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*DashboardStats, error) {
	stats, err := r.study.GetStats(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLStats(stats), nil
}

// Meanings is the resolver for the meanings field.
func (r *wordResolver) Meanings(ctx context.Context, obj *Word) ([]*Meaning, error) {
	wordID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	meanings, err := LoadMeaningsForWord(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Конвертируем в GraphQL тип (без examples и tags — они загрузятся через field resolvers)
	result := make([]*Meaning, 0, len(meanings))
	for _, m := range meanings {
		result = append(result, ToGraphQLMeaningBasic(m))
	}

	return result, nil
}

// Meaning returns MeaningResolver implementation.
func (r *Resolver) Meaning() MeaningResolver { return &meaningResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Word returns WordResolver implementation.
func (r *Resolver) Word() WordResolver { return &wordResolver{r} }

type meaningResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type wordResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *meaningResolver) SynonymsAntonyms(ctx context.Context, obj *Meaning) ([]*SynonymAntonym, error) {
	// Загружаем word чтобы получить text
	wordID, err := FromGraphQLID(obj.WordID)
	if err != nil {
		return []*SynonymAntonym{}, nil
	}

	wordWithRelations, err := r.words.GetByID(ctx, wordID)
	if err != nil {
		ctxlog.L(ctx).Error("error loading word for synonyms",
			slog.Int64("wordID", wordID),
			slog.String("error", err.Error()),
		)
		return []*SynonymAntonym{}, nil
	}

	// Конвертируем GraphQL PartOfSpeech в domain PartOfSpeech
	partOfSpeech := FromGraphQLPartOfSpeech(obj.PartOfSpeech)

	// Получаем синонимы/антонимы
	relations, dictMeaningID, err := r.words.(*word.Service).GetDictionarySynonymsAntonymsByUserMeaning(
		ctx,
		wordWithRelations.Word.Text,
		partOfSpeech,
	)
	if err != nil {
		ctxlog.L(ctx).Error("error loading synonyms/antonyms",
			slog.String("word", wordWithRelations.Word.Text),
			slog.String("error", err.Error()),
		)
		return []*SynonymAntonym{}, nil
	}

	return ToGraphQLSynonymAntonyms(relations, dictMeaningID), nil
}
func (r *wordResolver) Forms(ctx context.Context, obj *Word) ([]*WordForm, error) {
	// Получаем формы слова по тексту слова
	forms, err := r.words.(*word.Service).GetWordForms(ctx, obj.Text)
	if err != nil {
		// Логируем ошибку, но возвращаем пустой массив
		ctxlog.L(ctx).Error("error loading word forms",
			slog.String("word", obj.Text),
			slog.String("error", err.Error()),
		)
		return []*WordForm{}, nil
	}

	return ToGraphQLWordForms(forms), nil
}
*/
