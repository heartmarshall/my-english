# Сценарий создания нового слова в словаре vMVP-1

Документ описывает полный пользовательский и технический сценарий создания нового слова в словаре **с учетом управляемой работы с подсказками (Suggestions)** и реальных рисков реализации.

Сценарий является **нормативным контрактом между фронтендом и бэкендом** и предназначен для прямого использования в документации.

---

## Ключевые принципы

1. **Backend — единственный источник истины**.
2. Создание слова — строго транзакционная операция.
3. Suggestions **не загружаются автоматически** и **не сохраняются автоматически**.
4. Пользователь явно инициирует загрузку подсказок и явно выбирает, какие элементы будут сохранены.
5. В БД невозможно существование частично созданного слова.

---

## Предусловия

* Пользователь находится в интерфейсе словаря.
* Все проверки уникальности слова выполняются по `text_normalized`.
* Используется единая функция нормализации текста (trim, lower-case, Unicode normalize).
* Система рассчитана на одного пользователя (В рамках MVP)

---

## Фаза 1. Поиск слова

### Действие пользователя
Пользователь вводит текст в строку поиска, например:

```
Privy
```

---

### Действие фронтенда

* Поиск выполняется только если длина строки ≥ 2 символов.
* Используется debounce не менее 300–500 мс.

```graphql
query DictionarySearch {
  dictionary(filter: {
    search: "privy"
    limit: 10
  }) {
    id
    text
  }
}
```

---

### Действие бэкенда

* Применяет ту же нормализацию текста, что и при создании слова.
* Выполняет поиск без side effects.

---

### UI-результат

* Если слово найдено — пользователь переходит к существующей записи (Сначала слово просто отображается в поиске, потом пользователь может перейти в него)
* Если слово не найдено — UI показывает empty-state с кнопкой **«Создать новое слово»**.

Важно: отсутствие слова в поиске **не гарантирует**, что его можно создать.
Важно: пользоатель также может просто перейти к созданию нового слова и без поиска. В таком случае проверка уникальности будет на этапе ввода слова в поле при создании. 
---

## Фаза 2. Открытие экрана создания слова

### Действие пользователя

Пользователь инициирует создание нового слова.

---

### Действие фронтенда

* Открывается экран создания слова.
* Поле `text` заполняется словом, которое ввел пользователь. Он может изменить его и тогда запускается проверка на уникальность. Если уникальность нарушена, то сохранить слово нельзя - пользователю показывается ошибка. НА БУДУЩЕЕ (MVP-2): пробовать подсказать пользователю слово если он ввел его с ошибкой ("Может быть вы имели в виду ...?")
* На экране присутствует кнопка **«Загрузить подсказки»**.
* До нажатия этой кнопки **никакие внешние запросы не выполняются**.

Любое изменение поля `text`:

* инвалидирует ранее загруженные подсказки,
* очищает левую карточку с подсказками.

---

## Фаза 3. Явная загрузка подсказок (Suggestions)

### Действие пользователя
Пользователь нажимает кнопку **«Загрузить подсказки»** и (опционально) выбирает источник в выпадающем списке (например: `freedict`, `openai`).

---

### Действие фронтенда

```graphql
query FetchSuggestions {
  fetchSuggestions(
    text: "to figure out",
    sources: ["freedict"]
  ) {
    sourceSlug
    sourceName
    senses {
      definition
      partOfSpeech
      translations
      examples {
        sentence
        translation
      }
    }
    images {
      url
      caption
    }
    pronunciations {
      audioUrl
      transcription
      region
    }
  }
}
```

---

### Действие бэкенда

* Не читает и не пишет БД.
* Вызывает **только явно указанные** источники.
* Каждый источник вызывается с таймаутом.
* Частичный ответ считается успешным.

---

## Фаза 4. Работа с подсказками (двухкарточный режим)

### Общая UX-модель

Экран создания слова разделен на две логические карточки:

### Левая карточка — «Подсказки»

* Отображает **сырые данные**, полученные от выбранного источника.
* Данные **read-only**.
* Источник можно сменить — содержимое полностью перезагружается.
* Эти данные **никогда напрямую не сохраняются в БД**.

### Правая карточка — «Моё слово»

* Отображает **финальную версию слова**, которая будет сохранена.
* Изначально пустая (кроме поля `text`).
* Является **единственным источником данных** для `CreateWordInput`.

---

### Перенос данных

Пользователь может:

* добавлять элементы из левой карточки в правую:

  * кнопкой «Добавить»,
  * drag-and-drop (опционально);
* редактировать любые данные в правой карточке;
* удалять добавленные элементы.

Важно:

* Перенос данных — **явное действие пользователя**.
* Никакие данные не копируются автоматически.

---

## Фаза 5. Подготовка данных к сохранению

### Действие фронтенда

`CreateWordInput` формируется **исключительно на основе данных правой карточки**.

Минимальные требования:

* хотя бы один sense;
* в каждом sense есть definition и/или translations;
* каждый example содержит sentence.

---

## Фаза 6. Backend-операция `createWord`

Backend-логика полностью соответствует backend-сценарию `createWord` и **не зависит от того, использовались ли suggestions**.

Инварианты:

* Suggestions не имеют связи с БД.
* Backend не знает и не различает источник данных.

---

## Фаза 7. Ответ и обновление UI

* UI обновляется **только после успешного ответа сервера**.
* При ошибке UI полностью откатывает состояние и отображает причину.

---

## Постусловия

После успешного создания:

* В БД существует ровно одно слово с данным `text_normalized`.
* Все вложенные сущности принадлежат этому слову.
* Карточка либо полностью создана, либо отсутствует.
* Ни один элемент suggestions не был сохранен без явного действия пользователя.

---