package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/google/uuid"
	model1 "github.com/heartmarshall/my-english/graph/model"
	"github.com/heartmarshall/my-english/graph/scalar"
	"github.com/heartmarshall/my-english/internal/model"
	dictservice "github.com/heartmarshall/my-english/internal/service/dictionary"
	"github.com/heartmarshall/my-english/internal/service/study"
	"github.com/heartmarshall/my-english/internal/transport"
	"github.com/heartmarshall/my-english/internal/transport/dataloader"
)

// Changes is the resolver for the changes field.
func (r *auditRecordResolver) Changes(ctx context.Context, obj *model.AuditRecord) (scalar.JSON, error) {
	// Поле Changes уже является model.JSON (scalar.JSON), который мапится сам на себя.
	// Обычно этот метод не нужен, если типы совпадают.
	// Но если он сгенерировался, значит есть нюанс. Просто вернем поле.
	return obj.Changes, nil
}

// ReviewHistory is the resolver for the reviewHistory field.
func (r *cardResolver) ReviewHistory(ctx context.Context, obj *model.Card, limit *int) ([]*model.ReviewLog, error) {
	lim := 10
	if limit != nil {
		lim = *limit
	}
	// Используем репозиторий напрямую или через сервис.
	// Лучше добавить метод в сервис Study, но для истории допустим прямой вызов репозитория через Registry
	// так как это "view" логика.
	logs, err := r.Services.Study.GetCardHistory(ctx, obj.ID, lim) // Нужно добавить этот метод в сервис Study!
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Конвертация []model.ReviewLog -> []*model.ReviewLog
	res := make([]*model.ReviewLog, len(logs))
	for i := range logs {
		res[i] = &logs[i]
	}
	return res, nil
}

// Pronunciations is the resolver for the pronunciations field.
func (r *dictionaryEntryResolver) Pronunciations(ctx context.Context, obj *model.DictionaryEntry) ([]*model.Pronunciation, error) {
	// Используем DataLoader
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	items, err := loaders.PronunciationsByEntryID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	res := make([]*model.Pronunciation, len(items))
	for i := range items {
		res[i] = &items[i] // Берем адрес элемента массива
	}
	return res, nil
}

// Images is the resolver for the images field.
func (r *dictionaryEntryResolver) Images(ctx context.Context, obj *model.DictionaryEntry) ([]*model.Image, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	items, err := loaders.ImagesByEntryID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	res := make([]*model.Image, len(items))
	for i := range items {
		res[i] = &items[i]
	}
	return res, nil
}

// Senses is the resolver for the senses field.
func (r *dictionaryEntryResolver) Senses(ctx context.Context, obj *model.DictionaryEntry) ([]*model.Sense, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	items, err := loaders.SensesByEntryID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	res := make([]*model.Sense, len(items))
	for i := range items {
		res[i] = &items[i]
	}
	return res, nil
}

// Card is the resolver for the card field.
func (r *dictionaryEntryResolver) Card(ctx context.Context, obj *model.DictionaryEntry) (*model.Card, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	card, err := loaders.CardByEntryID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return card, nil // card уже указатель или nil
}

// CardEnabled is the resolver for the cardEnabled field.
func (r *dictionaryEntryResolver) CardEnabled(ctx context.Context, obj *model.DictionaryEntry) (bool, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return false, transport.HandleError(ctx, err)
	}
	card, err := loaders.CardByEntryID.Load(ctx, obj.ID)
	if err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return card != nil, nil
}

// AuditLog is the resolver for the auditLog field.
func (r *dictionaryEntryResolver) AuditLog(ctx context.Context, obj *model.DictionaryEntry) ([]*model.AuditRecord, error) {
	// TODO: Реализовать получение аудита через сервис/репо. Пока пустой список.
	return []*model.AuditRecord{}, nil
}

// CreateWord is the resolver for the createWord field.
func (r *mutationResolver) CreateWord(ctx context.Context, input model1.CreateWordInput) (*model.DictionaryEntry, error) {
	entry, err := r.Services.Dictionary.CreateWord(ctx, mapCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return entry, nil
}

// UpdateWord is the resolver for the updateWord field.
func (r *mutationResolver) UpdateWord(ctx context.Context, id uuid.UUID, input model1.UpdateWordInput) (*model.DictionaryEntry, error) {
	entry, err := r.Services.Dictionary.UpdateWord(ctx, mapUpdateWordInput(id.String(), input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return entry, nil
}

// DeleteWord is the resolver for the deleteWord field.
func (r *mutationResolver) DeleteWord(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Dictionary.DeleteWord(ctx, dictservice.DeleteWordInput{ID: id.String()})
	if err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// AddToInbox is the resolver for the addToInbox field.
func (r *mutationResolver) AddToInbox(ctx context.Context, text string, context *string) (*model.InboxItem, error) {
	item, err := r.Services.Inbox.AddToInbox(ctx, text, context)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return item, nil
}

// DeleteInboxItem is the resolver for the deleteInboxItem field.
func (r *mutationResolver) DeleteInboxItem(ctx context.Context, id uuid.UUID) (bool, error) {
	err := r.Services.Inbox.Delete(ctx, id)
	if err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// ConvertInboxToWord is the resolver for the convertInboxToWord field.
func (r *mutationResolver) ConvertInboxToWord(ctx context.Context, inboxID uuid.UUID, input model1.CreateWordInput) (*model.DictionaryEntry, error) {
	entry, err := r.Services.Inbox.ConvertToWord(ctx, inboxID, mapCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return entry, nil
}

// ReviewCard is the resolver for the reviewCard field.
func (r *mutationResolver) ReviewCard(ctx context.Context, cardID uuid.UUID, grade model.ReviewGrade, timeTakenMs *int) (*model1.ReviewResult, error) {
	res, err := r.Services.Study.ReviewCard(ctx, study.ReviewCardInput{
		CardID:     cardID,
		Grade:      grade,
		DurationMs: timeTakenMs,
	})
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Здесь есть нюанс: res содержит model.Card и model.ReviewLog.
	// А GraphQL схема ожидает ReviewResult { entry: DictionaryEntry, nextReviewAt: Time }.
	// Поле entry не заполнено в ответе сервиса (там Card).

	// Решение: вернем структуру, но нам нужно достать Entry.
	// Для оптимизации gqlgen может вызвать резолвер поля entry, если мы вернем объект, содержащий ID.
	// Но так как у нас в модели ReviewResult (GraphQL) поле Entry типа DictionaryEntry, нам нужно его заполнить.

	// Вариант: Загрузить Entry прямо здесь.
	entry, err := r.Services.Dictionary.GetByID(ctx, res.Card.EntryID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return &model1.ReviewResult{
		Entry:        entry,
		NextReviewAt: res.NextReviewAt,
	}, nil
}

// FetchSuggestions is the resolver for the fetchSuggestions field.
func (r *queryResolver) FetchSuggestions(ctx context.Context, text string, sources []string) ([]*model1.SuggestionResult, error) {
	results, err := r.Services.Suggestion.FetchSuggestions(ctx, text, sources)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Mapping []suggestion.Result -> []*model1.SuggestionResult
	// Это лучше вынести в mapper, но для скорости напишем тут.
	out := make([]*model1.SuggestionResult, len(results))
	for i, res := range results {
		// Mapping SenseInput -> SuggestedSense
		senses := make([]*model1.SuggestedSense, len(res.Senses))
		for j, s := range res.Senses {
			// Mapping TranslationInput string -> string
			trans := make([]string, len(s.Translations))
			for k, t := range s.Translations {
				trans[k] = t.Text
			}
			// Mapping Examples
			exs := make([]*model1.SuggestedExample, len(s.Examples))
			for k, e := range s.Examples {
				exs[k] = &model1.SuggestedExample{
					Sentence:    e.Sentence,
					Translation: e.Translation,
				}
			}

			def := ""
			if s.Definition != nil {
				def = *s.Definition
			}

			senses[j] = &model1.SuggestedSense{
				Definition:   def,
				PartOfSpeech: s.PartOfSpeech,
				Translations: trans,
				Examples:     exs,
			}
		}

		// Images and Pronunciations mapping skipped for brevity (similar logic)
		// ...

		out[i] = &model1.SuggestionResult{
			SourceSlug:     res.SourceSlug,
			SourceName:     res.SourceName,
			Senses:         senses,
			Images:         []*model1.SuggestedImage{},         // TODO: map images
			Pronunciations: []*model1.SuggestedPronunciation{}, // TODO: map pron
		}
	}
	return out, nil
}

// Dictionary is the resolver for the dictionary field.
func (r *queryResolver) Dictionary(ctx context.Context, filter *model1.WordFilter) ([]*model.DictionaryEntry, error) {
	entries, err := r.Services.Dictionary.Find(ctx, mapDictionaryFilter(filter))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	res := make([]*model.DictionaryEntry, len(entries))
	for i := range entries {
		res[i] = &entries[i]
	}
	return res, nil
}

// DictionaryEntry is the resolver for the dictionaryEntry field.
func (r *queryResolver) DictionaryEntry(ctx context.Context, id uuid.UUID) (*model.DictionaryEntry, error) {
	entry, err := r.Services.Dictionary.GetByID(ctx, id)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return entry, nil
}

// InboxItems is the resolver for the inboxItems field.
func (r *queryResolver) InboxItems(ctx context.Context) ([]*model.InboxItem, error) {
	items, err := r.Services.Inbox.List(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	res := make([]*model.InboxItem, len(items))
	for i := range items {
		res[i] = &items[i]
	}
	return res, nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*model.DictionaryEntry, error) {
	lim := 20
	if limit != nil {
		lim = *limit
	}
	entries, err := r.Services.Study.GetStudyQueue(ctx, lim)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	res := make([]*model.DictionaryEntry, len(entries))
	for i := range entries {
		res[i] = &entries[i]
	}
	return res, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context) (*model1.DashboardStats, error) {
	stats, err := r.Services.Study.GetDashboardStats(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	// Маппинг cards.DashboardStats -> model1.DashboardStats
	// Т.к. поля совпадают, можно переложить вручную
	return &model1.DashboardStats{
		TotalWords:    stats.TotalWords,
		TotalCards:    stats.TotalCards,
		NewCards:      stats.NewCards,
		LearningCards: stats.LearningCards,
		ReviewCards:   stats.ReviewCards,
		MasteredCards: stats.MasteredCards,
		DueToday:      stats.DueToday,
	}, nil
}

// Translations is the resolver for the translations field.
func (r *senseResolver) Translations(ctx context.Context, obj *model.Sense) ([]*model.Translation, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	items, err := loaders.TranslationsBySenseID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	res := make([]*model.Translation, len(items))
	for i := range items {
		res[i] = &items[i]
	}
	return res, nil
}

// Examples is the resolver for the examples field.
func (r *senseResolver) Examples(ctx context.Context, obj *model.Sense) ([]*model.Example, error) {
	loaders, err := dataloader.MustFor(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	items, err := loaders.ExamplesBySenseID.Load(ctx, obj.ID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	res := make([]*model.Example, len(items))
	for i := range items {
		res[i] = &items[i]
	}
	return res, nil
}

// Relations is the resolver for the relations field.
func (r *senseResolver) Relations(ctx context.Context, obj *model.Sense) ([]*model1.SenseRelation, error) {
	// Not implemented
	return []*model1.SenseRelation{}, nil
}

// AuditRecord returns AuditRecordResolver implementation.
func (r *Resolver) AuditRecord() AuditRecordResolver { return &auditRecordResolver{r} }

// Card returns CardResolver implementation.
func (r *Resolver) Card() CardResolver { return &cardResolver{r} }

// DictionaryEntry returns DictionaryEntryResolver implementation.
func (r *Resolver) DictionaryEntry() DictionaryEntryResolver { return &dictionaryEntryResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Sense returns SenseResolver implementation.
func (r *Resolver) Sense() SenseResolver { return &senseResolver{r} }

type auditRecordResolver struct{ *Resolver }
type cardResolver struct{ *Resolver }
type dictionaryEntryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type senseResolver struct{ *Resolver }
