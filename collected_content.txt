Содержимое директории: /home/alodi/playground/my-english/backend/internal/database
Всего файлов собрано: 25
Пропущено файлов: 0

================================================================================


================================================================================
Файл: database.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/database.go
================================================================================

package database

import (
	"context"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/georgysavva/scany/v2/pgxscan"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Pagination defaults
const (
	DefaultLimit    = 20
	MaxLimit        = 100
	DefaultSRSLimit = 10
)

type Querier interface {
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

var (
	_ Querier = (*pgxpool.Pool)(nil)
	_ Querier = (pgx.Tx)(nil)
)

var Builder = squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)

type Clock interface {
	Now() time.Time
}

type RealClock struct{}

func (RealClock) Now() time.Time {
	return time.Now()
}

var DefaultClock Clock = RealClock{}

type TxFunc func(ctx context.Context, q Querier) error

func WithTx(ctx context.Context, pool *pgxpool.Pool, fn TxFunc) error {
	tx, err := pool.Begin(ctx)
	if err != nil {
		return err
	}

	defer func() {
		if p := recover(); p != nil {
			_ = tx.Rollback(ctx)
			panic(p)
		}
	}()

	if err := fn(ctx, tx); err != nil {
		_ = tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}

// --- Scany Helpers ---

// GetOne сканирует одну структуру.
func GetOne[T any](ctx context.Context, q Querier, sql string, args ...any) (*T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, ErrNotFound
		}
		return nil, err
	}
	return &dest, nil
}

// Select сканирует список структур. Возвращает []*T.
func Select[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T // Слайс значений
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// GetScalar сканирует одно скалярное значение (int, string, bool).
func GetScalar[T any](ctx context.Context, q Querier, sql string, args ...any) (T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return dest, nil
		}
		return dest, err
	}
	return dest, nil
}

// SelectScalars сканирует список скалярных значений (например, []int64).
func SelectScalars[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// CheckExists проверяет наличие строки.
func CheckExists(ctx context.Context, q Querier, sql string, args ...any) (bool, error) {
	var dummy int
	err := pgxscan.Get(ctx, q, &dummy, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func NormalizePagination(limit, offset int) (int, int) {
	if limit <= 0 {
		limit = DefaultLimit
	}

	if limit > MaxLimit {
		limit = MaxLimit
	}
	if offset < 0 {
		offset = 0
	}
	return limit, offset
}

func NormalizeLimit(limit, defaultVal int) int {
	if limit <= 0 {
		limit = defaultVal
	}
	if limit > MaxLimit {
		limit = MaxLimit
	}
	return limit
}


================================================================================

================================================================================
Файл: errors.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/errors.go
================================================================================

package database

import (
	"errors"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// Кастомные ошибки слоя данных.
// Позволяют бизнес-логике не зависеть от sql пакета.
var (
	// ErrNotFound возвращается, когда запись не найдена.
	ErrNotFound = errors.New("record not found")

	// ErrDuplicate возвращается при попытке создать дубликат
	// (нарушение UNIQUE constraint).
	ErrDuplicate = errors.New("record already exists")

	// ErrInvalidInput возвращается при невалидных входных данных.
	ErrInvalidInput = errors.New("invalid input")
)

// PostgreSQL error codes
// https://www.postgresql.org/docs/current/errcodes-appendix.html
const (
	// pgUniqueViolation — код ошибки нарушения уникальности в PostgreSQL.
	pgUniqueViolation = "23505"
)

// IsNotFoundError проверяет, является ли ошибка "запись не найдена".
func IsNotFoundError(err error) bool {
	return errors.Is(err, pgx.ErrNoRows)
}

// IsDuplicateError проверяет, является ли ошибка нарушением UNIQUE constraint.
// Работает с github.com/jackc/pgx/v5.
func IsDuplicateError(err error) bool {
	if err == nil {
		return false
	}

	// Проверка для pgx v5 через pgconn.PgError
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		return pgErr.Code == pgUniqueViolation
	}

	// Fallback: проверка по строке (для совместимости)
	errStr := err.Error()
	if strings.Contains(errStr, pgUniqueViolation) ||
		strings.Contains(errStr, "duplicate key value violates unique constraint") {
		return true
	}

	return false
}

// WrapDBError оборачивает ошибку базы данных в domain-specific ошибку.
func WrapDBError(err error) error {
	if err == nil {
		return nil
	}

	if IsDuplicateError(err) {
		return ErrDuplicate
	}

	return err
}


================================================================================

================================================================================
Файл: example/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/read.go
================================================================================

package example

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает example по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (*model.Example, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Examples.String()).
		Where(schema.ExampleColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.GetOne[model.Example](ctx, r.q, query, args...)
}

// GetByMeaningID возвращает все examples для указанного meaning.
func (r *Repo) GetByMeaningID(ctx context.Context, meaningID int64) ([]model.Example, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Examples.String()).
		Where(schema.ExampleColumns.MeaningID.Eq(meaningID)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Example](ctx, r.q, query, args...)
}

// GetByMeaningIDs возвращает examples для нескольких meanings (для batch loading).
func (r *Repo) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error) {
	if len(meaningIDs) == 0 {
		return make([]model.Example, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Examples.String()).
		Where(schema.ExampleColumns.MeaningID.In(meaningIDs)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Example](ctx, r.q, query, args...)
}


================================================================================

================================================================================
Файл: example/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/repository.go
================================================================================

package example

import (
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
)

var columns = []string{
	schema.ExampleColumns.ID.String(),
	schema.ExampleColumns.MeaningID.String(),
	schema.ExampleColumns.SentenceEn.String(),
	schema.ExampleColumns.SentenceRu.String(),
	schema.ExampleColumns.SourceName.String(),
}

// Repo — реализация репозитория для работы с examples.
type Repo struct {
	q database.Querier
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repo {
	return &Repo{q: q}
}


================================================================================

================================================================================
Файл: example/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/repository_test.go
================================================================================

package example_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/example"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var exampleColumns = []string{"id", "meaning_id", "sentence_en", "sentence_ru", "source_name"}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		src := model.ExampleSourceFilm
		ex := &model.Example{
			MeaningID:  1,
			SentenceEn: "Hello, world!",
			SentenceRu: ptr("Привет, мир!"),
			SourceName: &src,
		}

		mock.ExpectQuery(`INSERT INTO examples`).
			WithArgs(int64(1), "Hello, world!", "Привет, мир!", &src).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, ex)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ex.ID != 1 {
			t.Errorf("expected ID=1, got %d", ex.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil example", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing sentence", func(t *testing.T) {
		ex := &model.Example{MeaningID: 1}

		err := repo.Create(ctx, ex)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns).
			AddRow(1, 1, "Hello!", "Привет!", "film")

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		ex, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ex.SentenceEn != "Hello!" {
			t.Errorf("expected SentenceEn='Hello!', got %q", ex.SentenceEn)
		}
		if ex.SourceName == nil || *ex.SourceName != model.ExampleSourceFilm {
			t.Error("expected SourceName=film")
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns).
			AddRow(1, 1, "First", nil, nil).
			AddRow(2, 1, "Second", nil, "book")

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		examples, err := repo.GetByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(examples) != 2 {
			t.Errorf("expected 2 examples, got %d", len(examples))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns)

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		examples, err := repo.GetByMeaningID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if examples == nil {
			t.Error("expected empty slice, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DeleteByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("deletes multiple", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		count, err := repo.DeleteByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 3 {
			t.Errorf("expected count=3, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func ptr(s string) *string {
	return &s
}


================================================================================

================================================================================
Файл: example/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/write.go
================================================================================

package example

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
)

// Create создаёт новый example.
func (r *Repo) Create(ctx context.Context, example *model.Example) error {
	if example == nil || example.MeaningID == 0 || example.SentenceEn == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Insert(schema.Examples.String()).
		Columns(
			schema.ExampleColumns.MeaningID.String(),
			schema.ExampleColumns.SentenceEn.String(),
			schema.ExampleColumns.SentenceRu.String(),
			schema.ExampleColumns.SourceName.String(),
		).
		Values(
			example.MeaningID,
			example.SentenceEn,
			example.SentenceRu,
			example.SourceName,
		).
		Suffix(schema.ExampleColumns.ID.Returning()).
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&example.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	return nil
}

// CreateBatch создаёт несколько examples за один запрос.
// Использует pgx.CollectRows для эффективного сбора ID.
func (r *Repo) CreateBatch(ctx context.Context, examples []*model.Example) error {
	if len(examples) == 0 {
		return nil
	}

	qb := database.Builder.
		Insert(schema.Examples.String()).
		Columns(
			schema.ExampleColumns.MeaningID.String(),
			schema.ExampleColumns.SentenceEn.String(),
			schema.ExampleColumns.SentenceRu.String(),
			schema.ExampleColumns.SourceName.String(),
		)

	for _, ex := range examples {
		if ex == nil || ex.MeaningID == 0 || ex.SentenceEn == "" {
			return database.ErrInvalidInput
		}
		qb = qb.Values(
			ex.MeaningID,
			ex.SentenceEn,
			ex.SentenceRu,
			ex.SourceName,
		)
	}

	qb = qb.Suffix("RETURNING " + schema.ExampleColumns.ID.String())

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}

	// Выполняем запрос
	rows, err := r.q.Query(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	// pgx.CollectRows автоматически закрывает rows и обрабатывает ошибки сканирования.
	// pgx.RowTo[int64] — эффективный маппер для одиночной колонки.
	ids, err := pgx.CollectRows(rows, pgx.RowTo[int64])
	if err != nil {
		return database.WrapDBError(err)
	}

	// Присваиваем полученные ID обратно в структуры
	// Порядок RETURNING в PostgreSQL соответствует порядку VALUES (для INSERT).
	for i, id := range ids {
		if i < len(examples) {
			examples[i].ID = id
		}
	}

	return nil
}

// Update обновляет example.
func (r *Repo) Update(ctx context.Context, example *model.Example) error {
	if example == nil || example.SentenceEn == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Update(schema.Examples.String()).
		Set(schema.ExampleColumns.SentenceEn.String(), example.SentenceEn).
		Set(schema.ExampleColumns.SentenceRu.String(), example.SentenceRu).
		Set(schema.ExampleColumns.SourceName.String(), example.SourceName).
		Where(schema.ExampleColumns.ID.Eq(example.ID)).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}

// Delete удаляет example по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(schema.Examples.String()).
		Where(schema.ExampleColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}

// DeleteByMeaningID удаляет все examples для указанного meaning.
func (r *Repo) DeleteByMeaningID(ctx context.Context, meaningID int64) (int64, error) {
	query, args, err := database.Builder.
		Delete(schema.Examples.String()).
		Where(schema.ExampleColumns.MeaningID.Eq(meaningID)).
		ToSql()
	if err != nil {
		return 0, err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	return commandTag.RowsAffected(), nil
}


================================================================================

================================================================================
Файл: meaning/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/read.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает meaning по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (model.Meaning, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return model.Meaning{}, err
	}

	meaning, err := database.GetOne[model.Meaning](ctx, r.q, query, args...)
	if err != nil {
		return model.Meaning{}, err
	}
	return *meaning, nil
}

// GetByWordID возвращает все meanings для указанного слова.
func (r *Repo) GetByWordID(ctx context.Context, wordID int64) ([]model.Meaning, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.WordID.Eq(wordID)).
		OrderBy(schema.MeaningColumns.CreatedAt.OrderByASC()).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetByWordIDs возвращает все meanings для нескольких слов (batch loading).
func (r *Repo) GetByWordIDs(ctx context.Context, wordIDs []int64) ([]model.Meaning, error) {
	if len(wordIDs) == 0 {
		return make([]model.Meaning, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.WordID.In(wordIDs)).
		OrderBy(schema.MeaningColumns.WordID.OrderByASC(), schema.MeaningColumns.CreatedAt.OrderByASC()).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// List возвращает список meanings с фильтрацией и пагинацией.
func (r *Repo) List(ctx context.Context, filter *Filter, limit, offset int) ([]model.Meaning, error) {
	limit, offset = database.NormalizePagination(limit, offset)

	qb := database.Builder.
		Select(columns...).
		From(schema.Meanings.String())

	qb = applyFilter(qb, filter)

	qb = qb.
		OrderBy(schema.MeaningColumns.CreatedAt.OrderByDESC()).
		Limit(uint64(limit)).
		Offset(uint64(offset))

	query, args, err := qb.ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// Count возвращает количество meanings, соответствующих фильтру.
func (r *Repo) Count(ctx context.Context, filter *Filter) (int, error) {
	qb := database.Builder.Select("COUNT(*)").From(schema.Meanings.String())
	qb = applyFilter(qb, filter)

	query, args, err := qb.ToSql()
	if err != nil {
		return 0, err
	}

	return database.GetScalar[int](ctx, r.q, query, args...)
}

// Exists проверяет существование meaning по ID.
func (r *Repo) Exists(ctx context.Context, id int64) (bool, error) {
	query, args, err := database.Builder.
		Select("1").
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.ID.Eq(id)).
		Limit(1).
		ToSql()
	if err != nil {
		return false, err
	}

	return database.CheckExists(ctx, r.q, query, args...)
}

// applyFilter применяет фильтры к query builder.
func applyFilter(qb squirrel.SelectBuilder, filter *Filter) squirrel.SelectBuilder {
	if filter == nil {
		return qb
	}
	if filter.WordID != nil {
		qb = qb.Where(schema.MeaningColumns.WordID.Eq(*filter.WordID))
	}
	if filter.PartOfSpeech != nil {
		qb = qb.Where(schema.MeaningColumns.PartOfSpeech.Eq(*filter.PartOfSpeech))
	}
	if filter.LearningStatus != nil {
		qb = qb.Where(schema.MeaningColumns.LearningStatus.Eq(*filter.LearningStatus))
	}
	return qb
}


================================================================================

================================================================================
Файл: meaning/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/repository.go
================================================================================

package meaning

import (
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

var columns = []string{
	schema.MeaningColumns.ID.String(),
	schema.MeaningColumns.WordID.String(),
	schema.MeaningColumns.PartOfSpeech.String(),
	schema.MeaningColumns.DefinitionEn.String(),
	schema.MeaningColumns.TranslationRu.String(),
	schema.MeaningColumns.CefrLevel.String(),
	schema.MeaningColumns.ImageURL.String(),
	schema.MeaningColumns.LearningStatus.String(),
	schema.MeaningColumns.NextReviewAt.String(),
	schema.MeaningColumns.Interval.String(),
	schema.MeaningColumns.EaseFactor.String(),
	schema.MeaningColumns.ReviewCount.String(),
	schema.MeaningColumns.CreatedAt.String(),
	schema.MeaningColumns.UpdatedAt.String(),
}

// Filter содержит параметры фильтрации для запросов поиска.
type Filter struct {
	WordID         *int64
	PartOfSpeech   *model.PartOfSpeech
	LearningStatus *model.LearningStatus
}

// SRSUpdate содержит поля для обновления SRS данных.
type SRSUpdate struct {
	LearningStatus model.LearningStatus
	NextReviewAt   *time.Time
	Interval       *int
	EaseFactor     *float64
	ReviewCount    *int
}

// Repo — реализация репозитория для работы с meanings.
type Repo struct {
	q     database.Querier
	clock database.Clock
}

// Option — функциональная опция для конфигурации Repo.
type Option func(*Repo)

// WithClock устанавливает объект clock для работы с временем.
func WithClock(c database.Clock) Option {
	return func(r *Repo) {
		r.clock = c
	}
}

// New создаёт новый репозиторий.
func New(q database.Querier, opts ...Option) *Repo {
	r := &Repo{
		q:     q,
		clock: database.DefaultClock,
	}

	for _, opt := range opts {
		opt(r)
	}

	return r
}


================================================================================

================================================================================
Файл: meaning/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/repository_test.go
================================================================================

package meaning_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var meaningColumns = []string{
	"id", "word_id", "part_of_speech", "definition_en", "translation_ru",
	"cefr_level", "image_url", "learning_status", "next_review_at",
	"interval", "ease_factor", "review_count", "created_at", "updated_at",
}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		m := &model.Meaning{
			WordID:        1,
			PartOfSpeech:  model.PartOfSpeechNoun,
			TranslationRu: "привет",
			DefinitionEn:  ptr("a greeting"),
		}

		mock.ExpectQuery(`INSERT INTO meanings`).
			WithArgs(
				int64(1),                // word_id
				model.PartOfSpeechNoun,  // part_of_speech
				"a greeting",            // definition_en
				"привет",                // translation_ru
				nil,                     // cefr_level
				nil,                     // image_url
				model.LearningStatusNew, // learning_status (default)
				nil,                     // next_review_at
				nil,                     // interval
				nil,                     // ease_factor
				nil,                     // review_count
				clock.Now(),             // created_at
				clock.Now(),             // updated_at
			).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, m)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.ID != 1 {
			t.Errorf("expected ID=1, got %d", m.ID)
		}
		if m.LearningStatus != model.LearningStatusNew {
			t.Errorf("expected status=new, got %s", m.LearningStatus)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil meaning", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing word_id", func(t *testing.T) {
		m := &model.Meaning{TranslationRu: "тест"}

		err := repo.Create(ctx, m)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing translation", func(t *testing.T) {
		m := &model.Meaning{WordID: 1}

		err := repo.Create(ctx, m)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("default part_of_speech", func(t *testing.T) {
		m := &model.Meaning{
			WordID:        1,
			TranslationRu: "тест",
		}

		mock.ExpectQuery(`INSERT INTO meanings`).
			WithArgs(
				int64(1),
				model.PartOfSpeechOther, // default
				nil,
				"тест",
				nil, nil, model.LearningStatusNew, nil, nil, nil, nil,
				clock.Now(), clock.Now(),
			).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, m)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.PartOfSpeech != model.PartOfSpeechOther {
			t.Errorf("expected part_of_speech=other, got %s", m.PartOfSpeech)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", "a greeting", "привет", "A1", nil, "new", nil, nil, 2.5, 0, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		m, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.ID != 1 {
			t.Errorf("expected ID=1, got %d", m.ID)
		}
		if m.TranslationRu != "привет" {
			t.Errorf("expected translation='привет', got %q", m.TranslationRu)
		}
		if m.PartOfSpeech != model.PartOfSpeechNoun {
			t.Errorf("expected part_of_speech=noun, got %s", m.PartOfSpeech)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByWordID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "привет", nil, nil, "new", nil, nil, nil, nil, now, now).
			AddRow(2, 1, "verb", nil, "приветствовать", nil, nil, "learning", nil, nil, nil, nil, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE word_id = \$1 ORDER BY created_at ASC`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		meanings, err := repo.GetByWordID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 2 {
			t.Errorf("expected 2 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows(meaningColumns)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		meanings, err := repo.GetByWordID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if meanings == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(meanings) != 0 {
			t.Errorf("expected 0 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DeleteByWordID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("deletes multiple", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		count, err := repo.DeleteByWordID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 3 {
			t.Errorf("expected count=3, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("no rows affected", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		count, err := repo.DeleteByWordID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 0 {
			t.Errorf("expected count=0, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

// Helper function
func ptr(s string) *string {
	return &s
}


================================================================================

================================================================================
Файл: meaning/srs.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/srs.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetDueForReview возвращает meanings, которые нужно повторить (next_review_at < NOW()).
func (r *Repo) GetDueForReview(ctx context.Context, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.NextReviewAt.Lt(r.clock.Now())).
		OrderBy(schema.MeaningColumns.NextReviewAt.OrderByASC()).
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetByStatus возвращает meanings с указанным статусом обучения.
func (r *Repo) GetByStatus(ctx context.Context, status model.LearningStatus, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(schema.MeaningColumns.LearningStatus.Eq(status)).
		OrderBy(schema.MeaningColumns.CreatedAt.OrderByASC()).
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetStudyQueue возвращает очередь для изучения.
func (r *Repo) GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	now := r.clock.Now()

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Meanings.String()).
		Where(squirrel.Or{
			schema.MeaningColumns.LearningStatus.Eq(model.LearningStatusNew),
			schema.MeaningColumns.NextReviewAt.Lt(now),
		}).
		OrderBy("COALESCE(" + schema.MeaningColumns.NextReviewAt.String() + ", " + schema.MeaningColumns.CreatedAt.String() + ") ASC").
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetStats возвращает статистику.
// Используем SQL Aliases (as total_words), чтобы scany мог замапить колонки на поля структуры Stats.
func (r *Repo) GetStats(ctx context.Context) (*model.Stats, error) {
	now := r.clock.Now()

	query := `
		SELECT 
			COUNT(DISTINCT ` + schema.MeaningColumns.WordID.String() + `) as total_words,
			COUNT(*) FILTER (WHERE ` + schema.MeaningColumns.LearningStatus.String() + ` = $1) as mastered_count,
			COUNT(*) FILTER (WHERE ` + schema.MeaningColumns.LearningStatus.String() + ` = $2) as learning_count,
			COUNT(*) FILTER (WHERE ` + schema.MeaningColumns.NextReviewAt.String() + ` < $3 OR ` + schema.MeaningColumns.LearningStatus.String() + ` = $4) as due_for_review_count
		FROM ` + schema.Meanings.String() + `
	`

	return database.GetOne[model.Stats](ctx, r.q, query,
		model.LearningStatusMastered,
		model.LearningStatusLearning,
		now,
		model.LearningStatusNew,
	)
}

// UpdateSRS обновляет только SRS-поля meaning.
func (r *Repo) UpdateSRS(ctx context.Context, id int64, srs *SRSUpdate) error {
	if srs == nil {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	qb := database.Builder.
		Update(schema.Meanings.String()).
		Set(schema.MeaningColumns.LearningStatus.String(), srs.LearningStatus).
		Set(schema.MeaningColumns.UpdatedAt.String(), now).
		Where(squirrel.Eq{schema.MeaningColumns.ID.String(): id})

	if srs.NextReviewAt != nil {
		qb = qb.Set(schema.MeaningColumns.NextReviewAt.String(), srs.NextReviewAt)
	}
	if srs.Interval != nil {
		qb = qb.Set(schema.MeaningColumns.Interval.String(), srs.Interval)
	}
	if srs.EaseFactor != nil {
		qb = qb.Set(schema.MeaningColumns.EaseFactor.String(), srs.EaseFactor)
	}
	if srs.ReviewCount != nil {
		qb = qb.Set(schema.MeaningColumns.ReviewCount.String(), srs.ReviewCount)
	}

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}


================================================================================

================================================================================
Файл: meaning/srs_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/srs_test.go
================================================================================

package meaning_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_GetDueForReview(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns due meanings", func(t *testing.T) {
		pastTime := clock.Now().Add(-1 * time.Hour)
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "тест", nil, nil, "review", pastTime, 7, 2.5, 3, pastTime, pastTime)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE next_review_at < \$1 ORDER BY next_review_at ASC LIMIT 10`).
			WithArgs(clock.Now()).
			WillReturnRows(rows)

		meanings, err := repo.GetDueForReview(ctx, 0) // default limit

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 1 {
			t.Errorf("expected 1 meaning, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByStatus(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("returns meanings with status", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "тест", nil, nil, "new", nil, nil, nil, nil, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE learning_status = \$1 ORDER BY created_at ASC LIMIT 10`).
			WithArgs(model.LearningStatusNew).
			WillReturnRows(rows)

		meanings, err := repo.GetByStatus(ctx, model.LearningStatusNew, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 1 {
			t.Errorf("expected 1 meaning, got %d", len(meanings))
		}
		if meanings[0].LearningStatus != model.LearningStatusNew {
			t.Errorf("expected status=new, got %s", meanings[0].LearningStatus)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetStudyQueue(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns new and due meanings", func(t *testing.T) {
		now := clock.Now()
		pastTime := now.Add(-1 * time.Hour)
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "новое", nil, nil, "new", nil, nil, nil, nil, now, now).
			AddRow(2, 2, "verb", nil, "на повторение", nil, nil, "review", pastTime, 7, 2.5, 3, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE \(learning_status = \$1 OR next_review_at < \$2\)`).
			WithArgs(model.LearningStatusNew, now).
			WillReturnRows(rows)

		meanings, err := repo.GetStudyQueue(ctx, 10)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 2 {
			t.Errorf("expected 2 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetStats(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns stats", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"total", "mastered", "learning", "due"}).
			AddRow(100, 50, 30, 20)

		mock.ExpectQuery(`SELECT (.+) FROM meanings`).
			WithArgs(
				model.LearningStatusMastered,
				model.LearningStatusLearning,
				clock.Now(),
				model.LearningStatusNew,
			).
			WillReturnRows(rows)

		stats, err := repo.GetStats(ctx)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if stats.TotalWords != 100 {
			t.Errorf("expected TotalWords=100, got %d", stats.TotalWords)
		}
		if stats.MasteredCount != 50 {
			t.Errorf("expected MasteredCount=50, got %d", stats.MasteredCount)
		}
		if stats.LearningCount != 30 {
			t.Errorf("expected LearningCount=30, got %d", stats.LearningCount)
		}
		if stats.DueForReviewCount != 20 {
			t.Errorf("expected DueForReviewCount=20, got %d", stats.DueForReviewCount)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_UpdateSRS(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("success with all fields", func(t *testing.T) {
		nextReview := clock.Now().Add(24 * time.Hour)
		interval := 7
		easeFactor := 2.5
		reviewCount := 5

		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusLearning,
			NextReviewAt:   &nextReview,
			Interval:       &interval,
			EaseFactor:     &easeFactor,
			ReviewCount:    &reviewCount,
		}

		// Порядок: SET поля (learning_status, updated_at, next_review_at, interval, ease_factor, review_count), затем WHERE id
		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusLearning,
				clock.Now(),
				nextReview,
				interval,
				easeFactor,
				reviewCount,
				int64(1), // id в WHERE в конце
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.UpdateSRS(ctx, 1, srs)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("success with minimal fields", func(t *testing.T) {
		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusMastered,
		}

		// Только learning_status, updated_at, затем id в WHERE
		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusMastered,
				clock.Now(),
				int64(1),
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.UpdateSRS(ctx, 1, srs)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil srs", func(t *testing.T) {
		err := repo.UpdateSRS(ctx, 1, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("not found", func(t *testing.T) {
		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusNew,
		}

		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusNew,
				clock.Now(),
				int64(999),
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 0))

		err := repo.UpdateSRS(ctx, 999, srs)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}


================================================================================

================================================================================
Файл: meaning/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/write.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Create создаёт новое meaning в базе данных.
func (r *Repo) Create(ctx context.Context, meaning *model.Meaning) error {
	if meaning == nil {
		return database.ErrInvalidInput
	}

	if meaning.WordID == 0 || meaning.TranslationRu == "" {
		return database.ErrInvalidInput
	}

	// Значения по умолчанию
	if meaning.LearningStatus == "" {
		meaning.LearningStatus = model.LearningStatusNew
	}
	if meaning.PartOfSpeech == "" {
		meaning.PartOfSpeech = model.PartOfSpeechOther
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Insert(schema.Meanings.String()).
		Columns(
			schema.MeaningColumns.WordID.String(),
			schema.MeaningColumns.PartOfSpeech.String(),
			schema.MeaningColumns.DefinitionEn.String(),
			schema.MeaningColumns.TranslationRu.String(),
			schema.MeaningColumns.CefrLevel.String(),
			schema.MeaningColumns.ImageURL.String(),
			schema.MeaningColumns.LearningStatus.String(),
			schema.MeaningColumns.NextReviewAt.String(),
			schema.MeaningColumns.Interval.String(),
			schema.MeaningColumns.EaseFactor.String(),
			schema.MeaningColumns.ReviewCount.String(),
			schema.MeaningColumns.CreatedAt.String(),
			schema.MeaningColumns.UpdatedAt.String(),
		).
		Values(
			meaning.WordID,
			meaning.PartOfSpeech,
			meaning.DefinitionEn, // Прямая передача *string
			meaning.TranslationRu,
			meaning.CefrLevel, // Прямая передача *string
			meaning.ImageURL,  // Прямая передача *string
			meaning.LearningStatus,
			meaning.NextReviewAt, // Прямая передача *time.Time
			meaning.Interval,     // Прямая передача *int
			meaning.EaseFactor,   // Прямая передача *float64
			meaning.ReviewCount,  // Прямая передача *int
			now,
			now,
		).
		Suffix(schema.MeaningColumns.ID.Returning()).
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&meaning.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	meaning.CreatedAt = now
	meaning.UpdatedAt = now
	return nil
}

// Update обновляет лингвистические поля meaning (не SRS).
func (r *Repo) Update(ctx context.Context, meaning *model.Meaning) error {
	if meaning == nil || meaning.TranslationRu == "" {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Update(schema.Meanings.String()).
		Set(schema.MeaningColumns.WordID.String(), meaning.WordID).
		Set(schema.MeaningColumns.PartOfSpeech.String(), meaning.PartOfSpeech).
		Set(schema.MeaningColumns.DefinitionEn.String(), meaning.DefinitionEn). // Прямая передача
		Set(schema.MeaningColumns.TranslationRu.String(), meaning.TranslationRu).
		Set(schema.MeaningColumns.CefrLevel.String(), meaning.CefrLevel). // Прямая передача
		Set(schema.MeaningColumns.ImageURL.String(), meaning.ImageURL).   // Прямая передача
		Set(schema.MeaningColumns.UpdatedAt.String(), now).
		Where(squirrel.Eq{schema.MeaningColumns.ID.String(): meaning.ID}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	meaning.UpdatedAt = now
	return nil
}

// Delete удаляет meaning по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(schema.Meanings.String()).
		Where(squirrel.Eq{schema.MeaningColumns.ID.String(): id}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}
	return nil
}

// DeleteByWordID удаляет все meanings для указанного слова.
func (r *Repo) DeleteByWordID(ctx context.Context, wordID int64) (int64, error) {
	query, args, err := database.Builder.
		Delete(schema.Meanings.String()).
		Where(squirrel.Eq{schema.MeaningColumns.WordID.String(): wordID}).
		ToSql()
	if err != nil {
		return 0, err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	return commandTag.RowsAffected(), nil
}


================================================================================

================================================================================
Файл: meaningtag/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaningtag/repository.go
================================================================================

package meaningtag

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repo struct {
	q database.Querier
}

func New(q database.Querier) *Repo {
	return &Repo{q: q}
}

func (r *Repo) AttachTag(ctx context.Context, meaningID, tagID int64) error {
	query, args, err := database.Builder.
		Insert(schema.MeaningTags.String()).
		Columns(
			schema.MeaningTagColumns.MeaningID.String(),
			schema.MeaningTagColumns.TagID.String(),
		).
		Values(meaningID, tagID).
		Suffix("ON CONFLICT DO NOTHING").
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) AttachTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	if len(tagIDs) == 0 {
		return nil
	}
	qb := database.Builder.
		Insert(schema.MeaningTags.String()).
		Columns(
			schema.MeaningTagColumns.MeaningID.String(),
			schema.MeaningTagColumns.TagID.String(),
		)

	for _, tagID := range tagIDs {
		qb = qb.Values(meaningID, tagID)
	}
	qb = qb.Suffix("ON CONFLICT DO NOTHING")

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) DetachTag(ctx context.Context, meaningID, tagID int64) error {
	query, args, err := database.Builder.
		Delete(schema.MeaningTags.String()).
		Where(squirrel.And{
			schema.MeaningTagColumns.MeaningID.Eq(meaningID),
			schema.MeaningTagColumns.TagID.Eq(tagID),
		}).
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) DetachAllFromMeaning(ctx context.Context, meaningID int64) error {
	query, args, err := database.Builder.
		Delete(schema.MeaningTags.String()).
		Where(schema.MeaningTagColumns.MeaningID.Eq(meaningID)).
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

// GetTagIDsByMeaningID возвращает ID тегов для meaning.
// Используем SelectScalars для получения []int64.
func (r *Repo) GetTagIDsByMeaningID(ctx context.Context, meaningID int64) ([]int64, error) {
	query, args, err := database.Builder.
		Select(schema.MeaningTagColumns.TagID.String()).
		From(schema.MeaningTags.String()).
		Where(schema.MeaningTagColumns.MeaningID.Eq(meaningID)).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.SelectScalars[int64](ctx, r.q, query, args...)
}

// GetMeaningIDsByTagID возвращает ID meanings для tag.
func (r *Repo) GetMeaningIDsByTagID(ctx context.Context, tagID int64) ([]int64, error) {
	query, args, err := database.Builder.
		Select(schema.MeaningTagColumns.MeaningID.String()).
		From(schema.MeaningTags.String()).
		Where(schema.MeaningTagColumns.TagID.Eq(tagID)).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.SelectScalars[int64](ctx, r.q, query, args...)
}

// GetByMeaningIDs возвращает все связи для нескольких meanings.
// Используем Select для получения списка структур.
func (r *Repo) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error) {
	if len(meaningIDs) == 0 {
		return make([]model.MeaningTag, 0), nil
	}
	query, args, err := database.Builder.
		Select(
			schema.MeaningTagColumns.MeaningID.String(),
			schema.MeaningTagColumns.TagID.String(),
		).
		From(schema.MeaningTags.String()).
		Where(schema.MeaningTagColumns.MeaningID.In(meaningIDs)).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.Select[model.MeaningTag](ctx, r.q, query, args...)
}

func (r *Repo) SyncTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	// TODO: Оптимизировать через вычисление Diff (insert/delete), чтобы избежать bloat таблицы
	if err := r.DetachAllFromMeaning(ctx, meaningID); err != nil {
		return err
	}
	return r.AttachTags(ctx, meaningID, tagIDs)
}


================================================================================

================================================================================
Файл: meaningtag/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaningtag/repository_test.go
================================================================================

package meaningtag_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database/meaningtag"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_AttachTag(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(2)).
			WillReturnResult(pgxmock.NewResult("INSERT", 1))

		err := repo.AttachTag(ctx, 1, 2)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_AttachTags(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("attaches multiple", func(t *testing.T) {
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(2), int64(1), int64(3), int64(1), int64(4)).
			WillReturnResult(pgxmock.NewResult("INSERT", 3))

		err := repo.AttachTags(ctx, 1, []int64{2, 3, 4})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty list", func(t *testing.T) {
		err := repo.AttachTags(ctx, 1, []int64{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
	})
}

func TestRepo_DetachTag(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1 AND tag_id = \$2`).
			WithArgs(int64(1), int64(2)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.DetachTag(ctx, 1, 2)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DetachAllFromMeaning(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		err := repo.DetachAllFromMeaning(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetTagIDsByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("returns tag ids", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"tag_id"}).
			AddRow(1).
			AddRow(2).
			AddRow(3)

		mock.ExpectQuery(`SELECT tag_id FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		ids, err := repo.GetTagIDsByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(ids) != 3 {
			t.Errorf("expected 3 ids, got %d", len(ids))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"tag_id"})

		mock.ExpectQuery(`SELECT tag_id FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		ids, err := repo.GetTagIDsByMeaningID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ids == nil {
			t.Error("expected empty slice, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByMeaningIDs(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("returns all relations", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"meaning_id", "tag_id"}).
			AddRow(1, 10).
			AddRow(1, 20).
			AddRow(2, 10)

		mock.ExpectQuery(`SELECT meaning_id, tag_id FROM meanings_tags WHERE meaning_id IN \(\$1,\$2\)`).
			WithArgs(int64(1), int64(2)).
			WillReturnRows(rows)

		relations, err := repo.GetByMeaningIDs(ctx, []int64{1, 2})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(relations) != 3 {
			t.Errorf("expected 3 relations, got %d", len(relations))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty input", func(t *testing.T) {
		relations, err := repo.GetByMeaningIDs(ctx, []int64{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if relations == nil {
			t.Error("expected empty slice, got nil")
		}
	})
}

func TestRepo_SyncTags(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("syncs tags", func(t *testing.T) {
		// Сначала удаляет старые
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 2))

		// Затем добавляет новые
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(5), int64(1), int64(6)).
			WillReturnResult(pgxmock.NewResult("INSERT", 2))

		err := repo.SyncTags(ctx, 1, []int64{5, 6})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}


================================================================================

================================================================================
Файл: schema/schema.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/schema/schema.go
================================================================================

package schema

import (
	"github.com/Masterminds/squirrel"
)

// Table — описание таблицы для использования в Squirrel
type Table string

// String реализует интерфейс fmt.Stringer (и подходит для squirrel)
func (t Table) String() string { return string(t) }

// Column — описание колонки
type Column string

func (c Column) String() string { return string(c) }

// --- Вспомогательные функции для работы с Squirrel ---

// Eq создает условие равенства для Where с использованием Column
func (c Column) Eq(value interface{}) squirrel.Eq {
	return squirrel.Eq{c.String(): value}
}

// In создает условие IN для Where с использованием Column
func (c Column) In(values interface{}) squirrel.Eq {
	return squirrel.Eq{c.String(): values}
}

// ILike создает условие ILIKE для Where с использованием Column
func (c Column) ILike(pattern string) squirrel.ILike {
	return squirrel.ILike{c.String(): pattern}
}

// Lt создает условие < для Where с использованием Column
func (c Column) Lt(value interface{}) squirrel.Lt {
	return squirrel.Lt{c.String(): value}
}

// OrderByASC создает строку для OrderBy с ASC
func (c Column) OrderByASC() string {
	return c.String() + " ASC"
}

// OrderByDESC создает строку для OrderBy с DESC
func (c Column) OrderByDESC() string {
	return c.String() + " DESC"
}

// OrderBy создает строку для OrderBy с указанным направлением
func (c Column) OrderBy(direction string) string {
	return c.String() + " " + direction
}

// Returning создает строку для RETURNING
func (c Column) Returning() string {
	return "RETURNING " + c.String()
}

// ColumnsToStrings преобразует список Column в []string
func ColumnsToStrings(cols ...Column) []string {
	result := make([]string, len(cols))
	for i, col := range cols {
		result[i] = col.String()
	}
	return result
}

// Определяем таблицы
const (
	Words       Table = "words"
	Meanings    Table = "meanings"
	Examples    Table = "examples"
	Tags        Table = "tags"
	MeaningTags Table = "meanings_tags"
)

var (
	WordColumns = struct {
		ID            Column
		Text          Column
		Transcription Column
		AudioURL      Column
		FrequencyRank Column
		CreatedAt     Column
	}{
		ID:            "id",
		Text:          "text",
		Transcription: "transcription",
		AudioURL:      "audio_url",
		FrequencyRank: "frequency_rank",
		CreatedAt:     "created_at",
	}

	MeaningColumns = struct {
		ID             Column
		WordID         Column
		TranslationRu  Column
		PartOfSpeech   Column
		DefinitionEn   Column
		CefrLevel      Column
		ImageURL       Column
		LearningStatus Column
		NextReviewAt   Column
		Interval       Column
		EaseFactor     Column
		ReviewCount    Column
		CreatedAt      Column
		UpdatedAt      Column
	}{
		ID:             "id",
		WordID:         "word_id",
		TranslationRu:  "translation_ru",
		PartOfSpeech:   "part_of_speech",
		DefinitionEn:   "definition_en",
		CefrLevel:      "cefr_level",
		ImageURL:       "image_url",
		LearningStatus: "learning_status",
		NextReviewAt:   "next_review_at",
		Interval:       "interval",
		EaseFactor:     "ease_factor",
		ReviewCount:    "review_count",
		CreatedAt:      "created_at",
		UpdatedAt:      "updated_at",
	}

	ExampleColumns = struct {
		ID         Column
		MeaningID  Column
		SentenceEn Column
		SentenceRu Column
		SourceName Column
		CreatedAt  Column
		UpdatedAt  Column
	}{
		ID:         "id",
		MeaningID:  "meaning_id",
		SentenceEn: "sentence_en",
		SentenceRu: "sentence_ru",
		SourceName: "source_name",
		CreatedAt:  "created_at",
		UpdatedAt:  "updated_at",
	}

	TagColumns = struct {
		ID        Column
		Name      Column
		CreatedAt Column
		UpdatedAt Column
	}{
		ID:        "id",
		Name:      "name",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	}

	MeaningTagColumns = struct {
		MeaningID Column
		TagID     Column
	}{
		MeaningID: "meaning_id",
		TagID:     "tag_id",
	}
)


================================================================================

================================================================================
Файл: tag/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/read.go
================================================================================

package tag

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает tag по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (*model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Tags.String()).
		Where(schema.TagColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.GetOne[model.Tag](ctx, r.q, query, args...)
}

// GetByName возвращает tag по имени.
func (r *Repo) GetByName(ctx context.Context, name string) (model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Tags.String()).
		Where(schema.TagColumns.Name.Eq(name)).
		ToSql()
	if err != nil {
		return model.Tag{}, err
	}

	tag, err := database.GetOne[model.Tag](ctx, r.q, query, args...)
	if err != nil {
		return model.Tag{}, err
	}
	return *tag, nil
}

// GetByNames возвращает tags по списку имён.
func (r *Repo) GetByNames(ctx context.Context, names []string) ([]model.Tag, error) {
	if len(names) == 0 {
		return make([]model.Tag, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Tags.String()).
		Where(schema.TagColumns.Name.In(names)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}

// GetByIDs возвращает tags по списку ID.
func (r *Repo) GetByIDs(ctx context.Context, ids []int64) ([]model.Tag, error) {
	if len(ids) == 0 {
		return make([]model.Tag, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Tags.String()).
		Where(schema.TagColumns.ID.In(ids)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}

// List возвращает все tags.
func (r *Repo) List(ctx context.Context) ([]model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Tags.String()).
		OrderBy(schema.TagColumns.Name.OrderByASC()).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}


================================================================================

================================================================================
Файл: tag/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/repository.go
================================================================================

package tag

import (
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
)

var columns = []string{
	schema.TagColumns.ID.String(),
	schema.TagColumns.Name.String(),
}

// Repo — реализация репозитория для работы с tags.
type Repo struct {
	q database.Querier
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repo {
	return &Repo{q: q}
}


================================================================================

================================================================================
Файл: tag/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/repository_test.go
================================================================================

package tag_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/tag"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var tagColumns = []string{"id", "name"}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		tg := &model.Tag{Name: "vocabulary"}

		mock.ExpectQuery(`INSERT INTO tags`).
			WithArgs("vocabulary").
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, tg)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 1 {
			t.Errorf("expected ID=1, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil tag", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("empty name", func(t *testing.T) {
		tg := &model.Tag{Name: "   "}

		err := repo.Create(ctx, tg)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "business")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		tg, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.Name != "business" {
			t.Errorf("expected Name='business', got %q", tg.Name)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByName(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "travel")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("travel").
			WillReturnRows(rows)

		tg, err := repo.GetByName(ctx, "travel")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.Name != "travel" {
			t.Errorf("expected Name='travel', got %q", tg.Name)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("nonexistent").
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByName(ctx, "nonexistent")

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByNames(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).
			AddRow(1, "business").
			AddRow(2, "travel")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name IN \(\$1,\$2\)`).
			WithArgs("business", "travel").
			WillReturnRows(rows)

		tags, err := repo.GetByNames(ctx, []string{"business", "travel"})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(tags) != 2 {
			t.Errorf("expected 2 tags, got %d", len(tags))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty input", func(t *testing.T) {
		tags, err := repo.GetByNames(ctx, []string{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tags == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(tags) != 0 {
			t.Errorf("expected 0 tags, got %d", len(tags))
		}
	})
}

func TestRepo_List(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("returns all", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).
			AddRow(1, "a-tag").
			AddRow(2, "b-tag")

		mock.ExpectQuery(`SELECT (.+) FROM tags ORDER BY name ASC`).
			WillReturnRows(rows)

		tags, err := repo.List(ctx)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(tags) != 2 {
			t.Errorf("expected 2 tags, got %d", len(tags))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM tags WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM tags WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetOrCreate(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("returns existing", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "existing")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("existing").
			WillReturnRows(rows)

		tg, err := repo.GetOrCreate(ctx, "existing")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 1 {
			t.Errorf("expected ID=1, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("creates new", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("new-tag").
			WillReturnError(pgx.ErrNoRows)

		mock.ExpectQuery(`INSERT INTO tags`).
			WithArgs("new-tag").
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(5))

		tg, err := repo.GetOrCreate(ctx, "new-tag")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 5 {
			t.Errorf("expected ID=5, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty name", func(t *testing.T) {
		_, err := repo.GetOrCreate(ctx, "   ")

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}


================================================================================

================================================================================
Файл: tag/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/write.go
================================================================================

package tag

import (
	"context"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Create создаёт новый tag.
func (r *Repo) Create(ctx context.Context, tag *model.Tag) error {
	if tag == nil {
		return database.ErrInvalidInput
	}

	name := strings.TrimSpace(tag.Name)
	if name == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Insert(schema.Tags.String()).
		Columns(schema.TagColumns.Name.String()).
		Values(name).
		Suffix(schema.TagColumns.ID.Returning()).
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&tag.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	tag.Name = name
	return nil
}

// GetOrCreate возвращает существующий tag или создаёт новый.
func (r *Repo) GetOrCreate(ctx context.Context, name string) (model.Tag, error) {
	name = strings.TrimSpace(name)
	if name == "" {
		return model.Tag{}, database.ErrInvalidInput
	}

	// Пробуем найти существующий
	tag, err := r.GetByName(ctx, name)
	if err == nil {
		return tag, nil
	}

	if err != database.ErrNotFound {
		return model.Tag{}, err
	}

	// Создаём новый
	tagPtr := &model.Tag{Name: name}
	if err := r.Create(ctx, tagPtr); err != nil {
		// Возможен race condition — проверяем ещё раз
		if database.IsDuplicateError(err) {
			return r.GetByName(ctx, name)
		}
		return model.Tag{}, err
	}

	return *tagPtr, nil
}

// Delete удаляет tag по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(schema.Tags.String()).
		Where(schema.TagColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}


================================================================================

================================================================================
Файл: testutil/testutil.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/testutil/testutil.go
================================================================================

// Package testutil содержит утилиты для тестирования репозиториев.
package testutil

import (
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

// MockClock — мок для database.Clock.
type MockClock struct {
	Time time.Time
}

// Now возвращает заранее заданное время.
func (m *MockClock) Now() time.Time {
	return m.Time
}

// FixedTime возвращает фиксированное время для тестов.
func FixedTime() time.Time {
	return time.Date(2025, 1, 15, 10, 30, 0, 0, time.UTC)
}

// NewMockClock создаёт MockClock с фиксированным временем.
func NewMockClock() *MockClock {
	return &MockClock{Time: FixedTime()}
}

// Compile-time проверка.
var _ database.Clock = (*MockClock)(nil)

// NewMockQuerier создаёт мок Querier для тестов.
func NewMockQuerier(t *testing.T) (database.Querier, pgxmock.PgxPoolIface) {
	t.Helper()

	mock, err := pgxmock.NewPool()
	if err != nil {
		t.Fatalf("failed to create pgxmock: %v", err)
	}

	t.Cleanup(func() {
		mock.Close()
	})

	return mock, mock
}

// ExpectationsWereMet проверяет, что все ожидания pgxmock выполнены.
func ExpectationsWereMet(t *testing.T, mock pgxmock.PgxPoolIface) {
	t.Helper()

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("unfulfilled expectations: %v", err)
	}
}


================================================================================

================================================================================
Файл: tx.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tx.go
================================================================================

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
)

// TxManager управляет транзакциями и создаёт репозитории с tx.
type TxManager struct {
	pool *pgxpool.Pool
}

// NewTxManager создаёт новый TxManager.
func NewTxManager(pool *pgxpool.Pool) *TxManager {
	return &TxManager{pool: pool}
}

// RunInTx выполняет функцию в рамках транзакции.
// Querier передаётся в функцию для создания репозиториев.
func (m *TxManager) RunInTx(ctx context.Context, fn func(ctx context.Context, tx Querier) error) error {
	return WithTx(ctx, m.pool, fn)
}

// Pool возвращает пул соединений с БД.
func (m *TxManager) Pool() *pgxpool.Pool {
	return m.pool
}


================================================================================

================================================================================
Файл: word/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/read.go
================================================================================

package word

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

func (r *Repo) GetByID(ctx context.Context, id int64) (model.Word, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Words.String()).
		Where(schema.WordColumns.ID.Eq(id)).
		ToSql()
	if err != nil {
		return model.Word{}, err
	}

	word, err := database.GetOne[model.Word](ctx, r.q, query, args...)
	if err != nil {
		return model.Word{}, err
	}
	return *word, nil
}

func (r *Repo) GetByText(ctx context.Context, text string) (model.Word, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(schema.Words.String()).
		Where(schema.WordColumns.Text.Eq(text)).
		ToSql()
	if err != nil {
		return model.Word{}, err
	}

	word, err := database.GetOne[model.Word](ctx, r.q, query, args...)
	if err != nil {
		return model.Word{}, err
	}
	return *word, nil
}

func (r *Repo) List(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error) {
	limit, offset = database.NormalizePagination(limit, offset)

	qb := database.Builder.
		Select(columns...).
		From(schema.Words.String())

	qb = applyFilter(qb, filter)

	qb = qb.
		OrderBy(schema.WordColumns.CreatedAt.OrderByDESC()).
		Limit(uint64(limit)).
		Offset(uint64(offset))

	query, args, err := qb.ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Word](ctx, r.q, query, args...)
}

func (r *Repo) Count(ctx context.Context, filter *model.WordFilter) (int, error) {
	qb := database.Builder.Select("COUNT(*)").From(schema.Words.String())
	qb = applyFilter(qb, filter)

	query, args, err := qb.ToSql()
	if err != nil {
		return 0, err
	}

	return database.GetScalar[int](ctx, r.q, query, args...)
}

func (r *Repo) Exists(ctx context.Context, id int64) (bool, error) {
	query, args, err := database.Builder.
		Select("1").
		From(schema.Words.String()).
		Where(schema.WordColumns.ID.Eq(id)).
		Limit(1).
		ToSql()
	if err != nil {
		return false, err
	}
	return database.CheckExists(ctx, r.q, query, args...)
}

func applyFilter(qb squirrel.SelectBuilder, filter *model.WordFilter) squirrel.SelectBuilder {
	if filter == nil {
		return qb
	}
	if filter.Search != nil && *filter.Search != "" {
		return qb.Where(schema.WordColumns.Text.ILike("%" + *filter.Search + "%"))
	}
	return qb
}


================================================================================

================================================================================
Файл: word/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/repository.go
================================================================================

// Package word содержит репозиторий для работы с таблицей words.
package word

import (
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
)

// columns — список колонок таблицы words.
var columns = []string{
	schema.WordColumns.ID.String(),
	schema.WordColumns.Text.String(),
	schema.WordColumns.Transcription.String(),
	schema.WordColumns.AudioURL.String(),
	schema.WordColumns.FrequencyRank.String(),
	schema.WordColumns.CreatedAt.String(),
}

// Repo — реализация репозитория для PostgreSQL.
type Repo struct {
	q     database.Querier
	clock database.Clock
}

// Option — функциональная опция для конфигурации Repo.
type Option func(*Repo)

// WithClock устанавливает кастомный clock (полезно для тестов).
func WithClock(c database.Clock) Option {
	return func(r *Repo) {
		r.clock = c
	}
}

// New создаёт новый репозиторий.
func New(q database.Querier, opts ...Option) *Repo {
	r := &Repo{
		q:     q,
		clock: database.DefaultClock,
	}

	for _, opt := range opts {
		opt(r)
	}

	return r
}


================================================================================

================================================================================
Файл: word/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/repository_test.go
================================================================================

package word_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/database/word"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := word.New(q, word.WithClock(clock))
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		w := &model.Word{
			Text:          "Hello",
			Transcription: ptr("həˈloʊ"),
			AudioURL:      ptr("https://example.com/hello.mp3"),
			FrequencyRank: intPtr(100),
		}

		transcription := "həˈloʊ"
		audioURL := "https://example.com/hello.mp3"
		freqRank := int64(100)
		rows := pgxmock.NewRows([]string{"id"}).AddRow(int64(1))
		mock.ExpectQuery(`INSERT INTO words`).
			WithArgs("hello", &transcription, &audioURL, &freqRank, clock.Now()).
			WillReturnRows(rows)

		err := repo.Create(ctx, w)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.ID != 1 {
			t.Errorf("expected ID=1, got %d", w.ID)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil word", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("empty text", func(t *testing.T) {
		w := &model.Word{Text: "   "}

		err := repo.Create(ctx, w)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("duplicate", func(t *testing.T) {
		w := &model.Word{Text: "duplicate"}

		mock.ExpectQuery(`INSERT INTO words`).
			WithArgs("duplicate", nil, nil, nil, clock.Now()).
			WillReturnError(pgx.ErrNoRows) // simplified; real error would be postgres duplicate key

		err := repo.Create(ctx, w)

		if err == nil {
			t.Error("expected error, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		now := time.Now()
		transcription := "həˈloʊ"
		audioURL := "https://example.com/hello.mp3"
		freqRank := int64(100)
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", &transcription, &audioURL, &freqRank, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		w, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.ID != 1 {
			t.Errorf("expected ID=1, got %d", w.ID)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM words WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByText(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("found with trimming and lowercasing", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text = \$1`).
			WithArgs("hello"). // trimmed and lowercased
			WillReturnRows(rows)

		w, err := repo.GetByText(ctx, "  HELLO  ")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text = \$1`).
			WithArgs("nonexistent").
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByText(ctx, "nonexistent")

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_List(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("without filter", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now).
			AddRow(int64(2), "world", nil, nil, nil, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words ORDER BY created_at DESC LIMIT 20 OFFSET 0`).
			WillReturnRows(rows)

		words, err := repo.List(ctx, nil, 0, 0) // default limit

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(words) != 2 {
			t.Errorf("expected 2 words, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("with search filter", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now)

		search := "hel"
		filter := &model.WordFilter{Search: &search}

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text ILIKE \$1 ORDER BY created_at DESC LIMIT 10 OFFSET 0`).
			WithArgs("%hel%").
			WillReturnRows(rows)

		words, err := repo.List(ctx, filter, 10, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(words) != 1 {
			t.Errorf("expected 1 word, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"})

		mock.ExpectQuery(`SELECT (.+) FROM words`).
			WillReturnRows(rows)

		words, err := repo.List(ctx, nil, 20, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if words == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(words) != 0 {
			t.Errorf("expected 0 words, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Count(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"count"}).AddRow(int64(42))

		mock.ExpectQuery(`SELECT COUNT\(\*\) FROM words`).
			WillReturnRows(rows)

		count, err := repo.Count(ctx, nil)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 42 {
			t.Errorf("expected count=42, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Update(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		w := &model.Word{
			ID:   1,
			Text: "Updated",
		}

		mock.ExpectExec(`UPDATE words SET`).
			WithArgs("updated", nil, nil, nil, int64(1)).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.Update(ctx, w)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.Text != "updated" {
			t.Errorf("expected text='updated', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		w := &model.Word{ID: 999, Text: "test"}

		mock.ExpectExec(`UPDATE words SET`).
			WithArgs("test", nil, nil, nil, int64(999)).
			WillReturnResult(pgxmock.NewResult("UPDATE", 0))

		err := repo.Update(ctx, w)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil word", func(t *testing.T) {
		err := repo.Update(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM words WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM words WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Exists(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("exists", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"1"}).AddRow(int64(1))

		mock.ExpectQuery(`SELECT 1 FROM words WHERE id = \$1 LIMIT 1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		exists, err := repo.Exists(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !exists {
			t.Error("expected exists=true")
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not exists", func(t *testing.T) {
		mock.ExpectQuery(`SELECT 1 FROM words WHERE id = \$1 LIMIT 1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		exists, err := repo.Exists(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if exists {
			t.Error("expected exists=false")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

// Helper functions
func ptr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}


================================================================================

================================================================================
Файл: word/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/write.go
================================================================================

package word

import (
	"context"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

func (r *Repo) Create(ctx context.Context, word *model.Word) error {
	if word == nil || strings.TrimSpace(word.Text) == "" {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Insert(schema.Words.String()).
		Columns(
			schema.WordColumns.Text.String(),
			schema.WordColumns.Transcription.String(),
			schema.WordColumns.AudioURL.String(),
			schema.WordColumns.FrequencyRank.String(),
			schema.WordColumns.CreatedAt.String(),
		).
		Values(
			word.Text,
			word.Transcription,
			word.AudioURL,
			word.FrequencyRank,
			now,
		).
		Suffix(schema.WordColumns.ID.Returning()).
		ToSql()
	if err != nil {
		return err
	}

	// Для возврата ID используем стандартный Scan, так как это одно поле
	err = r.q.QueryRow(ctx, query, args...).Scan(&word.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	word.CreatedAt = now
	return nil
}

func (r *Repo) Update(ctx context.Context, word *model.Word) error {
	if word == nil || strings.TrimSpace(word.Text) == "" {
		return database.ErrInvalidInput
	}

	text := strings.TrimSpace(strings.ToLower(word.Text))

	query, args, err := database.Builder.
		Update(schema.Words.String()).
		Set(schema.WordColumns.Text.String(), text).
		Set(schema.WordColumns.Transcription.String(), word.Transcription). // Прямая передача
		Set(schema.WordColumns.AudioURL.String(), word.AudioURL).
		Set(schema.WordColumns.FrequencyRank.String(), word.FrequencyRank).
		Where(schema.WordColumns.ID.Eq(word.ID)).
		ToSql()
	if err != nil {
		return err
	}

	cmd, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}
	if cmd.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	word.Text = text
	return nil
}

func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.Delete(schema.Words.String()).Where(schema.WordColumns.ID.Eq(id)).ToSql()
	if err != nil {
		return err
	}
	cmd, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}
	if cmd.RowsAffected() == 0 {
		return database.ErrNotFound
	}
	return nil
}


================================================================================
