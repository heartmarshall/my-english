Содержимое директории: /home/alodi/playground/my-english/backend_v2
Всего файлов собрано: 63
Пропущено файлов: 1

================================================================================


================================================================================
Файл: .docker-compose.env.example
Полный путь: /home/alodi/playground/my-english/backend_v2/.docker-compose.env.example
================================================================================

# Пример файла с переменными окружения для docker-compose
# Скопируйте этот файл в .env и настройте под свои нужды
# docker-compose автоматически загрузит переменные из .env файла

# Database Configuration
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=my_english
DB_PORT=5432
DB_SSLMODE=disable

# Server Configuration  
SERVER_PORT=8080

# Logging
LOG_LEVEL=info
LOG_FORMAT=json



================================================================================

================================================================================
Файл: .dockerignore
Полный путь: /home/alodi/playground/my-english/backend_v2/.dockerignore
================================================================================

# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
server
*.test
*.out

# Go workspace files
.idea/
.vscode/
*.swp
*.swo
*~

# Build artifacts
dist/
build/
bin/

# Dependencies
vendor/

# Test files
*_test.go
*.test

# Git
.git/
.gitignore
.gitattributes

# Documentation
*.md
README.md
docs/

# Docker files
Dockerfile*
docker-compose*.yml
.dockerignore

# CI/CD
.github/
.gitlab-ci.yml

# Environment files
.env
.env.local
.env.*.local
*.log

# OS files
.DS_Store
Thumbs.db

# IDE
.idea/
.vscode/
*.iml

# Temporary files
tmp/
temp/
*.tmp



================================================================================

================================================================================
Файл: .env
Полный путь: /home/alodi/playground/my-english/backend_v2/.env
================================================================================

# Пример файла с переменными окружения для docker-compose
# Скопируйте этот файл в .env и настройте под свои нужды
# docker-compose автоматически загрузит переменные из .env файла

# Database Configuration
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=my_english
DB_PORT=5432
DB_SSLMODE=disable

# Server Configuration  
SERVER_PORT=8080

# Logging
LOG_LEVEL=info
LOG_FORMAT=json



================================================================================

================================================================================
Файл: Dockerfile
Полный путь: /home/alodi/playground/my-english/backend_v2/Dockerfile
================================================================================

# Multi-stage build для оптимизации размера образа

# Stage 1: Builder - компиляция приложения
FROM golang:1.24-alpine AS builder

# Устанавливаем необходимые инструменты
RUN apk add --no-cache git make

# Устанавливаем рабочую директорию
WORKDIR /build

# Копируем файлы зависимостей
COPY go.mod go.sum ./
RUN go mod download

# Копируем исходный код
COPY . .

# Генерируем GraphQL код (если нужно)
RUN make generate || true

# Собираем бинарник
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a -installsuffix cgo \
    -o server \
    ./cmd/server

# Stage 2: Runtime - минимальный образ для запуска
FROM alpine:latest

# Устанавливаем CA сертификаты и wget для healthcheck
RUN apk --no-cache add ca-certificates tzdata wget

# Создаем непривилегированного пользователя для безопасности
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# Копируем бинарник из builder stage
COPY --from=builder /build/server .

# Копируем миграции (если нужно запускать их внутри контейнера)
COPY --from=builder /build/migrations ./migrations

# Меняем владельца файлов
RUN chown -R appuser:appuser /app

# Переключаемся на непривилегированного пользователя
USER appuser

# Открываем порт
EXPOSE 8080

# Healthcheck для мониторинга (можно переопределить в docker-compose)
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Запускаем приложение
CMD ["./server"]



================================================================================

================================================================================
Файл: Dockerfile.migrate
Полный путь: /home/alodi/playground/my-english/backend_v2/Dockerfile.migrate
================================================================================

# Dockerfile для запуска миграций
FROM golang:1.24-alpine

# Устанавливаем необходимые инструменты
RUN apk add --no-cache git make

WORKDIR /app

# Копируем файлы зависимостей
COPY go.mod go.sum ./
RUN go mod download

# Копируем миграции
COPY migrations ./migrations

# Устанавливаем goose
RUN go install github.com/pressly/goose/v3/cmd/goose@latest

# Создаем скрипт для запуска миграций
RUN echo '#!/bin/sh' > /app/run-migrations.sh && \
    echo 'set -e' >> /app/run-migrations.sh && \
    echo 'echo "Waiting for database to be ready..."' >> /app/run-migrations.sh && \
    echo 'until pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER"; do' >> /app/run-migrations.sh && \
    echo '  echo "Database is unavailable - sleeping"' >> /app/run-migrations.sh && \
    echo '  sleep 2' >> /app/run-migrations.sh && \
    echo 'done' >> /app/run-migrations.sh && \
    echo 'echo "Database is ready!"' >> /app/run-migrations.sh && \
    echo 'DB_URL="postgres://$DB_USER:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME?sslmode=$DB_SSLMODE"' >> /app/run-migrations.sh && \
    echo 'echo "Running migrations..."' >> /app/run-migrations.sh && \
    echo 'goose -dir migrations postgres "$DB_URL" up || exit 1' >> /app/run-migrations.sh && \
    echo 'echo "Migrations completed successfully!"' >> /app/run-migrations.sh && \
    chmod +x /app/run-migrations.sh

# Устанавливаем postgresql-client для pg_isready
# Используем postgresql15-client для совместимости с Alpine
RUN apk add --no-cache postgresql15-client || \
    apk add --no-cache --repository=http://dl-cdn.alpinelinux.org/alpine/edge/main postgresql-client || \
    apk update && apk add --no-cache postgresql-client

CMD ["/app/run-migrations.sh"]



================================================================================

================================================================================
Файл: Makefile
Полный путь: /home/alodi/playground/my-english/backend_v2/Makefile
================================================================================

.PHONY: generate
generate:
	@echo "Generating GraphQL code..."
	@if command -v gqlgen > /dev/null; then \
		gqlgen generate; \
	else \
		echo "gqlgen not found, installing..."; \
		go install github.com/99designs/gqlgen@latest; \
		gqlgen generate; \
	fi

.PHONY: generate-verbose
generate-verbose:
	@echo "Generating GraphQL code (verbose)..."
	@if command -v gqlgen > /dev/null; then \
		gqlgen generate -v; \
	else \
		echo "gqlgen not found, installing..."; \
		go install github.com/99designs/gqlgen@latest; \
		gqlgen generate -v; \
	fi

.PHONY: migrate-up
migrate-up:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-up DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Running migrations..."
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" up

.PHONY: migrate-down
migrate-down:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-down DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Rolling back migrations..."
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" down

.PHONY: migrate-status
migrate-status:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-status DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Migration status:"
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" status

.PHONY: migrate-create
migrate-create:
	@if [ -z "$(NAME)" ]; then \
		echo "Error: NAME environment variable is required"; \
		echo "Example: make migrate-create NAME=add_new_column"; \
		exit 1; \
	fi
	@echo "Creating migration: $(NAME)"
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations create $(NAME) sql
	@echo "Migration created! Don't forget to add -- +goose Up and -- +goose Down directives."

.PHONY: help
help:
	@echo "Available commands:"
	@echo "  make generate         - Generate GraphQL code"
	@echo "  make generate-verbose - Generate GraphQL code with verbose output"
	@echo ""
	@echo "Migration commands:"
	@echo "  make migrate-up       - Apply all migrations (requires DB_URL)"
	@echo "  make migrate-down     - Rollback last migration (requires DB_URL)"
	@echo "  make migrate-status   - Show migration status (requires DB_URL)"
	@echo "  make migrate-create   - Create new migration (requires NAME)"
	@echo ""
	@echo "Examples:"
	@echo "  make migrate-up DB_URL=postgres://user:pass@localhost:5432/mydb?sslmode=disable"
	@echo "  make migrate-create NAME=add_user_table"



================================================================================

================================================================================
Файл: README.md
Полный путь: /home/alodi/playground/my-english/backend_v2/README.md
================================================================================

# my-english

Стек: Go + postgres + graphql + squirel (для бд)

Сервис для практики английского языка.

## Быстрый старт с Docker

Самый простой способ запустить проект - использовать Docker:

```bash
# 1. Скопируйте файл с переменными окружения
cp .docker-compose.env.example .env

# 2. Запустите все сервисы
docker compose up -d

# 3. Проверьте статус
docker compose ps
```

Подробная документация по Docker: [DOCKER.md](./DOCKER.md)

## Локальная разработка

### Требования

- Go 1.24+
- PostgreSQL 16+
- Make

### Установка

```bash
# Установить зависимости
go mod download

# Сгенерировать GraphQL код
make generate
```

### Запуск

```bash
# Запустить сервер
go run cmd/server/main.go

# Или с конфигом
go run cmd/server/main.go -config config.example.yaml
```

### Миграции

```bash
# Применить миграции
make migrate-up DB_URL=postgres://user:password@localhost:5432/my_english?sslmode=disable

# Откатить последнюю миграцию
make migrate-down DB_URL=postgres://user:password@localhost:5432/my_english?sslmode=disable

# Статус миграций
make migrate-status DB_URL=postgres://user:password@localhost:5432/my_english?sslmode=disable
```

## Генерация GraphQL кода

Для генерации GraphQL кода из схемы используйте команду:

```bash
make generate
```

Или напрямую:

```bash
go run github.com/99designs/gqlgen generate
```

После генерации будут созданы файлы:
- `graph/generated.go` - сгенерированный код сервера
- `graph/models_gen.go` - сгенерированные модели
- `graph/resolvers.go` - файлы резолверов (создаются автоматически)

## Docker команды

Основные команды для работы с Docker:

```bash
# Запустить все сервисы
docker compose up -d

# Запустить миграции
docker compose up migrate

# Просмотр логов
docker compose logs -f [service_name]

# Остановить все
docker compose down
```

Подробная документация: [DOCKER.md](./DOCKER.md)


# Docker Setup

## Быстрый старт

```bash
# 1. Опционально: скопировать переменные окружения
cp .docker-compose.env.example .env

# 2. Запустить все сервисы
docker compose up -d

# 3. Проверить статус
docker compose ps
```

## Основные команды

```bash
# Запустить сервисы
docker compose up -d

# Остановить сервисы
docker compose down

# Просмотр логов
docker compose logs -f [service_name]

# Перезапустить
docker compose restart

# Запустить миграции вручную
docker compose up migrate

# Подключиться к БД
docker compose exec postgres psql -U postgres -d my_english
```

## Доступ к сервисам

- **GraphQL API**: http://localhost:8080/graphql
- **GraphQL Playground**: http://localhost:8080/playground
- **Health Check**: http://localhost:8080/health
- **PostgreSQL**: localhost:5432

## Переменные окружения

Основные переменные (можно настроить в `.env`):

- `DB_USER`, `DB_PASSWORD`, `DB_NAME` - настройки БД
- `SERVER_PORT` - порт backend (по умолчанию: 8080)
- `LOG_LEVEL` - уровень логирования

Полный список: `.docker-compose.env.example`

## Важные замечания

### Использование Docker Compose v2

Используйте `docker compose` (v2) вместо `docker-compose` (v1):

```bash
docker compose up -d  # правильно
docker-compose up -d  # устаревший способ
```

### Проблемы с сетями Docker

Если ошибка `all predefined address pools have been fully subnetted`:

```bash
docker network prune -f
docker system prune -a --volumes -f
```

## Troubleshooting

**Backend не подключается к БД**: Проверьте, что используете `postgres` как hostname (не `localhost`)

**Миграции не применяются**: 
```bash
docker compose up migrate
```

**Порт занят**: Измените порт в `.env` или `docker-compose.yml`


================================================================================

================================================================================
Файл: cmd/server/main.go
Полный путь: /home/alodi/playground/my-english/backend_v2/cmd/server/main.go
================================================================================

package main

import (
	"flag"
	"log"
	"os"

	"github.com/heartmarshall/my-english/internal/app"
	"github.com/heartmarshall/my-english/internal/config"
)

func main() {
	// Флаг для указания пути к YAML конфигу
	configPath := flag.String("config", "", "path to YAML config file (optional)")
	flag.Parse()

	// Проверяем переменную окружения CONFIG_PATH, если флаг не указан
	if *configPath == "" {
		if configPathEnv := os.Getenv("CONFIG_PATH"); configPathEnv != "" {
			*configPath = configPathEnv
		}
	}

	// Загружаем конфигурацию
	// Приоритет: переменные окружения > YAML файл > дефолтные значения
	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Создаём приложение
	application, err := app.New(*cfg)
	if err != nil {
		log.Fatalf("Failed to create application: %v", err)
	}

	if err := application.Run(); err != nil {
		log.Fatalf("Application error: %v", err)
	}
}


================================================================================

================================================================================
Файл: config.example.yaml
Полный путь: /home/alodi/playground/my-english/backend_v2/config.example.yaml
================================================================================

# Пример конфигурации приложения
server:
  host: "0.0.0.0"
  port: 8080
  read_timeout: 15s
  write_timeout: 15s
  request_timeout: 30s

database:
  host: "localhost"
  port: 5432
  user: "postgres"
  password: "postgres"
  database: "my_english"
  ssl_mode: "disable"
  max_open_conns: 25
  max_idle_conns: 5
  conn_max_lifetime: 5m

graphql:
  enable_playground: true
  enable_introspection: true
  query_cache_size: 1000

log:
  level: "info"  # debug, info, warn, error
  format: "text" # json или text



================================================================================

================================================================================
Файл: docker-compose.yml
Полный путь: /home/alodi/playground/my-english/backend_v2/docker-compose.yml
================================================================================

services:
  # PostgreSQL база данных
  postgres:
    image: postgres:16-alpine
    container_name: my-english-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
      POSTGRES_DB: ${DB_NAME:-my_english}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Можно добавить init скрипты если нужно
      # - ./init-db:/docker-entrypoint-initdb.d
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-my_english}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - my-english-network
    # Оптимизация для production
    command: >
      postgres
      -c shared_buffers=256MB
      -c max_connections=200
      -c effective_cache_size=1GB
      -c maintenance_work_mem=64MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB

  # Миграции базы данных
  # Запускается автоматически при старте, применяет только новые миграции
  migrate:
    build:
      context: .
      dockerfile: Dockerfile.migrate
    container_name: my-english-migrate
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-my_english}
      DB_SSLMODE: disable
    networks:
      - my-english-network
    # Запускается только один раз при старте (не перезапускается)
    restart: "no"

  # Backend сервис
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: my-english-backend
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      migrate:
        condition: service_completed_successfully
    environment:
      # Server config
      SERVER_HOST: ${SERVER_HOST:-0.0.0.0}
      SERVER_PORT: ${SERVER_PORT:-8080}
      SERVER_READ_TIMEOUT: ${SERVER_READ_TIMEOUT:-15s}
      SERVER_WRITE_TIMEOUT: ${SERVER_WRITE_TIMEOUT:-15s}
      SERVER_REQUEST_TIMEOUT: ${SERVER_REQUEST_TIMEOUT:-30s}
      
      # Database config
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-my_english}
      DB_SSLMODE: ${DB_SSLMODE:-disable}
      DB_MAX_OPEN_CONNS: ${DB_MAX_OPEN_CONNS:-25}
      DB_MAX_IDLE_CONNS: ${DB_MAX_IDLE_CONNS:-5}
      DB_CONN_MAX_LIFETIME: ${DB_CONN_MAX_LIFETIME:-5m}
      
      # GraphQL config
      GRAPHQL_PLAYGROUND: ${GRAPHQL_PLAYGROUND:-true}
      GRAPHQL_INTROSPECTION: ${GRAPHQL_INTROSPECTION:-true}
      GRAPHQL_QUERY_CACHE_SIZE: ${GRAPHQL_QUERY_CACHE_SIZE:-1000}
      
      # Log config
      LOG_LEVEL: ${LOG_LEVEL:-info}
      LOG_FORMAT: ${LOG_FORMAT:-json}
    ports:
      - "${SERVER_PORT:-8080}:8080"
    networks:
      - my-english-network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  postgres_data:
    driver: local
    name: my-english-postgres-data

networks:
  my-english-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
          gateway: 172.28.0.1



================================================================================

================================================================================
Файл: go.mod
Полный путь: /home/alodi/playground/my-english/backend_v2/go.mod
================================================================================

module github.com/heartmarshall/my-english

go 1.24.7

require (
	github.com/99designs/gqlgen v0.17.85
	github.com/Masterminds/squirrel v1.5.4
	github.com/georgysavva/scany/v2 v2.1.4
	github.com/google/uuid v1.6.0
	github.com/ilyakaznacheev/cleanenv v1.5.0
	github.com/jackc/pgx/v5 v5.8.0
	github.com/pashagolub/pgxmock/v2 v2.12.0
	github.com/vektah/gqlparser/v2 v2.5.31
)

require (
	github.com/BurntSushi/toml v1.6.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/lann/builder v0.0.0-20180802200727-47ae307949d0 // indirect
	github.com/lann/ps v0.0.0-20150810152359-62de8c46ede0 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/rogpeppe/go-internal v1.14.1 // indirect
	github.com/sosodev/duration v1.3.1 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/text v0.32.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	olympos.io/encoding/edn v0.0.0-20201019073823-d3554ca0b0a3 // indirect
)


================================================================================

================================================================================
Файл: gqlgen.yml
Полный путь: /home/alodi/playground/my-english/backend_v2/gqlgen.yml
================================================================================

# Where are all the schema files located?
schema:
  - graph/schema.graphqls

# Where should the generated server code go?
exec:
  filename: graph/generated.go
  package: graph

# Where should any generated models go?
model:
  filename: graph/models_gen.go
  package: graph

# Resolver configuration
resolver:
  layout: follow-schema
  dir: graph
  package: graph
  filename_template: "{name}.resolvers.go"

# Optional: turn on autobind
autobind:
  - "github.com/heartmarshall/my-english/graph"

# Map GraphQL types to Go types
models:
  Time:
    model: github.com/heartmarshall/my-english/graph.Time
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.IntID
  Word:
    fields:
      meanings:
        resolver: true
  Meaning:
    fields:
      examples:
        resolver: true
      tags:
        resolver: true


================================================================================

================================================================================
Файл: graph/schema.graphqls
Полный путь: /home/alodi/playground/my-english/backend_v2/graph/schema.graphqls
================================================================================

scalar Time
"""
JSON объект для хранения технических данных алгоритма интервального повторения.
Пример для FSRS: { "stability": 4.5, "difficulty": 1.2, "retrievability": 0.9 }
Пример для SM-2: { "interval": 6, "ease": 2.5 }
"""
scalar JSON

# ==========================================
# 1. ENUMS
# ==========================================

enum LearningStatus {
  NEW
  LEARNING
  REVIEW
  MASTERED
}

enum PartOfSpeech {
  NOUN
  VERB
  ADJECTIVE
  ADVERB
  PRONOUN
  PREPOSITION
  CONJUNCTION
  INTERJECTION
  PHRASE
  IDIOM
  OTHER
}

enum AccentRegion {
  US
  UK
  AU
  GENERAL
}

enum RelationType {
  SYNONYM
  ANTONYM
  COLLOCATION # Устойчивое выражение (make -> decision)
  RELATED
}

enum MorphologicalType {
  PLURAL           # mice
  PAST_TENSE       # went
  PAST_PARTICIPLE  # gone
  PRESENT_PARTICIPLE # going
  COMPARATIVE      # bigger
  SUPERLATIVE      # biggest
}

enum ExampleSourceType {
  FILM
  BOOK
  CHAT
  VIDEO
  PODCAST
}

# ==========================================
# 2. SYSTEM & METADATA
# ==========================================

"""
Источник данных (Oxford, FreeDict, User Manual, AI).
"""
type DataSource {
  id: ID!
  slug: String!        # "freedict", "user"
  displayName: String! # "Free Dictionary API"
  trustLevel: Int!     # 1-10
  websiteUrl: String
}

# ==========================================
# 3. LINGUISTIC LAYER (GLOBAL DICTIONARY)
# ==========================================

"""
Лексема (Lexeme) — единица языка. Общая для всех.
Хранит написание, произношение и связи форм.
"""
type Lexeme {
  id: ID!
  text: String! # Оригинальное написание
  
  # Список вариантов произношения (разные регионы/спикеры)
  pronunciations: [Pronunciation!]!
  
  # Значения слова (Смыслы)
  senses: [Sense!]!
  
  # --- Морфология ---
  # Если это "Go", вернет формы: [{word: "Went", type: PAST_TENSE}, ...]
  inflections: [Inflection!]!
  
  # Если это "Went", вернет ссылку на "Go"
  lemma: Lexeme
}

type Pronunciation {
  audioUrl: String!
  transcription: String # IPA
  region: AccentRegion!
  source: DataSource # Откуда взята озвучка
}

"""
Связь формы слова с текущим словом.
"""
type Inflection {
  word: Lexeme! # Ссылка на слово-форму
  type: MorphologicalType!
}

"""
Смысловое значение (Sense).
Именно эту сущность пользователь добавляет в "Мои слова".
"""
type Sense {
  id: ID!
  lexeme: Lexeme! # Ссылка назад на слово
  
  partOfSpeech: PartOfSpeech!
  definition: String!
  cefrLevel: String
  
  # Источник определения
  source: DataSource!
  
  translations: [Translation!]!
  examples: [Example!]!
  relations: [SenseRelation!]!
}

type Translation {
  text: String!
  source: DataSource
}

"""
Семантическая связь (Синоним/Антоним/Коллокация).
"""
type SenseRelation {
  sense: Sense!       # С каким значением связано
  type: RelationType! # Тип связи
  
  # Если false, связь работает только в одну сторону (Source -> Target).
  # Пример: Cause -> Result (Related), но не наоборот.
  isBidirectional: Boolean! 
}

type Example {
  id: ID!
  sentenceEn: String!
  sentenceRu: String
  
  # Индексы [start, end] для подсветки целевого слова.
  # Полезно для генерации упражнений "Вставь пропущенное".
  highlightRange: [Int!]
  
  sourceType: ExampleSourceType
  sourceName: String
}

# ==========================================
# 4. USER SPACE (PERSONAL PROGRESS)
# ==========================================

"""
Личная карточка (Card).
Связывает пользователя и Sense, хранит прогресс и личные правки.
"""
type Card {
  id: ID!
  
  # Ссылка на глобальный словарь (может быть null, если слово полностью кастомное)
  sense: Sense
  
  # --- User Overrides (Кастомные данные) ---
  # Если эти поля заполнены, UI показывает их вместо данных словаря
  customText: String
  customTranscription: String
  customTranslations: [String!] 
  customNote: String          # Личная заметка (Markdown)
  customImageUrl: String
  
  # --- Progress ---
  # Вынесен в отдельный объект для чистоты
  progress: CardProgress!
  
  tags: [Tag!]!
  createdAt: Time!
}

"""
Состояние изучения и статистика.
Соответствует таблице 'srs_states'.
"""
type CardProgress {
  status: LearningStatus!
  nextReviewAt: Time
  
  # Общие метрики
  reviewCount: Int!
  lastReviewAt: Time
  
  # Сырые данные алгоритма (FSRS / SM-2).
  # Frontend может использовать это для дебага или визуализации "сложности".
  algorithmData: JSON!
}

type Tag {
  id: ID!
  name: String!
  color: String
}

type InboxItem {
  id: ID!
  text: String!
  context: String
  createdAt: Time!
}

type DashboardStats {
  totalCards: Int!
  masteredCount: Int!
  learningCount: Int!
  dueCount: Int!
}

# ==========================================
# 5. INPUTS & FILTERS
# ==========================================

input CardsFilter {
  search: String
  tags: [String!]
  statuses: [LearningStatus!]
}

input StudyFilter {
  tags: [String!]
  statuses: [LearningStatus!]
  limit: Int = 20
}

"""
Входные данные для создания карточки.
"""
input CreateCardInput {
  # Вариант А: Добавляем из словаря (ссылка на Sense)
  senseId: ID
  
  # Вариант Б: Полностью свое слово (без связи со словарем)
  customText: String
  
  # Общие поля
  translations: [String!]!
  note: String
  transcription: String
  tags: [String!]
}

input UpdateCardInput {
  customTranscription: String
  customTranslations: [String!]
  customNote: String
  tags: [String!]
}

# ==========================================
# 6. OPERATIONS
# ==========================================

type Query {
  # --- Dictionary Access ---
  # Поиск по глобальному словарю (включая поиск во внешних API)
  search(query: String!): [Lexeme!]!
  
  # Получить детали лексемы
  lexeme(id: ID!): Lexeme

  # --- User Access ---
  # Мои карточки
  myCards(filter: CardsFilter, limit: Int = 20, offset: Int = 0): [Card!]!
  card(id: ID!): Card
  
  # Inbox
  inboxItems: [InboxItem!]!
  
  # --- Study Mode ---
  # Очередь на изучение
  studyQueue(filter: StudyFilter): [Card!]!
  
  stats: DashboardStats!
}

type Mutation {
  # --- Card Ops ---
  createCard(input: CreateCardInput!): Card!
  updateCard(id: ID!, input: UpdateCardInput!): Card!
  deleteCard(id: ID!): Boolean!
  
  # --- Inbox Ops ---
  addToInbox(text: String!, context: String): InboxItem!
  deleteInboxItem(id: ID!): Boolean!
  convertInboxToCard(inboxId: ID!, input: CreateCardInput!): Card!

  # --- Study Ops ---
  # Оценка карточки
  reviewCard(
    cardId: ID!, 
    grade: Int!,      # 1-5
    timeTakenMs: Int  # Время ответа (для аналитики сложности)
  ): ReviewResult!
}

type ReviewResult {
  card: Card!
  nextReviewInDays: Float! # "Увидимся через 2.5 дня"
  statusChanged: Boolean!
}

================================================================================

================================================================================
Файл: internal/app/health.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/app/health.go
================================================================================

package app

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
)

// HealthStatus — статус компонента.
type HealthStatus string

const (
	HealthStatusUp   HealthStatus = "up"
	HealthStatusDown HealthStatus = "down"
)

// HealthResponse — ответ health check endpoint.
type HealthResponse struct {
	Status     HealthStatus               `json:"status"`
	Components map[string]ComponentHealth `json:"components"`
	Timestamp  time.Time                  `json:"timestamp"`
}

// ComponentHealth — здоровье отдельного компонента.
type ComponentHealth struct {
	Status  HealthStatus `json:"status"`
	Latency string       `json:"latency,omitempty"`
	Error   string       `json:"error,omitempty"`
}

// HealthChecker проверяет здоровье приложения.
type HealthChecker struct {
	pool *pgxpool.Pool
}

// NewHealthChecker создаёт новый HealthChecker.
func NewHealthChecker(pool *pgxpool.Pool) *HealthChecker {
	return &HealthChecker{pool: pool}
}

// Handler возвращает HTTP handler для health check.
func (h *HealthChecker) Handler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
		defer cancel()

		response := h.Check(ctx)

		w.Header().Set("Content-Type", "application/json")

		if response.Status == HealthStatusDown {
			w.WriteHeader(http.StatusServiceUnavailable)
		} else {
			w.WriteHeader(http.StatusOK)
		}

		json.NewEncoder(w).Encode(response)
	}
}

// LivenessHandler — простой liveness probe (для Kubernetes).
func (h *HealthChecker) LivenessHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	}
}

// ReadinessHandler — readiness probe с проверкой БД.
func (h *HealthChecker) ReadinessHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
		defer cancel()

		if err := h.pool.Ping(ctx); err != nil {
			w.WriteHeader(http.StatusServiceUnavailable)
			w.Write([]byte("NOT READY"))
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte("READY"))
	}
}

// Check выполняет полную проверку здоровья.
func (h *HealthChecker) Check(ctx context.Context) HealthResponse {
	components := make(map[string]ComponentHealth)

	// Проверка БД
	dbHealth := h.checkDatabase(ctx)
	components["database"] = dbHealth

	// Определяем общий статус
	overallStatus := HealthStatusUp
	for _, comp := range components {
		if comp.Status == HealthStatusDown {
			overallStatus = HealthStatusDown
			break
		}
	}

	return HealthResponse{
		Status:     overallStatus,
		Components: components,
		Timestamp:  time.Now().UTC(),
	}
}

// checkDatabase проверяет соединение с БД.
func (h *HealthChecker) checkDatabase(ctx context.Context) ComponentHealth {
	start := time.Now()

	err := h.pool.Ping(ctx)
	latency := time.Since(start)

	if err != nil {
		return ComponentHealth{
			Status:  HealthStatusDown,
			Latency: latency.String(),
			Error:   err.Error(),
		}
	}

	return ComponentHealth{
		Status:  HealthStatusUp,
		Latency: latency.String(),
	}
}


================================================================================

================================================================================
Файл: internal/app/logger.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/app/logger.go
================================================================================

package app

import (
	"log/slog"
	"os"

	"github.com/heartmarshall/my-english/internal/config"
)

func NewLogger(cfg config.LogConfig) *slog.Logger {
	var level slog.Level
	switch cfg.Level {
	case "debug":
		level = slog.LevelDebug
	case "warn":
		level = slog.LevelWarn
	case "error":
		level = slog.LevelError
	default:
		level = slog.LevelInfo
	}

	opts := &slog.HandlerOptions{
		Level: level,
	}

	var handler slog.Handler
	if cfg.Format == "json" {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	} else {
		handler = slog.NewTextHandler(os.Stdout, opts)
	}

	return slog.New(handler)
}


================================================================================

================================================================================
Файл: internal/clients/freedict/client.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/clients/freedict/client.go
================================================================================

package freedict

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/dictionary"
)

const (
	apiURL     = "https://api.dictionaryapi.dev/api/v2/entries/en/"
	SourceSlug = "freedict"
)

// Client реализует интерфейс dictionary.Provider.
type Client struct {
	httpClient *http.Client
}

func NewClient() *Client {
	return &Client{
		httpClient: &http.Client{
			Timeout: 10 * time.Second,
		},
	}
}

// SourceSlug возвращает идентификатор источника.
func (c *Client) SourceSlug() string {
	return SourceSlug
}

// Fetch получает данные о слове и преобразует их в ImportedWord.
func (c *Client) Fetch(ctx context.Context, query string) (*dictionary.ImportedWord, error) {
	safeWord := url.PathEscape(strings.TrimSpace(query))
	reqURL := apiURL + safeWord

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, nil // Штатная ситуация: слово не найдено
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var apiResponse []apiEntry
	if err := json.NewDecoder(resp.Body).Decode(&apiResponse); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	if len(apiResponse) == 0 {
		return nil, nil
	}

	return c.mapToImportedWord(apiResponse), nil
}

// mapToImportedWord преобразует ответ API во внутреннюю структуру.
// FreeDict может вернуть несколько entries для одного слова (например, как сущ. и как глагол),
// мы объединяем их в один ImportedWord.
func (c *Client) mapToImportedWord(entries []apiEntry) *dictionary.ImportedWord {
	result := &dictionary.ImportedWord{
		Text:           entries[0].Word, // Берем написание из первого вхождения
		Pronunciations: make([]dictionary.ImportedPronunciation, 0),
		Senses:         make([]dictionary.ImportedSense, 0),
	}

	// Используем мапы для дедупликации, так как API часто дублирует данные
	seenAudios := make(map[string]bool)

	for _, entry := range entries {
		// 1. Собираем произношения
		for _, p := range entry.Phonetics {
			if p.Audio == "" {
				continue
			}
			if seenAudios[p.Audio] {
				continue
			}

			seenAudios[p.Audio] = true

			// Пытаемся определить регион по URL (API часто пишет -us.mp3 / -uk.mp3)
			region := model.AccentRegionGeneral
			if strings.Contains(p.Audio, "-us.mp3") {
				region = model.AccentRegionUS
			} else if strings.Contains(p.Audio, "-uk.mp3") {
				region = model.AccentRegionUK
			} else if strings.Contains(p.Audio, "-au.mp3") {
				region = model.AccentRegionAU
			}

			// Текст транскрипции берем либо из фонетики, либо из корня entry
			transcription := p.Text
			if transcription == "" {
				transcription = entry.Phonetic
			}

			result.Pronunciations = append(result.Pronunciations, dictionary.ImportedPronunciation{
				AudioURL:      p.Audio,
				Transcription: transcription,
				Region:        region,
			})
		}

		// 2. Собираем смыслы (Senses)
		for _, m := range entry.Meanings {
			pos := mapPartOfSpeech(m.PartOfSpeech)

			for _, def := range m.Definitions {
				sense := dictionary.ImportedSense{
					PartOfSpeech: pos,
					Definition:   def.Definition,
					Translations: []string{}, // FreeDict не дает переводов
					Examples:     make([]dictionary.ImportedExample, 0),
				}

				if def.Example != "" {
					sense.Examples = append(sense.Examples, dictionary.ImportedExample{
						SentenceEn: def.Example,
						// SentenceRu пустой
					})
				}

				result.Senses = append(result.Senses, sense)
			}
		}
	}

	return result
}

func mapPartOfSpeech(pos string) model.PartOfSpeech {
	switch strings.ToLower(pos) {
	case "noun":
		return model.PartOfSpeechNoun
	case "verb":
		return model.PartOfSpeechVerb
	case "adjective":
		return model.PartOfSpeechAdjective
	case "adverb":
		return model.PartOfSpeechAdverb
	case "pronoun":
		return model.PartOfSpeechPronoun
	case "preposition":
		return model.PartOfSpeechPreposition
	case "conjunction":
		return model.PartOfSpeechConjunction
	case "interjection":
		return model.PartOfSpeechInterjection
	default:
		return model.PartOfSpeechOther
	}
}


================================================================================

================================================================================
Файл: internal/clients/freedict/types.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/clients/freedict/types.go
================================================================================

package freedict

// apiEntry описывает структуру одного элемента массива в ответе API.
type apiEntry struct {
	Word       string        `json:"word"`
	Phonetic   string        `json:"phonetic"`
	Phonetics  []apiPhonetic `json:"phonetics"`
	Meanings   []apiMeaning  `json:"meanings"`
	SourceUrls []string      `json:"sourceUrls"`
}

type apiPhonetic struct {
	Text  string `json:"text"`
	Audio string `json:"audio"`
}

type apiMeaning struct {
	PartOfSpeech string          `json:"partOfSpeech"`
	Definitions  []apiDefinition `json:"definitions"`
}

type apiDefinition struct {
	Definition string   `json:"definition"`
	Example    string   `json:"example"`
	Synonyms   []string `json:"synonyms"`
	Antonyms   []string `json:"antonyms"`
}


================================================================================

================================================================================
Файл: internal/config/config.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/config/config.go
================================================================================

package config

import (
	"fmt"
	"time"
)

// Config — конфигурация приложения.
// Теги `yaml` используются для чтения из файла.
// Теги `env` используются для чтения переменных окружения.
// Теги `env-default` задают значения по умолчанию.
type Config struct {
	Server   ServerConfig   `yaml:"server"`
	Database DatabaseConfig `yaml:"database"`
	GraphQL  GraphQLConfig  `yaml:"graphql"`
	Log      LogConfig      `yaml:"log"`
}

// ServerConfig — конфигурация HTTP сервера.
type ServerConfig struct {
	Host           string        `yaml:"host" env:"SERVER_HOST" env-default:"0.0.0.0"`
	Port           int           `yaml:"port" env:"SERVER_PORT" env-default:"8080"`
	ReadTimeout    time.Duration `yaml:"read_timeout" env:"SERVER_READ_TIMEOUT" env-default:"15s"`
	WriteTimeout   time.Duration `yaml:"write_timeout" env:"SERVER_WRITE_TIMEOUT" env-default:"15s"`
	RequestTimeout time.Duration `yaml:"request_timeout" env:"SERVER_REQUEST_TIMEOUT" env-default:"30s"`
}

// Addr возвращает адрес сервера.
func (c ServerConfig) Addr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}

// DatabaseConfig — конфигурация базы данных.
type DatabaseConfig struct {
	Host            string        `yaml:"host" env:"DB_HOST" env-default:"localhost"`
	Port            int           `yaml:"port" env:"DB_PORT" env-default:"5432"`
	User            string        `yaml:"user" env:"DB_USER" env-default:"postgres"`
	Password        string        `yaml:"password" env:"DB_PASSWORD" env-default:"postgres"`
	Database        string        `yaml:"database" env:"DB_NAME" env-default:"my_english"`
	SSLMode         string        `yaml:"ssl_mode" env:"DB_SSLMODE" env-default:"disable"`
	MaxOpenConns    int           `yaml:"max_open_conns" env:"DB_MAX_OPEN_CONNS" env-default:"25"`
	MaxIdleConns    int           `yaml:"max_idle_conns" env:"DB_MAX_IDLE_CONNS" env-default:"5"`
	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime" env:"DB_CONN_MAX_LIFETIME" env-default:"5m"`
}

// DSN возвращает строку подключения к PostgreSQL в формате URL для pgx.
func (c DatabaseConfig) DSN() string {
	return fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s",
		c.User, c.Password, c.Host, c.Port, c.Database, c.SSLMode,
	)
}

// GraphQLConfig — конфигурация GraphQL.
type GraphQLConfig struct {
	EnablePlayground    bool `yaml:"enable_playground" env:"GRAPHQL_PLAYGROUND" env-default:"true"`
	EnableIntrospection bool `yaml:"enable_introspection" env:"GRAPHQL_INTROSPECTION" env-default:"true"`
	QueryCacheSize      int  `yaml:"query_cache_size" env:"GRAPHQL_QUERY_CACHE_SIZE" env-default:"1000"`
}

// LogConfig — конфигурация логгера.
type LogConfig struct {
	Level  string `yaml:"level" env:"LOG_LEVEL" env-default:"info"`   // debug, info, warn, error
	Format string `yaml:"format" env:"LOG_FORMAT" env-default:"text"` // json, text
}


================================================================================

================================================================================
Файл: internal/config/loader.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/config/loader.go
================================================================================

package config

import (
	"fmt"
	"os"

	"github.com/ilyakaznacheev/cleanenv"
)

// Load загружает конфигурацию приложения.
// Приоритет загрузки:
// 1. Переменные окружения (наивысший приоритет, перекрывают файл)
// 2. YAML файл конфигурации (если указан путь и файл существует)
// 3. Значения по умолчанию (указаны в struct tags)
func Load(configPath string) (*Config, error) {
	var cfg Config

	// Проверяем, передан ли путь к файлу и существует ли он
	if configPath != "" {
		if _, err := os.Stat(configPath); err == nil {
			// Читаем из файла + ENV + Defaults
			if err := cleanenv.ReadConfig(configPath, &cfg); err != nil {
				return nil, fmt.Errorf("failed to read config from file %s: %w", configPath, err)
			}
			return &cfg, nil
		}
	}

	// Если файла нет, читаем только ENV + Defaults
	if err := cleanenv.ReadEnv(&cfg); err != nil {
		return nil, fmt.Errorf("failed to read env vars: %w", err)
	}

	return &cfg, nil
}


================================================================================

================================================================================
Файл: internal/database/database.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/database.go
================================================================================

// Package database предоставляет базовые компоненты для работы с PostgreSQL.
package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// ============================================================================
// QUERIER INTERFACE
// ============================================================================

// Querier — общий интерфейс для pgxpool.Pool и pgx.Tx.
// Позволяет использовать один и тот же код для обычных запросов и транзакций.
type Querier interface {
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

// Compile-time check что типы реализуют интерфейс.
var (
	_ Querier = (*pgxpool.Pool)(nil)
	_ Querier = (pgx.Tx)(nil)
)

// ============================================================================
// CLOCK
// ============================================================================

// Clock интерфейс для получения текущего времени.
// Позволяет мокать время в тестах.
type Clock interface {
	Now() time.Time
}

// RealClock возвращает реальное время.
type RealClock struct{}

func (RealClock) Now() time.Time { return time.Now() }

// DefaultClock — дефолтная реализация часов.
var DefaultClock Clock = RealClock{}

// ============================================================================
// TRANSACTIONS
// ============================================================================

// TxFunc — функция, выполняемая в рамках транзакции.
type TxFunc func(ctx context.Context, q Querier) error

// WithTx выполняет функцию в транзакции.
// При ошибке или панике — автоматический rollback.
// При успехе — commit.
func WithTx(ctx context.Context, pool *pgxpool.Pool, fn TxFunc) error {
	tx, err := pool.Begin(ctx)
	if err != nil {
		return err
	}

	defer func() {
		if p := recover(); p != nil {
			_ = tx.Rollback(ctx)
			panic(p)
		}
	}()

	if err := fn(ctx, tx); err != nil {
		_ = tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}

// ============================================================================
// TX MANAGER
// ============================================================================

// TxManager управляет транзакциями и предоставляет доступ к пулу.
type TxManager struct {
	pool *pgxpool.Pool
}

// NewTxManager создаёт новый TxManager.
func NewTxManager(pool *pgxpool.Pool) *TxManager {
	return &TxManager{pool: pool}
}

// RunInTx выполняет функцию в рамках транзакции.
func (m *TxManager) RunInTx(ctx context.Context, fn TxFunc) error {
	return WithTx(ctx, m.pool, fn)
}

// Pool возвращает пул соединений с БД.
func (m *TxManager) Pool() *pgxpool.Pool {
	return m.pool
}

// Q возвращает Querier (пул) для обычных запросов.
func (m *TxManager) Q() Querier {
	return m.pool
}


================================================================================

================================================================================
Файл: internal/database/errors.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/errors.go
================================================================================

package database

import (
	"errors"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// Кастомные ошибки слоя данных.
// Позволяют бизнес-логике не зависеть от sql пакета.
var (
	// ErrNotFound возвращается, когда запись не найдена.
	ErrNotFound = errors.New("record not found")

	// ErrDuplicate возвращается при попытке создать дубликат
	// (нарушение UNIQUE constraint).
	ErrDuplicate = errors.New("record already exists")

	// ErrInvalidInput возвращается при невалидных входных данных.
	ErrInvalidInput = errors.New("invalid input")
)

// PostgreSQL error codes
// https://www.postgresql.org/docs/current/errcodes-appendix.html
const (
	// pgUniqueViolation — код ошибки нарушения уникальности в PostgreSQL.
	pgUniqueViolation = "23505"
)

// IsNotFoundError проверяет, является ли ошибка "запись не найдена".
func IsNotFoundError(err error) bool {
	return errors.Is(err, pgx.ErrNoRows)
}

// IsDuplicateError проверяет, является ли ошибка нарушением UNIQUE constraint.
// Работает с github.com/jackc/pgx/v5.
func IsDuplicateError(err error) bool {
	if err == nil {
		return false
	}

	// Проверка для pgx v5 через pgconn.PgError
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		return pgErr.Code == pgUniqueViolation
	}

	// Fallback: проверка по строке (для совместимости)
	errStr := err.Error()
	if strings.Contains(errStr, pgUniqueViolation) ||
		strings.Contains(errStr, "duplicate key value violates unique constraint") {
		return true
	}

	return false
}

// WrapDBError оборачивает ошибку базы данных в domain-specific ошибку.
func WrapDBError(err error) error {
	if err == nil {
		return nil
	}

	if IsDuplicateError(err) {
		return ErrDuplicate
	}

	return err
}


================================================================================

================================================================================
Файл: internal/database/execute.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/execute.go
================================================================================

package database

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/georgysavva/scany/v2/pgxscan"
)

// ============================================================================
// LEGACY QUERY EXECUTOR
// Сохранено для обратной совместимости.
// Для новых репозиториев используйте repository.Base[T].
// ============================================================================

// SQLBuilder интерфейс для squirrel.SelectBuilder, InsertBuilder и т.д.
type SQLBuilder interface {
	ToSql() (string, []interface{}, error)
}

// Exec выполняет generic запросы через squirrel builder.
type Exec[T any] struct {
	q   Querier
	b   SQLBuilder
	err error
}

// NewQuery создаёт новый экзекьютор.
func NewQuery[T any](q Querier, b SQLBuilder) *Exec[T] {
	return &Exec[T]{q: q, b: b}
}

// One возвращает одну сущность или ошибку ErrNotFound.
func (e *Exec[T]) One(ctx context.Context) (T, error) {
	var dest T
	if e.err != nil {
		return dest, e.err
	}

	sql, args, err := e.b.ToSql()
	if err != nil {
		return dest, WrapDBError(err)
	}

	if err := pgxscan.Get(ctx, e.q, &dest, sql, args...); err != nil {
		if pgxscan.NotFound(err) {
			return dest, ErrNotFound
		}
		return dest, WrapDBError(err)
	}

	return dest, nil
}

// List возвращает слайс сущностей.
func (e *Exec[T]) List(ctx context.Context) ([]T, error) {
	if e.err != nil {
		return nil, e.err
	}

	sql, args, err := e.b.ToSql()
	if err != nil {
		return nil, WrapDBError(err)
	}

	var dest []T
	if err := pgxscan.Select(ctx, e.q, &dest, sql, args...); err != nil {
		return nil, WrapDBError(err)
	}

	return dest, nil
}

// Scalar возвращает примитив (int, string, bool).
func (e *Exec[T]) Scalar(ctx context.Context) (T, error) {
	return e.One(ctx)
}

// ============================================================================
// STANDALONE HELPERS
// ============================================================================

// ExecOnly выполняет запрос (INSERT/UPDATE/DELETE) и возвращает кол-во затронутых строк.
func ExecOnly(ctx context.Context, q Querier, b SQLBuilder) (int64, error) {
	sql, args, err := b.ToSql()
	if err != nil {
		return 0, WrapDBError(err)
	}

	tag, err := q.Exec(ctx, sql, args...)
	if err != nil {
		return 0, WrapDBError(err)
	}
	return tag.RowsAffected(), nil
}

// ExecInsertWithReturn выполняет INSERT ... RETURNING id и сканирует результат.
func ExecInsertWithReturn[T any](ctx context.Context, q Querier, b SQLBuilder) (T, error) {
	var id T
	sql, args, err := b.ToSql()
	if err != nil {
		return id, WrapDBError(err)
	}

	err = q.QueryRow(ctx, sql, args...).Scan(&id)
	if err != nil {
		return id, WrapDBError(err)
	}
	return id, nil
}

// ============================================================================
// RAW SQL HELPERS
// ============================================================================

// GetOne сканирует одну структуру из raw SQL.
func GetOne[T any](ctx context.Context, q Querier, sql string, args ...any) (*T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, ErrNotFound
		}
		return nil, err
	}
	return &dest, nil
}

// Select сканирует список структур из raw SQL.
func Select[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// GetScalar сканирует одно скалярное значение.
func GetScalar[T any](ctx context.Context, q Querier, sql string, args ...any) (T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return dest, nil
		}
		return dest, err
	}
	return dest, nil
}

// SelectScalars сканирует список скалярных значений.
func SelectScalars[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// CheckExists проверяет наличие строки.
func CheckExists(ctx context.Context, q Querier, sql string, args ...any) (bool, error) {
	var dummy int
	err := pgxscan.Get(ctx, q, &dummy, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

// ============================================================================
// BUILDER
// ============================================================================

// Builder — глобальный squirrel builder с PostgreSQL placeholder format.
var Builder = squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)


================================================================================

================================================================================
Файл: internal/database/repository/base.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/base.go
================================================================================

package repository

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/georgysavva/scany/v2/pgxscan"
	"github.com/heartmarshall/my-english/internal/database"
)

// Builder — глобальный squirrel builder с PostgreSQL placeholder format.
var Builder = squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)

// ============================================================================
// BASE REPOSITORY
// ============================================================================

// Base предоставляет общие CRUD операции для репозиториев.
// Используй embedding для создания специализированных репозиториев.
type Base[T any] struct {
	querier database.Querier
	table   string
	columns []string
}

// NewBase создаёт базовый репозиторий.
func NewBase[T any](q database.Querier, table string, columns []string) *Base[T] {
	return &Base[T]{
		querier: q,
		table:   table,
		columns: columns,
	}
}

// Q возвращает Querier для использования в специализированных методах.
func (r *Base[T]) Q() database.Querier {
	return r.querier
}

// Table возвращает имя таблицы.
func (r *Base[T]) Table() string {
	return r.table
}

// Columns возвращает список колонок для SELECT.
func (r *Base[T]) Columns() []string {
	return r.columns
}

// SelectBuilder возвращает базовый SELECT builder.
func (r *Base[T]) SelectBuilder() squirrel.SelectBuilder {
	return Builder.Select(r.columns...).From(r.table)
}

// ============================================================================
// READ OPERATIONS
// ============================================================================

// GetByID находит сущность по ID (первичный ключ).
// idColumn — имя колонки ID (например "id" или "cards.id").
func (r *Base[T]) GetByID(ctx context.Context, idColumn string, id any) (*T, error) {
	query := r.SelectBuilder().Where(squirrel.Eq{idColumn: id})
	return r.GetOne(ctx, query)
}

// GetOne выполняет запрос и возвращает одну сущность.
func (r *Base[T]) GetOne(ctx context.Context, query squirrel.SelectBuilder) (*T, error) {
	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var dest T
	if err := pgxscan.Get(ctx, r.querier, &dest, sql, args...); err != nil {
		if pgxscan.NotFound(err) {
			return nil, database.ErrNotFound
		}
		return nil, database.WrapDBError(err)
	}
	return &dest, nil
}

// List выполняет запрос и возвращает список сущностей.
func (r *Base[T]) List(ctx context.Context, query squirrel.SelectBuilder) ([]T, error) {
	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var dest []T
	if err := pgxscan.Select(ctx, r.querier, &dest, sql, args...); err != nil {
		return nil, database.WrapDBError(err)
	}
	return dest, nil
}

// ListAll возвращает все сущности с опциональными модификаторами.
func (r *Base[T]) ListAll(ctx context.Context, opts ...QueryOption) ([]T, error) {
	query := ApplyOptions(r.SelectBuilder(), opts...)
	return r.List(ctx, query)
}

// FindBy находит сущности по условию.
func (r *Base[T]) FindBy(ctx context.Context, column string, value any, opts ...QueryOption) ([]T, error) {
	query := r.SelectBuilder().Where(squirrel.Eq{column: value})
	query = ApplyOptions(query, opts...)
	return r.List(ctx, query)
}

// ListByIDs находит сущности по списку ID (WHERE id IN (...)).
// idColumn — имя колонки ID (например "id" или "cards.id").
// ids — слайс ID для поиска. Если пустой, возвращает пустой слайс без запроса к БД.
func (r *Base[T]) ListByIDs(ctx context.Context, idColumn string, ids []any, opts ...QueryOption) ([]T, error) {
	if len(ids) == 0 {
		return []T{}, nil
	}

	query := r.SelectBuilder().Where(squirrel.Eq{idColumn: ids})
	query = ApplyOptions(query, opts...)
	return r.List(ctx, query)
}

// FindOneBy находит одну сущность по условию.
func (r *Base[T]) FindOneBy(ctx context.Context, column string, value any) (*T, error) {
	query := r.SelectBuilder().Where(squirrel.Eq{column: value}).Limit(1)
	return r.GetOne(ctx, query)
}

// Exists проверяет существование записи.
func (r *Base[T]) Exists(ctx context.Context, column string, value any) (bool, error) {
	query := Builder.Select("1").From(r.table).Where(squirrel.Eq{column: value}).Limit(1)

	sql, args, err := query.ToSql()
	if err != nil {
		return false, database.WrapDBError(err)
	}

	var dummy int
	if err := pgxscan.Get(ctx, r.querier, &dummy, sql, args...); err != nil {
		if pgxscan.NotFound(err) {
			return false, nil
		}
		return false, database.WrapDBError(err)
	}
	return true, nil
}

// Count возвращает количество записей.
func (r *Base[T]) Count(ctx context.Context, opts ...QueryOption) (int64, error) {
	query := Builder.Select("COUNT(*)").From(r.table)
	query = ApplyOptions(query, opts...)

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	var count int64
	if err := pgxscan.Get(ctx, r.querier, &count, sql, args...); err != nil {
		return 0, database.WrapDBError(err)
	}
	return count, nil
}

// ============================================================================
// WRITE OPERATIONS
// ============================================================================

// InsertBuilder возвращает INSERT builder для таблицы.
func (r *Base[T]) InsertBuilder() squirrel.InsertBuilder {
	return Builder.Insert(r.table)
}

// UpdateBuilder возвращает UPDATE builder для таблицы.
func (r *Base[T]) UpdateBuilder() squirrel.UpdateBuilder {
	return Builder.Update(r.table)
}

// DeleteBuilder возвращает DELETE builder для таблицы.
func (r *Base[T]) DeleteBuilder() squirrel.DeleteBuilder {
	return Builder.Delete(r.table)
}

// Insert выполняет INSERT и возвращает ID (RETURNING).
func (r *Base[T]) Insert(ctx context.Context, insert squirrel.InsertBuilder, returningCol string) (any, error) {
	query := insert.Suffix("RETURNING " + returningCol)

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var id any
	if err := r.querier.QueryRow(ctx, sql, args...).Scan(&id); err != nil {
		return nil, database.WrapDBError(err)
	}
	return id, nil
}

// InsertReturning выполняет INSERT RETURNING * и сканирует результат в структуру.
func (r *Base[T]) InsertReturning(ctx context.Context, insert squirrel.InsertBuilder) (*T, error) {
	query := insert.Suffix("RETURNING *")

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var dest T
	if err := pgxscan.Get(ctx, r.querier, &dest, sql, args...); err != nil {
		return nil, database.WrapDBError(err)
	}
	return &dest, nil
}

// Update выполняет UPDATE и возвращает количество затронутых строк.
func (r *Base[T]) Update(ctx context.Context, update squirrel.UpdateBuilder) (int64, error) {
	sql, args, err := update.ToSql()
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	tag, err := r.querier.Exec(ctx, sql, args...)
	if err != nil {
		return 0, database.WrapDBError(err)
	}
	return tag.RowsAffected(), nil
}

// UpdateReturning выполняет UPDATE RETURNING * и сканирует результат.
func (r *Base[T]) UpdateReturning(ctx context.Context, update squirrel.UpdateBuilder) (*T, error) {
	query := update.Suffix("RETURNING *")

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var dest T
	if err := pgxscan.Get(ctx, r.querier, &dest, sql, args...); err != nil {
		if pgxscan.NotFound(err) {
			return nil, database.ErrNotFound
		}
		return nil, database.WrapDBError(err)
	}
	return &dest, nil
}

// Delete выполняет DELETE и возвращает количество удалённых строк.
func (r *Base[T]) Delete(ctx context.Context, del squirrel.DeleteBuilder) (int64, error) {
	sql, args, err := del.ToSql()
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	tag, err := r.querier.Exec(ctx, sql, args...)
	if err != nil {
		return 0, database.WrapDBError(err)
	}
	return tag.RowsAffected(), nil
}

// DeleteByID удаляет запись по ID.
func (r *Base[T]) DeleteByID(ctx context.Context, idColumn string, id any) error {
	del := r.DeleteBuilder().Where(squirrel.Eq{idColumn: id})

	affected, err := r.Delete(ctx, del)
	if err != nil {
		return err
	}
	if affected == 0 {
		return database.ErrNotFound
	}
	return nil
}

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

// BatchInsert выполняет вставку нескольких записей.
// columns — колонки для INSERT, valuesFunc — функция, возвращающая значения для каждой записи.
func (r *Base[T]) BatchInsert(ctx context.Context, columns []string, items []T, valuesFunc func(T) []any) (int64, error) {
	if len(items) == 0 {
		return 0, nil
	}

	insert := r.InsertBuilder().Columns(columns...)
	for _, item := range items {
		insert = insert.Values(valuesFunc(item)...)
	}

	sql, args, err := insert.ToSql()
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	tag, err := r.querier.Exec(ctx, sql, args...)
	if err != nil {
		return 0, database.WrapDBError(err)
	}
	return tag.RowsAffected(), nil
}

// ============================================================================
// SCALAR QUERIES
// ============================================================================

// GetScalar выполняет запрос и возвращает скалярное значение.
func GetScalar[R any](ctx context.Context, q database.Querier, query squirrel.SelectBuilder) (R, error) {
	var result R

	sql, args, err := query.ToSql()
	if err != nil {
		return result, database.WrapDBError(err)
	}

	if err := pgxscan.Get(ctx, q, &result, sql, args...); err != nil {
		if pgxscan.NotFound(err) {
			return result, nil
		}
		return result, database.WrapDBError(err)
	}
	return result, nil
}

// SelectScalars выполняет запрос и возвращает список скалярных значений.
func SelectScalars[R any](ctx context.Context, q database.Querier, query squirrel.SelectBuilder) ([]R, error) {
	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	var dest []R
	if err := pgxscan.Select(ctx, q, &dest, sql, args...); err != nil {
		return nil, database.WrapDBError(err)
	}
	return dest, nil
}


================================================================================

================================================================================
Файл: internal/database/repository/card/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/card/repository.go
================================================================================

package card

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Repository работает с таблицей cards.
type Repository struct {
	*repository.Base[model.Card]
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Card](q, schema.Cards.Name.String(), schema.Cards.Columns()),
	}
}

// GetByID возвращает активную (не удалённую) карточку по ID.
func (r *Repository) GetByID(ctx context.Context, id uuid.UUID) (*model.Card, error) {
	query := r.SelectBuilder().
		Where(schema.Cards.ID.Eq(id)).
		Where(schema.Cards.IsDeleted.Eq(false))

	return r.GetOne(ctx, query)
}

// ListByIDs возвращает список активных (не удалённых) карточек по списку ID.
func (r *Repository) ListByIDs(ctx context.Context, ids []uuid.UUID) ([]model.Card, error) {
	if len(ids) == 0 {
		return []model.Card{}, nil
	}

	query := r.SelectBuilder().
		Where(schema.Cards.ID.In(ids)).
		Where(schema.Cards.IsDeleted.Eq(false))

	return r.List(ctx, query)
}

// ListActive возвращает список активных карточек с возможностью фильтрации и пагинации.
func (r *Repository) ListActive(ctx context.Context, opts ...repository.QueryOption) ([]model.Card, error) {
	// Базовое условие - только не удаленные
	query := r.SelectBuilder().
		Where(schema.Cards.IsDeleted.Eq(false))

	// Применяем внешние опции (сортировка, лимит, офсет)
	query = repository.ApplyOptions(query, opts...)

	return r.List(ctx, query)
}

// Create создаёт новую карточку.
func (r *Repository) Create(ctx context.Context, card *model.Card) (*model.Card, error) {
	insert := r.InsertBuilder().
		Columns(schema.Cards.InsertColumns()...).
		Values(
			card.SenseID,
			card.CustomText,
			card.CustomTranscription,
			card.CustomTranslations,
			card.CustomNote,
			card.CustomImageURL,
		)

	return r.InsertReturning(ctx, insert)
}

// Update обновляет поля карточки.
func (r *Repository) Update(ctx context.Context, card *model.Card) (*model.Card, error) {
	now := time.Now()

	update := r.UpdateBuilder().
		Set(schema.Cards.CustomText.Bare(), card.CustomText).
		Set(schema.Cards.CustomTranscription.Bare(), card.CustomTranscription).
		Set(schema.Cards.CustomTranslations.Bare(), card.CustomTranslations).
		Set(schema.Cards.CustomNote.Bare(), card.CustomNote).
		Set(schema.Cards.CustomImageURL.Bare(), card.CustomImageURL).
		Set(schema.Cards.UpdatedAt.Bare(), now).
		Where(schema.Cards.ID.Eq(card.ID)).
		Where(schema.Cards.IsDeleted.Eq(false)) // Защита от обновления удаленных

	return r.UpdateReturning(ctx, update)
}

// SoftDelete помечает карточку как удалённую.
func (r *Repository) SoftDelete(ctx context.Context, id uuid.UUID) error {
	update := r.UpdateBuilder().
		Set(schema.Cards.IsDeleted.Bare(), true).
		Set(schema.Cards.UpdatedAt.Bare(), time.Now()).
		Where(schema.Cards.ID.Eq(id)).
		Where(schema.Cards.IsDeleted.Eq(false)) // Если уже удалена, rowsAffected будет 0

	// Используем базовый Update (который возвращает int64), а не UpdateReturning
	affected, err := r.Base.Update(ctx, update)
	if err != nil {
		return err
	}
	if affected == 0 {
		return database.ErrNotFound
	}
	return nil
}


================================================================================

================================================================================
Файл: internal/database/repository/cardtag/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/cardtag/repository.go
================================================================================

package cardtag

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Repository для таблицы card_tags.
// Не наследуем Base полностью, так как тут составной PK и специфичная логика.
type Repository struct {
	q database.Querier
}

func New(q database.Querier) *Repository {
	return &Repository{q: q}
}

func (r *Repository) Attach(ctx context.Context, cardID uuid.UUID, tagID int) error {
	query := repository.Builder.
		Insert(schema.CardTags.Name.String()).
		Columns(schema.CardTags.InsertColumns()...).
		Values(cardID, tagID).
		Suffix("ON CONFLICT DO NOTHING")

	_, err := database.ExecOnly(ctx, r.q, query)
	return err
}

func (r *Repository) Detach(ctx context.Context, cardID uuid.UUID, tagID int) error {
	query := repository.Builder.
		Delete(schema.CardTags.Name.String()).
		Where(schema.CardTags.CardID.Eq(cardID)).
		Where(schema.CardTags.TagID.Eq(tagID))

	_, err := database.ExecOnly(ctx, r.q, query)
	return err
}

func (r *Repository) DetachAll(ctx context.Context, cardID uuid.UUID) error {
	query := repository.Builder.
		Delete(schema.CardTags.Name.String()).
		Where(schema.CardTags.CardID.Eq(cardID))

	_, err := database.ExecOnly(ctx, r.q, query)
	return err
}

// GetTagIDsByCardID возвращает ID тегов для карточки.
func (r *Repository) GetTagIDsByCardID(ctx context.Context, cardID uuid.UUID) ([]int, error) {
	query := repository.Builder.
		Select(schema.CardTags.TagID.String()).
		From(schema.CardTags.Name.String()).
		Where(schema.CardTags.CardID.Eq(cardID))

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	return database.SelectScalars[int](ctx, r.q, sql, args...)
}

// GetTagsByCardID загружает полные модели тегов для карточки (JOIN).
func (r *Repository) GetTagsByCardID(ctx context.Context, cardID uuid.UUID) ([]model.Tag, error) {
	query := repository.Builder.
		Select(schema.Tags.Columns()...).
		From(schema.Tags.Name.String()).
		Join(schema.CardTags.Name.String() + " ON " + schema.Tags.ID.Qualified() + " = " + schema.CardTags.TagID.Qualified()).
		Where(schema.CardTags.CardID.Eq(cardID))

	// Используем helper из database package
	sql, args, err := query.ToSql()
	if err != nil {
		return nil, database.WrapDBError(err)
	}

	return database.Select[model.Tag](ctx, r.q, sql, args...)
}


================================================================================

================================================================================
Файл: internal/database/repository/datasource/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/datasource/repository.go
================================================================================

package datasource

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.DataSource]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.DataSource](q, schema.DataSources.Name.String(), schema.DataSources.Columns()),
	}
}

// GetByID возвращает источник по ID (int).
func (r *Repository) GetByID(ctx context.Context, id int) (*model.DataSource, error) {
	return r.Base.GetByID(ctx, schema.DataSources.ID.String(), id)
}

// GetBySlug возвращает источник по уникальному коду (например "freedict").
func (r *Repository) GetBySlug(ctx context.Context, slug string) (*model.DataSource, error) {
	return r.FindOneBy(ctx, schema.DataSources.Slug.String(), slug)
}


================================================================================

================================================================================
Файл: internal/database/repository/example/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/example/repository.go
================================================================================

package example

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.Example]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Example](q, schema.Examples.Name.String(), schema.Examples.Columns()),
	}
}

func (r *Repository) ListBySenseID(ctx context.Context, senseID uuid.UUID) ([]model.Example, error) {
	return r.FindBy(ctx, schema.Examples.SenseID.String(), senseID)
}

func (r *Repository) Create(ctx context.Context, ex *model.Example) (*model.Example, error) {
	insert := r.InsertBuilder().
		Columns(schema.Examples.InsertColumns()...).
		Values(ex.SenseID, ex.SentenceEn, ex.SentenceRu, ex.TargetWordRange, ex.SourceName)

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/factory/factory.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/factory/factory.go
================================================================================

package repository

import (
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository/card"
	"github.com/heartmarshall/my-english/internal/database/repository/cardtag"
	"github.com/heartmarshall/my-english/internal/database/repository/datasource"
	"github.com/heartmarshall/my-english/internal/database/repository/example"
	"github.com/heartmarshall/my-english/internal/database/repository/inbox"
	"github.com/heartmarshall/my-english/internal/database/repository/inflection"
	"github.com/heartmarshall/my-english/internal/database/repository/lexeme"
	"github.com/heartmarshall/my-english/internal/database/repository/pronunciation"
	"github.com/heartmarshall/my-english/internal/database/repository/review"
	"github.com/heartmarshall/my-english/internal/database/repository/sense"
	"github.com/heartmarshall/my-english/internal/database/repository/senserelation"
	"github.com/heartmarshall/my-english/internal/database/repository/sensetranslation"
	"github.com/heartmarshall/my-english/internal/database/repository/srs"
	"github.com/heartmarshall/my-english/internal/database/repository/tag"
)

// Factory позволяет создавать инстансы репозиториев с заданным экзекьютором (пул или транзакция).
type Factory struct{}

func NewFactory() *Factory {
	return &Factory{}
}

// --- System ---
func (f *Factory) DataSource(q database.Querier) *datasource.Repository {
	return datasource.New(q)
}

// --- Linguistic ---
func (f *Factory) Lexeme(q database.Querier) *lexeme.Repository {
	return lexeme.New(q)
}

func (f *Factory) Sense(q database.Querier) *sense.Repository {
	return sense.New(q)
}

func (f *Factory) SenseTranslation(q database.Querier) *sensetranslation.Repository {
	return sensetranslation.New(q)
}

func (f *Factory) SenseRelation(q database.Querier) *senserelation.Repository {
	return senserelation.New(q)
}

func (f *Factory) Inflection(q database.Querier) *inflection.Repository {
	return inflection.New(q)
}

func (f *Factory) Example(q database.Querier) *example.Repository {
	return example.New(q)
}

func (f *Factory) Pronunciation(q database.Querier) *pronunciation.Repository {
	return pronunciation.New(q)
}

// --- User & Study ---
func (f *Factory) Card(q database.Querier) *card.Repository {
	return card.New(q)
}

func (f *Factory) SRS(q database.Querier) *srs.Repository {
	return srs.New(q)
}

func (f *Factory) Review(q database.Querier) *review.Repository {
	return review.New(q)
}

func (f *Factory) Inbox(q database.Querier) *inbox.Repository {
	return inbox.New(q)
}

func (f *Factory) Tag(q database.Querier) *tag.Repository {
	return tag.New(q)
}

func (f *Factory) CardTag(q database.Querier) *cardtag.Repository {
	return cardtag.New(q)
}


================================================================================

================================================================================
Файл: internal/database/repository/inbox/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/inbox/repository.go
================================================================================

package inbox

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Repository работает с таблицей inbox_items.
type Repository struct {
	*repository.Base[model.InboxItem]
}

// New создаёт новый репозиторий inbox.
func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.InboxItem](q, schema.InboxItems.Name.String(), schema.InboxItems.Columns()),
	}
}

// GetByID находит элемент inbox по UUID.
func (r *Repository) GetByID(ctx context.Context, id uuid.UUID) (*model.InboxItem, error) {
	return r.Base.GetByID(ctx, schema.InboxItems.ID.String(), id)
}

// ListRecent возвращает последние элементы inbox, отсортированные по дате создания.
func (r *Repository) ListRecent(ctx context.Context, limit int) ([]model.InboxItem, error) {
	query := r.SelectBuilder().
		OrderBy(schema.InboxItems.CreatedAt.Desc())

	// Применяем лимит через функциональную опцию из родительского пакета repository
	query = repository.ApplyOptions(query, repository.WithLimit(limit))

	return r.List(ctx, query)
}

// Create создаёт новый элемент inbox.
// ID и CreatedAt генерируются базой данных (gen_random_uuid(), now()).
func (r *Repository) Create(ctx context.Context, item *model.InboxItem) (*model.InboxItem, error) {
	insert := r.InsertBuilder().
		Columns(schema.InboxItems.InsertColumns()...).
		Values(
			item.RawText,
			item.ContextNote,
		)

	return r.InsertReturning(ctx, insert)
}

// Delete удаляет элемент inbox по UUID.
func (r *Repository) Delete(ctx context.Context, id uuid.UUID) error {
	return r.DeleteByID(ctx, schema.InboxItems.ID.String(), id)
}


================================================================================

================================================================================
Файл: internal/database/repository/inflection/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/inflection/repository.go
================================================================================

package inflection

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.Inflection]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Inflection](q, schema.Inflections.Name.String(), schema.Inflections.Columns()),
	}
}

// GetFormsByLemmaID возвращает все формы для базового слова (Go -> Went, Gone).
func (r *Repository) GetFormsByLemmaID(ctx context.Context, lemmaID uuid.UUID) ([]model.Inflection, error) {
	return r.FindBy(ctx, schema.Inflections.LemmaLexemeID.String(), lemmaID)
}

// GetLemmaByInflectedID возвращает базовое слово для формы (Went -> Go).
// Обычно форма ссылается только на одну лемму, но возвращаем список для универсальности.
func (r *Repository) GetLemmaByInflectedID(ctx context.Context, inflectedID uuid.UUID) ([]model.Inflection, error) {
	return r.FindBy(ctx, schema.Inflections.InflectedLexemeID.String(), inflectedID)
}

// Create создаёт связь между леммой и формой.
func (r *Repository) Create(ctx context.Context, i *model.Inflection) (*model.Inflection, error) {
	insert := r.InsertBuilder().
		Columns(schema.Inflections.InsertColumns()...).
		Values(i.InflectedLexemeID, i.LemmaLexemeID, i.Type).
		Suffix("ON CONFLICT DO NOTHING RETURNING *") // Игнорируем дубли

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/interfaces.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/interfaces.go
================================================================================

package repository

import (
	"context"
)

// ============================================================================
// GENERIC REPOSITORY INTERFACES
// Используй эти интерфейсы для определения контрактов репозиториев.
// ============================================================================

// Reader интерфейс для операций чтения.
type Reader[T any, ID any] interface {
	GetByID(ctx context.Context, id ID) (*T, error)
	List(ctx context.Context, opts ...QueryOption) ([]T, error)
	ListByIDs(ctx context.Context, ids []ID) ([]T, error)
	Exists(ctx context.Context, id ID) (bool, error)
	Count(ctx context.Context, opts ...QueryOption) (int64, error)
}

// Writer интерфейс для операций записи.
type Writer[T any, ID any] interface {
	Create(ctx context.Context, entity *T) (*T, error)
	Update(ctx context.Context, entity *T) (*T, error)
	Delete(ctx context.Context, id ID) error
}

// Repository объединяет Reader и Writer.
type Repository[T any, ID any] interface {
	Reader[T, ID]
	Writer[T, ID]
}

// ============================================================================
// PAGINATED RESULT
// ============================================================================

// PagedResult содержит результаты с пагинацией.
type PagedResult[T any] struct {
	Items      []T   `json:"items"`
	TotalCount int64 `json:"total_count"`
	Limit      int   `json:"limit"`
	Offset     int   `json:"offset"`
	HasMore    bool  `json:"has_more"`
}

// NewPagedResult создаёт результат с пагинацией.
func NewPagedResult[T any](items []T, totalCount int64, limit, offset int) PagedResult[T] {
	return PagedResult[T]{
		Items:      items,
		TotalCount: totalCount,
		Limit:      limit,
		Offset:     offset,
		HasMore:    int64(offset+len(items)) < totalCount,
	}
}


================================================================================

================================================================================
Файл: internal/database/repository/lexeme/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/lexeme/repository.go
================================================================================

package lexeme

import (
	"context"
	"fmt"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database" // Импорт родителя
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

// Repository работает с таблицей lexemes.
// Мы называем структуру просто Repository, так как она внутри пакета lexeme.
// Использование: lexeme.Repository
type Repository struct {
	*repository.Base[model.Lexeme]
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Lexeme](q, schema.Lexemes.Name.String(), schema.Lexemes.Columns()),
	}
}

// FindByTextNormalized ищет точное совпадение.
func (r *Repository) FindByTextNormalized(ctx context.Context, text string) (*model.Lexeme, error) {
	return r.FindOneBy(ctx, schema.Lexemes.TextNormalized.String(), text)
}

// SearchFuzzy выполняет нечеткий поиск.
func (r *Repository) SearchFuzzy(ctx context.Context, query string, limit int) ([]model.Lexeme, error) {
	similarityExpr := fmt.Sprintf("similarity(%s, ?)", schema.Lexemes.TextNormalized.String())

	builder := r.SelectBuilder().
		Where(squirrel.Expr(fmt.Sprintf("%s %% ?", schema.Lexemes.TextNormalized.String()), query)).
		OrderBy(similarityExpr+" DESC", schema.Lexemes.TextDisplay.String()).
		Limit(uint64(limit))

	return r.List(ctx, builder)
}

// CreateWithConflictIgnore создает лексему или возвращает существующую.
func (r *Repository) CreateWithConflictIgnore(ctx context.Context, lexeme *model.Lexeme) (*model.Lexeme, error) {
	existing, err := r.FindByTextNormalized(ctx, lexeme.TextNormalized)
	if err == nil {
		return existing, nil
	}
	if err != database.ErrNotFound {
		return nil, err
	}

	insert := r.InsertBuilder().
		Columns(schema.Lexemes.InsertColumns()...).
		Values(lexeme.TextNormalized, lexeme.TextDisplay).
		Suffix("ON CONFLICT (text_normalized) DO UPDATE SET text_display = EXCLUDED.text_display RETURNING *")

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/options.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/options.go
================================================================================

// Package repository содержит базовые компоненты для работы с репозиториями.
package repository

import (
	"github.com/Masterminds/squirrel"
)

// ============================================================================
// PAGINATION
// ============================================================================

const (
	DefaultLimit = 20
	MaxLimit     = 100
)

// Pagination содержит параметры пагинации.
type Pagination struct {
	Limit  int
	Offset int
}

// NewPagination создаёт нормализованную пагинацию.
func NewPagination(limit, offset int) Pagination {
	if limit <= 0 {
		limit = DefaultLimit
	}
	if limit > MaxLimit {
		limit = MaxLimit
	}
	if offset < 0 {
		offset = 0
	}
	return Pagination{Limit: limit, Offset: offset}
}

// Apply применяет пагинацию к SelectBuilder.
func (p Pagination) Apply(b squirrel.SelectBuilder) squirrel.SelectBuilder {
	return b.Limit(uint64(p.Limit)).Offset(uint64(p.Offset))
}

// ============================================================================
// ORDERING
// ============================================================================

// OrderDirection направление сортировки.
type OrderDirection string

const (
	OrderAsc  OrderDirection = "ASC"
	OrderDesc OrderDirection = "DESC"
)

// OrderBy описывает один элемент сортировки.
type OrderBy struct {
	Column    string
	Direction OrderDirection
}

// String возвращает строку для ORDER BY.
func (o OrderBy) String() string {
	if o.Direction == "" {
		o.Direction = OrderAsc
	}
	return o.Column + " " + string(o.Direction)
}

// Ordering содержит параметры сортировки.
type Ordering []OrderBy

// Apply применяет сортировку к SelectBuilder.
func (o Ordering) Apply(b squirrel.SelectBuilder) squirrel.SelectBuilder {
	if len(o) == 0 {
		return b
	}
	orderClauses := make([]string, len(o))
	for i, ob := range o {
		orderClauses[i] = ob.String()
	}
	return b.OrderBy(orderClauses...)
}

// ============================================================================
// QUERY OPTIONS
// ============================================================================

// QueryOption функция для модификации SelectBuilder.
type QueryOption func(squirrel.SelectBuilder) squirrel.SelectBuilder

// WithPagination добавляет пагинацию.
func WithPagination(limit, offset int) QueryOption {
	p := NewPagination(limit, offset)
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		return p.Apply(b)
	}
}

// WithOrderBy добавляет сортировку.
func WithOrderBy(column string, direction OrderDirection) QueryOption {
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		return b.OrderBy(column + " " + string(direction))
	}
}

// WithOrderByDesc добавляет сортировку по убыванию.
func WithOrderByDesc(column string) QueryOption {
	return WithOrderBy(column, OrderDesc)
}

// WithOrderByAsc добавляет сортировку по возрастанию.
func WithOrderByAsc(column string) QueryOption {
	return WithOrderBy(column, OrderAsc)
}

// WithWhere добавляет условие WHERE.
func WithWhere(pred any, args ...any) QueryOption {
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		return b.Where(pred, args...)
	}
}

// WithLimit добавляет LIMIT.
func WithLimit(limit int) QueryOption {
	if limit <= 0 {
		limit = DefaultLimit
	}
	if limit > MaxLimit {
		limit = MaxLimit
	}
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		return b.Limit(uint64(limit))
	}
}

// WithOffset добавляет OFFSET.
func WithOffset(offset int) QueryOption {
	if offset < 0 {
		offset = 0
	}
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		return b.Offset(uint64(offset))
	}
}

// ApplyOptions применяет все опции к SelectBuilder.
func ApplyOptions(b squirrel.SelectBuilder, opts ...QueryOption) squirrel.SelectBuilder {
	for _, opt := range opts {
		b = opt(b)
	}
	return b
}

// ============================================================================
// FILTER HELPERS
// ============================================================================

// Filter представляет условие фильтрации.
type Filter struct {
	Column string
	Op     FilterOp
	Value  any
}

// FilterOp операция фильтрации.
type FilterOp string

const (
	FilterOpEq    FilterOp = "eq"
	FilterOpNotEq FilterOp = "neq"
	FilterOpLt    FilterOp = "lt"
	FilterOpLtEq  FilterOp = "lte"
	FilterOpGt    FilterOp = "gt"
	FilterOpGtEq  FilterOp = "gte"
	FilterOpIn    FilterOp = "in"
	FilterOpLike  FilterOp = "like"
	FilterOpILike FilterOp = "ilike"
)

// ToSquirrel конвертирует Filter в squirrel condition.
func (f Filter) ToSquirrel() squirrel.Sqlizer {
	switch f.Op {
	case FilterOpEq:
		return squirrel.Eq{f.Column: f.Value}
	case FilterOpNotEq:
		return squirrel.NotEq{f.Column: f.Value}
	case FilterOpLt:
		return squirrel.Lt{f.Column: f.Value}
	case FilterOpLtEq:
		return squirrel.LtOrEq{f.Column: f.Value}
	case FilterOpGt:
		return squirrel.Gt{f.Column: f.Value}
	case FilterOpGtEq:
		return squirrel.GtOrEq{f.Column: f.Value}
	case FilterOpIn:
		return squirrel.Eq{f.Column: f.Value}
	case FilterOpLike:
		return squirrel.Like{f.Column: f.Value}
	case FilterOpILike:
		return squirrel.ILike{f.Column: f.Value}
	default:
		return squirrel.Eq{f.Column: f.Value}
	}
}

// WithFilters добавляет несколько фильтров.
func WithFilters(filters ...Filter) QueryOption {
	return func(b squirrel.SelectBuilder) squirrel.SelectBuilder {
		for _, f := range filters {
			b = b.Where(f.ToSquirrel())
		}
		return b
	}
}



================================================================================

================================================================================
Файл: internal/database/repository/pronunciation/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/pronunciation/repository.go
================================================================================

package pronunciation

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.Pronunciation]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Pronunciation](q, schema.Pronunciations.Name.String(), schema.Pronunciations.Columns()),
	}
}

func (r *Repository) ListByLexemeID(ctx context.Context, lexemeID uuid.UUID) ([]model.Pronunciation, error) {
	return r.FindBy(ctx, schema.Pronunciations.LexemeID.String(), lexemeID)
}

func (r *Repository) Create(ctx context.Context, p *model.Pronunciation) (*model.Pronunciation, error) {
	insert := r.InsertBuilder().
		Columns(schema.Pronunciations.InsertColumns()...).
		Values(p.LexemeID, p.AudioURL, p.Transcription, p.Region, p.SourceID)

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/review/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/review/repository.go
================================================================================

package review

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.ReviewLog]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.ReviewLog](q, schema.ReviewLogs.Name.String(), schema.ReviewLogs.Columns()),
	}
}

func (r *Repository) ListByCardID(ctx context.Context, cardID uuid.UUID, limit int) ([]model.ReviewLog, error) {
	query := r.SelectBuilder().
		Where(schema.ReviewLogs.CardID.Eq(cardID)).
		OrderBy(schema.ReviewLogs.ReviewedAt.Desc())

	query = repository.ApplyOptions(query, repository.WithLimit(limit))
	return r.List(ctx, query)
}

func (r *Repository) Create(ctx context.Context, log *model.ReviewLog) error {
	// ID генерируется БД (serial/identity), поэтому не возвращаем структуру целиком, если не надо
	insert := r.InsertBuilder().
		Columns(schema.ReviewLogs.InsertColumns()...).
		Values(
			log.CardID,
			log.Grade,
			log.DurationMs,
			log.StateBefore,
			log.StateAfter,
		)

	// Используем ExecOnly, так как нам обычно не нужен ID лога сразу
	_, err := database.ExecOnly(ctx, r.Q(), insert)
	return err
}


================================================================================

================================================================================
Файл: internal/database/repository/sense/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/sense/repository.go
================================================================================

package sense

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.Sense]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Sense](q, schema.Senses.Name.String(), schema.Senses.Columns()),
	}
}

// GetByID возвращает смысл по UUID.
func (r *Repository) GetByID(ctx context.Context, id uuid.UUID) (*model.Sense, error) {
	return r.Base.GetByID(ctx, schema.Senses.ID.String(), id)
}

// ListByLexemeID возвращает список смыслов для конкретной лексемы.
func (r *Repository) ListByLexemeID(ctx context.Context, lexemeID uuid.UUID) ([]model.Sense, error) {
	return r.FindBy(ctx, schema.Senses.LexemeID.String(), lexemeID)
}

// Create создаёт новый смысл.
func (r *Repository) Create(ctx context.Context, sense *model.Sense) (*model.Sense, error) {
	insert := r.InsertBuilder().
		Columns(schema.Senses.InsertColumns()...).
		Values(
			sense.LexemeID,
			sense.PartOfSpeech,
			sense.Definition,
			sense.CefrLevel,
			sense.SourceID,
			sense.ExternalRefID,
		)

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/senserelation/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/senserelation/repository.go
================================================================================

package senserelation

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.SenseRelation]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.SenseRelation](q, schema.SenseRelations.Name.String(), schema.SenseRelations.Columns()),
	}
}

// ListBySourceSenseID возвращает связи, исходящие от смысла.
func (r *Repository) ListBySourceSenseID(ctx context.Context, senseID uuid.UUID) ([]model.SenseRelation, error) {
	return r.FindBy(ctx, schema.SenseRelations.SourceSenseID.String(), senseID)
}

// ListByTargetSenseID возвращает связи, входящие в смысл (кто ссылается на нас).
func (r *Repository) ListByTargetSenseID(ctx context.Context, senseID uuid.UUID) ([]model.SenseRelation, error) {
	return r.FindBy(ctx, schema.SenseRelations.TargetSenseID.String(), senseID)
}

func (r *Repository) Create(ctx context.Context, rel *model.SenseRelation) (*model.SenseRelation, error) {
	insert := r.InsertBuilder().
		Columns(schema.SenseRelations.InsertColumns()...).
		Values(rel.SourceSenseID, rel.TargetSenseID, rel.Type, rel.IsBidirectional, rel.SourceID).
		Suffix("ON CONFLICT DO NOTHING RETURNING *")

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/sensetranslation/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/sensetranslation/repository.go
================================================================================

package sensetranslation

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.SenseTranslation]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.SenseTranslation](q, schema.SenseTranslations.Name.String(), schema.SenseTranslations.Columns()),
	}
}

// ListBySenseID возвращает список переводов для конкретного смысла.
func (r *Repository) ListBySenseID(ctx context.Context, senseID uuid.UUID) ([]model.SenseTranslation, error) {
	return r.FindBy(ctx, schema.SenseTranslations.SenseID.String(), senseID)
}

// Create создаёт новый перевод.
func (r *Repository) Create(ctx context.Context, t *model.SenseTranslation) (*model.SenseTranslation, error) {
	insert := r.InsertBuilder().
		Columns(schema.SenseTranslations.InsertColumns()...).
		Values(t.SenseID, t.Translation, t.SourceID)

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/srs/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/srs/repository.go
================================================================================

package srs

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.SRSState]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.SRSState](q, schema.SRSStates.Name.String(), schema.SRSStates.Columns()),
	}
}

// GetByCardID возвращает состояние SRS для карточки.
func (r *Repository) GetByCardID(ctx context.Context, cardID uuid.UUID) (*model.SRSState, error) {
	// В этой таблице card_id является Primary Key
	return r.Base.GetByID(ctx, schema.SRSStates.CardID.String(), cardID)
}

// ListDueForReview возвращает карточки, которые нужно повторить (due_date < now).
func (r *Repository) ListDueForReview(ctx context.Context, limit int) ([]model.SRSState, error) {
	query := r.SelectBuilder().
		Where(schema.SRSStates.DueDate.LtOrEq(time.Now())).
		Where(schema.SRSStates.Status.NotEq(model.LearningStatusMastered)).
		OrderBy(schema.SRSStates.DueDate.Asc())

	query = repository.ApplyOptions(query, repository.WithLimit(limit))
	return r.List(ctx, query)
}

// Upsert создает или обновляет состояние SRS.
func (r *Repository) Upsert(ctx context.Context, state *model.SRSState) (*model.SRSState, error) {
	insert := r.InsertBuilder().
		Columns(schema.SRSStates.InsertColumns()...).
		Values(
			state.CardID,
			state.Status,
			state.DueDate,
			state.AlgorithmData, // pgx/v5 автоматически сериализует map[string]any в JSONB
		).
		Suffix("ON CONFLICT (card_id) DO UPDATE SET status = EXCLUDED.status, due_date = EXCLUDED.due_date, algorithm_data = EXCLUDED.algorithm_data, last_review_at = EXCLUDED.last_review_at RETURNING *")

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/repository/tag/repository.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/repository/tag/repository.go
================================================================================

package tag

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	"github.com/heartmarshall/my-english/internal/database/schema"
	"github.com/heartmarshall/my-english/internal/model"
)

type Repository struct {
	*repository.Base[model.Tag]
}

func New(q database.Querier) *Repository {
	return &Repository{
		Base: repository.NewBase[model.Tag](q, schema.Tags.Name.String(), schema.Tags.Columns()),
	}
}

func (r *Repository) GetByName(ctx context.Context, name string) (*model.Tag, error) {
	return r.FindOneBy(ctx, schema.Tags.NameCol.String(), name)
}

func (r *Repository) Create(ctx context.Context, tag *model.Tag) (*model.Tag, error) {
	insert := r.InsertBuilder().
		Columns(schema.Tags.InsertColumns()...).
		Values(tag.Name, tag.ColorHex)

	return r.InsertReturning(ctx, insert)
}


================================================================================

================================================================================
Файл: internal/database/schema/schema.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/schema/schema.go
================================================================================

// Package schema содержит определения таблиц и колонок БД.
// Используется для type-safe построения SQL запросов через squirrel.
package schema

import (
	"strings"

	"github.com/Masterminds/squirrel"
)

// Table описывает таблицу базы данных.
type Table string

func (t Table) String() string { return string(t) }

// Column описывает колонку с опциональным префиксом таблицы.
type Column string

func (c Column) String() string { return string(c) }

// Qualified возвращает полное имя колонки "table.column".
func (c Column) Qualified() string { return string(c) }

// Bare возвращает "голое" имя колонки без таблицы.
func (c Column) Bare() string {
	parts := strings.Split(string(c), ".")
	if len(parts) > 1 {
		return parts[1]
	}
	return string(c)
}

// --- Fluent API для условий WHERE ---

func (c Column) Eq(val any) squirrel.Eq          { return squirrel.Eq{string(c): val} }
func (c Column) NotEq(val any) squirrel.NotEq    { return squirrel.NotEq{string(c): val} }
func (c Column) Lt(val any) squirrel.Lt          { return squirrel.Lt{string(c): val} }
func (c Column) LtOrEq(val any) squirrel.LtOrEq  { return squirrel.LtOrEq{string(c): val} }
func (c Column) Gt(val any) squirrel.Gt          { return squirrel.Gt{string(c): val} }
func (c Column) GtOrEq(val any) squirrel.GtOrEq  { return squirrel.GtOrEq{string(c): val} }
func (c Column) In(vals any) squirrel.Eq         { return squirrel.Eq{string(c): vals} }
func (c Column) NotIn(vals any) squirrel.NotEq   { return squirrel.NotEq{string(c): vals} }
func (c Column) Like(pat string) squirrel.Like   { return squirrel.Like{string(c): pat} }
func (c Column) ILike(pat string) squirrel.ILike { return squirrel.ILike{string(c): pat} }
func (c Column) IsNull() squirrel.Eq             { return squirrel.Eq{string(c): nil} }
func (c Column) IsNotNull() squirrel.NotEq       { return squirrel.NotEq{string(c): nil} }

// --- Fluent API для ORDER BY ---

func (c Column) Desc() string { return string(c) + " DESC" }
func (c Column) Asc() string  { return string(c) + " ASC" }

// ============================================================================
// SYSTEM LAYER
// ============================================================================

type DataSourcesTable struct {
	Name        Table
	ID          Column
	Slug        Column
	DisplayName Column
	TrustLevel  Column
	WebsiteURL  Column
	CreatedAt   Column
}

var DataSources = DataSourcesTable{
	Name:        "data_sources",
	ID:          "data_sources.id",
	Slug:        "data_sources.slug",
	DisplayName: "data_sources.display_name",
	TrustLevel:  "data_sources.trust_level",
	WebsiteURL:  "data_sources.website_url",
	CreatedAt:   "data_sources.created_at",
}

func (t DataSourcesTable) Columns() []string {
	return []string{
		string(t.ID), string(t.Slug), string(t.DisplayName),
		string(t.TrustLevel), string(t.WebsiteURL), string(t.CreatedAt),
	}
}

func (t DataSourcesTable) InsertColumns() []string {
	return []string{"slug", "display_name", "trust_level", "website_url"}
}

// ============================================================================
// LINGUISTIC LAYER
// ============================================================================

// --- Lexemes ---

type LexemesTable struct {
	Name           Table
	ID             Column
	TextNormalized Column
	TextDisplay    Column
	CreatedAt      Column
}

var Lexemes = LexemesTable{
	Name:           "lexemes",
	ID:             "lexemes.id",
	TextNormalized: "lexemes.text_normalized",
	TextDisplay:    "lexemes.text_display",
	CreatedAt:      "lexemes.created_at",
}

func (t LexemesTable) Columns() []string {
	return []string{
		string(t.ID), string(t.TextNormalized),
		string(t.TextDisplay), string(t.CreatedAt),
	}
}

func (t LexemesTable) InsertColumns() []string {
	return []string{"text_normalized", "text_display"}
}

type PronunciationsTable struct {
	Name          Table
	ID            Column
	LexemeID      Column
	AudioURL      Column
	Transcription Column
	Region        Column
	SourceID      Column
}

var Pronunciations = PronunciationsTable{
	Name:          "pronunciations",
	ID:            "pronunciations.id",
	LexemeID:      "pronunciations.lexeme_id",
	AudioURL:      "pronunciations.audio_url",
	Transcription: "pronunciations.transcription",
	Region:        "pronunciations.region",
	SourceID:      "pronunciations.source_id",
}

func (t PronunciationsTable) Columns() []string {
	return []string{
		string(t.ID), string(t.LexemeID), string(t.AudioURL),
		string(t.Transcription), string(t.Region), string(t.SourceID),
	}
}

func (t PronunciationsTable) InsertColumns() []string {
	return []string{"lexeme_id", "audio_url", "transcription", "region", "source_id"}
}

// --- Inflections ---

type InflectionsTable struct {
	Name              Table
	InflectedLexemeID Column
	LemmaLexemeID     Column
	Type              Column
}

var Inflections = InflectionsTable{
	Name:              "inflections",
	InflectedLexemeID: "inflections.inflected_lexeme_id",
	LemmaLexemeID:     "inflections.lemma_lexeme_id",
	Type:              "inflections.type",
}

func (t InflectionsTable) Columns() []string {
	return []string{
		string(t.InflectedLexemeID), string(t.LemmaLexemeID), string(t.Type),
	}
}

func (t InflectionsTable) InsertColumns() []string {
	return []string{"inflected_lexeme_id", "lemma_lexeme_id", "type"}
}

// --- Senses ---

type SensesTable struct {
	Name          Table
	ID            Column
	LexemeID      Column
	PartOfSpeech  Column
	Definition    Column
	CefrLevel     Column
	SourceID      Column
	ExternalRefID Column
	CreatedAt     Column
}

var Senses = SensesTable{
	Name:          "senses",
	ID:            "senses.id",
	LexemeID:      "senses.lexeme_id",
	PartOfSpeech:  "senses.part_of_speech",
	Definition:    "senses.definition",
	CefrLevel:     "senses.cefr_level",
	SourceID:      "senses.source_id",
	ExternalRefID: "senses.external_ref_id",
	CreatedAt:     "senses.created_at",
}

func (t SensesTable) Columns() []string {
	return []string{
		string(t.ID), string(t.LexemeID), string(t.PartOfSpeech),
		string(t.Definition), string(t.CefrLevel), string(t.SourceID),
		string(t.ExternalRefID), string(t.CreatedAt),
	}
}

func (t SensesTable) InsertColumns() []string {
	return []string{"lexeme_id", "part_of_speech", "definition", "cefr_level", "source_id", "external_ref_id"}
}

// --- SenseTranslations ---

type SenseTranslationsTable struct {
	Name        Table
	ID          Column
	SenseID     Column
	Translation Column
	SourceID    Column
}

var SenseTranslations = SenseTranslationsTable{
	Name:        "sense_translations",
	ID:          "sense_translations.id",
	SenseID:     "sense_translations.sense_id",
	Translation: "sense_translations.translation",
	SourceID:    "sense_translations.source_id",
}

func (t SenseTranslationsTable) Columns() []string {
	return []string{
		string(t.ID), string(t.SenseID), string(t.Translation), string(t.SourceID),
	}
}

func (t SenseTranslationsTable) InsertColumns() []string {
	return []string{"sense_id", "translation", "source_id"}
}

// --- SenseRelations ---

type SenseRelationsTable struct {
	Name            Table
	SourceSenseID   Column
	TargetSenseID   Column
	Type            Column
	IsBidirectional Column
	SourceID        Column
}

var SenseRelations = SenseRelationsTable{
	Name:            "sense_relations",
	SourceSenseID:   "sense_relations.source_sense_id",
	TargetSenseID:   "sense_relations.target_sense_id",
	Type:            "sense_relations.type",
	IsBidirectional: "sense_relations.is_bidirectional",
	SourceID:        "sense_relations.source_id",
}

func (t SenseRelationsTable) Columns() []string {
	return []string{
		string(t.SourceSenseID), string(t.TargetSenseID),
		string(t.Type), string(t.IsBidirectional), string(t.SourceID),
	}
}

func (t SenseRelationsTable) InsertColumns() []string {
	return []string{"source_sense_id", "target_sense_id", "type", "is_bidirectional", "source_id"}
}

// --- Examples ---

type ExamplesTable struct {
	Name            Table
	ID              Column
	SenseID         Column
	SentenceEn      Column
	SentenceRu      Column
	TargetWordRange Column
	SourceName      Column
}

var Examples = ExamplesTable{
	Name:            "examples",
	ID:              "examples.id",
	SenseID:         "examples.sense_id",
	SentenceEn:      "examples.sentence_en",
	SentenceRu:      "examples.sentence_ru",
	TargetWordRange: "examples.target_word_range",
	SourceName:      "examples.source_name",
}

func (t ExamplesTable) Columns() []string {
	return []string{
		string(t.ID), string(t.SenseID), string(t.SentenceEn),
		string(t.SentenceRu), string(t.TargetWordRange), string(t.SourceName),
	}
}

func (t ExamplesTable) InsertColumns() []string {
	return []string{"sense_id", "sentence_en", "sentence_ru", "target_word_range", "source_name"}
}

// ============================================================================
// USER LAYER
// ============================================================================

// --- InboxItems ---

type InboxItemsTable struct {
	Name        Table
	ID          Column
	RawText     Column
	ContextNote Column
	CreatedAt   Column
}

var InboxItems = InboxItemsTable{
	Name:        "inbox_items",
	ID:          "inbox_items.id",
	RawText:     "inbox_items.raw_text",
	ContextNote: "inbox_items.context_note",
	CreatedAt:   "inbox_items.created_at",
}

func (t InboxItemsTable) Columns() []string {
	return []string{
		string(t.ID), string(t.RawText), string(t.ContextNote), string(t.CreatedAt),
	}
}

func (t InboxItemsTable) InsertColumns() []string {
	return []string{"raw_text", "context_note"}
}

// --- Tags ---

type TagsTable struct {
	Name     Table
	ID       Column
	NameCol  Column
	ColorHex Column
}

var Tags = TagsTable{
	Name:     "tags",
	ID:       "tags.id",
	NameCol:  "tags.name",
	ColorHex: "tags.color_hex",
}

func (t TagsTable) Columns() []string {
	return []string{string(t.ID), string(t.NameCol), string(t.ColorHex)}
}

func (t TagsTable) InsertColumns() []string {
	return []string{"name", "color_hex"}
}

// --- Cards ---

type CardsTable struct {
	Name                Table
	ID                  Column
	SenseID             Column
	CustomText          Column
	CustomTranscription Column
	CustomTranslations  Column
	CustomNote          Column
	CustomImageURL      Column
	CreatedAt           Column
	UpdatedAt           Column
	IsDeleted           Column
}

var Cards = CardsTable{
	Name:                "cards",
	ID:                  "cards.id",
	SenseID:             "cards.sense_id",
	CustomText:          "cards.custom_text",
	CustomTranscription: "cards.custom_transcription",
	CustomTranslations:  "cards.custom_translations",
	CustomNote:          "cards.custom_note",
	CustomImageURL:      "cards.custom_image_url",
	CreatedAt:           "cards.created_at",
	UpdatedAt:           "cards.updated_at",
	IsDeleted:           "cards.is_deleted",
}

func (t CardsTable) Columns() []string {
	return []string{
		string(t.ID), string(t.SenseID), string(t.CustomText),
		string(t.CustomTranscription), string(t.CustomTranslations),
		string(t.CustomNote), string(t.CustomImageURL),
		string(t.CreatedAt), string(t.UpdatedAt), string(t.IsDeleted),
	}
}

func (t CardsTable) InsertColumns() []string {
	return []string{
		"sense_id", "custom_text", "custom_transcription",
		"custom_translations", "custom_note", "custom_image_url",
	}
}

// --- CardTags ---

type CardTagsTable struct {
	Name   Table
	CardID Column
	TagID  Column
}

var CardTags = CardTagsTable{
	Name:   "card_tags",
	CardID: "card_tags.card_id",
	TagID:  "card_tags.tag_id",
}

func (t CardTagsTable) Columns() []string {
	return []string{string(t.CardID), string(t.TagID)}
}

func (t CardTagsTable) InsertColumns() []string {
	return []string{"card_id", "tag_id"}
}

// --- SRSStates ---

type SRSStatesTable struct {
	Name          Table
	CardID        Column
	Status        Column
	DueDate       Column
	AlgorithmData Column
	LastReviewAt  Column
}

var SRSStates = SRSStatesTable{
	Name:          "srs_states",
	CardID:        "srs_states.card_id",
	Status:        "srs_states.status",
	DueDate:       "srs_states.due_date",
	AlgorithmData: "srs_states.algorithm_data",
	LastReviewAt:  "srs_states.last_review_at",
}

func (t SRSStatesTable) Columns() []string {
	return []string{
		string(t.CardID), string(t.Status), string(t.DueDate),
		string(t.AlgorithmData), string(t.LastReviewAt),
	}
}

func (t SRSStatesTable) InsertColumns() []string {
	return []string{"card_id", "status", "due_date", "algorithm_data"}
}

// --- ReviewLogs ---

type ReviewLogsTable struct {
	Name        Table
	ID          Column
	CardID      Column
	Grade       Column
	DurationMs  Column
	ReviewedAt  Column
	StateBefore Column
	StateAfter  Column
}

var ReviewLogs = ReviewLogsTable{
	Name:        "review_logs",
	ID:          "review_logs.id",
	CardID:      "review_logs.card_id",
	Grade:       "review_logs.grade",
	DurationMs:  "review_logs.duration_ms",
	ReviewedAt:  "review_logs.reviewed_at",
	StateBefore: "review_logs.state_before",
	StateAfter:  "review_logs.state_after",
}

func (t ReviewLogsTable) Columns() []string {
	return []string{
		string(t.ID), string(t.CardID), string(t.Grade),
		string(t.DurationMs), string(t.ReviewedAt),
		string(t.StateBefore), string(t.StateAfter),
	}
}

func (t ReviewLogsTable) InsertColumns() []string {
	return []string{"card_id", "grade", "duration_ms", "state_before", "state_after"}
}


================================================================================

================================================================================
Файл: internal/database/testutil/testutil.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/database/testutil/testutil.go
================================================================================

package testutil

import (
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

// MockClock — мок для database.Clock.
type MockClock struct {
	Time time.Time
}

// Now возвращает заранее заданное время.
func (m *MockClock) Now() time.Time {
	return m.Time
}

// FixedTime возвращает фиксированное время для тестов.
func FixedTime() time.Time {
	return time.Date(2025, 1, 15, 10, 30, 0, 0, time.UTC)
}

// NewMockClock создаёт MockClock с фиксированным временем.
func NewMockClock() *MockClock {
	return &MockClock{Time: FixedTime()}
}

// Compile-time проверка.
var _ database.Clock = (*MockClock)(nil)

// NewMockQuerier создаёт мок Querier для тестов.
func NewMockQuerier(t *testing.T) (database.Querier, pgxmock.PgxPoolIface) {
	t.Helper()

	mock, err := pgxmock.NewPool()
	if err != nil {
		t.Fatalf("failed to create pgxmock: %v", err)
	}

	t.Cleanup(func() {
		mock.Close()
	})

	return mock, mock
}

// ExpectationsWereMet проверяет, что все ожидания pgxmock выполнены.
func ExpectationsWereMet(t *testing.T, mock pgxmock.PgxPoolIface) {
	t.Helper()

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("unfulfilled expectations: %v", err)
	}
}


================================================================================

================================================================================
Файл: internal/model/enums.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/model/enums.go
================================================================================

package model

// PartOfSpeech представляет часть речи.
type PartOfSpeech string

const (
	PartOfSpeechNoun         PartOfSpeech = "noun"
	PartOfSpeechVerb         PartOfSpeech = "verb"
	PartOfSpeechAdjective    PartOfSpeech = "adjective"
	PartOfSpeechAdverb       PartOfSpeech = "adverb"
	PartOfSpeechPronoun      PartOfSpeech = "pronoun"
	PartOfSpeechPreposition  PartOfSpeech = "preposition"
	PartOfSpeechConjunction  PartOfSpeech = "conjunction"
	PartOfSpeechInterjection PartOfSpeech = "interjection"
	PartOfSpeechPhrase       PartOfSpeech = "phrase"
	PartOfSpeechIdiom        PartOfSpeech = "idiom"
	PartOfSpeechOther        PartOfSpeech = "other"
)

func (p PartOfSpeech) String() string { return string(p) }

func (p PartOfSpeech) IsValid() bool {
	switch p {
	case PartOfSpeechNoun, PartOfSpeechVerb, PartOfSpeechAdjective,
		PartOfSpeechAdverb, PartOfSpeechPronoun, PartOfSpeechPreposition,
		PartOfSpeechConjunction, PartOfSpeechInterjection,
		PartOfSpeechPhrase, PartOfSpeechIdiom, PartOfSpeechOther:
		return true
	}
	return false
}

// AccentRegion представляет регион акцента.
type AccentRegion string

const (
	AccentRegionUS      AccentRegion = "us"
	AccentRegionUK      AccentRegion = "uk"
	AccentRegionAU      AccentRegion = "au"
	AccentRegionGeneral AccentRegion = "general"
)

func (a AccentRegion) String() string { return string(a) }

// RelationType представляет тип семантической связи.
type RelationType string

const (
	RelationTypeSynonym     RelationType = "synonym"
	RelationTypeAntonym     RelationType = "antonym"
	RelationTypeRelated     RelationType = "related"
	RelationTypeCollocation RelationType = "collocation"
)

func (r RelationType) String() string { return string(r) }

// MorphologicalType представляет тип морфологической формы.
type MorphologicalType string

const (
	MorphTypePlural            MorphologicalType = "plural"
	MorphTypePastTense         MorphologicalType = "past_tense"
	MorphTypePastParticiple    MorphologicalType = "past_participle"
	MorphTypePresentParticiple MorphologicalType = "present_participle"
	MorphTypeComparative       MorphologicalType = "comparative"
	MorphTypeSuperlative       MorphologicalType = "superlative"
)

func (m MorphologicalType) String() string { return string(m) }


================================================================================

================================================================================
Файл: internal/model/model.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/model/model.go
================================================================================

// Package model содержит доменные модели приложения.
package model

import (
	"time"

	"github.com/google/uuid"
)

// ============================================================================
// SYSTEM LAYER
// ============================================================================

// DataSource представляет источник данных (freedict, user, system).
type DataSource struct {
	ID          int       `db:"id"`
	Slug        string    `db:"slug"`
	DisplayName string    `db:"display_name"`
	TrustLevel  int       `db:"trust_level"`
	WebsiteURL  *string   `db:"website_url"`
	CreatedAt   time.Time `db:"created_at"`
}

// ============================================================================
// LINGUISTIC LAYER
// ============================================================================

// Lexeme представляет слово/фразу в словаре.
type Lexeme struct {
	ID             uuid.UUID `db:"id"`
	TextNormalized string    `db:"text_normalized"`
	TextDisplay    string    `db:"text_display"`
	CreatedAt      time.Time `db:"created_at"`
}

// Pronunciation представляет произношение лексемы.
type Pronunciation struct {
	ID            uuid.UUID `db:"id"`
	LexemeID      uuid.UUID `db:"lexeme_id"`
	AudioURL      string    `db:"audio_url"`
	Transcription *string   `db:"transcription"`
	Region        string    `db:"region"` // us, uk, au, general
	SourceID      *int      `db:"source_id"`
}

// Inflection представляет морфологическую связь между формами слова.
type Inflection struct {
	InflectedLexemeID uuid.UUID `db:"inflected_lexeme_id"`
	LemmaLexemeID     uuid.UUID `db:"lemma_lexeme_id"`
	Type              string    `db:"type"` // plural, past_tense, etc.
}

// Sense представляет смысл/значение слова.
type Sense struct {
	ID            uuid.UUID `db:"id"`
	LexemeID      uuid.UUID `db:"lexeme_id"`
	PartOfSpeech  string    `db:"part_of_speech"`
	Definition    string    `db:"definition"`
	CefrLevel     *string   `db:"cefr_level"`
	SourceID      int       `db:"source_id"`
	ExternalRefID *string   `db:"external_ref_id"`
	CreatedAt     time.Time `db:"created_at"`
}

// SenseTranslation представляет перевод смысла.
type SenseTranslation struct {
	ID          uuid.UUID `db:"id"`
	SenseID     uuid.UUID `db:"sense_id"`
	Translation string    `db:"translation"`
	SourceID    *int      `db:"source_id"`
}

// SenseRelation представляет семантическую связь между смыслами.
type SenseRelation struct {
	SourceSenseID   uuid.UUID `db:"source_sense_id"`
	TargetSenseID   uuid.UUID `db:"target_sense_id"`
	Type            string    `db:"type"` // synonym, antonym, related, collocation
	IsBidirectional bool      `db:"is_bidirectional"`
	SourceID        *int      `db:"source_id"`
}

// Example представляет пример использования слова.
type Example struct {
	ID              uuid.UUID  `db:"id"`
	SenseID         *uuid.UUID `db:"sense_id"`
	SentenceEn      string     `db:"sentence_en"`
	SentenceRu      *string    `db:"sentence_ru"`
	TargetWordRange []int      `db:"target_word_range"` // [start, end]
	SourceName      *string    `db:"source_name"`
}

// ============================================================================
// USER LAYER
// ============================================================================

// InboxItem представляет элемент inbox (GTD).
type InboxItem struct {
	ID          uuid.UUID `db:"id"`
	RawText     string    `db:"raw_text"`
	ContextNote *string   `db:"context_note"`
	CreatedAt   time.Time `db:"created_at"`
}

// Tag представляет пользовательский тег.
type Tag struct {
	ID       int     `db:"id"`
	Name     string  `db:"name"`
	ColorHex *string `db:"color_hex"`
}

// Card представляет личную карточку пользователя.
type Card struct {
	ID                  uuid.UUID  `db:"id"`
	SenseID             *uuid.UUID `db:"sense_id"`
	CustomText          *string    `db:"custom_text"`
	CustomTranscription *string    `db:"custom_transcription"`
	CustomTranslations  []string   `db:"custom_translations"`
	CustomNote          *string    `db:"custom_note"`
	CustomImageURL      *string    `db:"custom_image_url"`
	CreatedAt           time.Time  `db:"created_at"`
	UpdatedAt           time.Time  `db:"updated_at"`
	IsDeleted           bool       `db:"is_deleted"`
}

// CardTag связывает карточку с тегом.
type CardTag struct {
	CardID uuid.UUID `db:"card_id"`
	TagID  int       `db:"tag_id"`
}

// LearningStatus представляет статус изучения.
type LearningStatus string

const (
	LearningStatusNew      LearningStatus = "new"
	LearningStatusLearning LearningStatus = "learning"
	LearningStatusReview   LearningStatus = "review"
	LearningStatusMastered LearningStatus = "mastered"
)

// SRSState представляет текущее состояние SRS для карточки.
type SRSState struct {
	CardID        uuid.UUID      `db:"card_id"`
	Status        LearningStatus `db:"status"`
	DueDate       *time.Time     `db:"due_date"`
	AlgorithmData map[string]any `db:"algorithm_data"`
	LastReviewAt  *time.Time     `db:"last_review_at"`
}

// ReviewLog представляет запись об одном повторении.
type ReviewLog struct {
	ID          int64          `db:"id"`
	CardID      uuid.UUID      `db:"card_id"`
	Grade       int            `db:"grade"` // 1-5
	DurationMs  *int           `db:"duration_ms"`
	ReviewedAt  time.Time      `db:"reviewed_at"`
	StateBefore map[string]any `db:"state_before"`
	StateAfter  map[string]any `db:"state_after"`
}


================================================================================

================================================================================
Файл: internal/service/card/create.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/card/create.go
================================================================================

package card

import (
	"context"
	"errors"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

func (s *Service) Create(ctx context.Context, input CreateCardInput) (*model.Card, error) {
	// 1. Валидация
	if input.SenseID == nil && (input.CustomText == nil || strings.TrimSpace(*input.CustomText) == "") {
		return nil, service.ErrInvalidInput // Должен быть либо SenseID, либо CustomText
	}

	var createdCard *model.Card

	// 2. Транзакция
	err := s.txManager.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		// --- A. Создаем Card ---
		cardRepo := s.repos.Card(tx)

		cardModel := &model.Card{
			SenseID:             input.SenseID,
			CustomText:          input.CustomText,
			CustomTranscription: input.CustomTranscription,
			CustomTranslations:  input.CustomTranslations,
			CustomNote:          input.CustomNote,
			CustomImageURL:      input.CustomImageURL,
		}

		var err error
		createdCard, err = cardRepo.Create(ctx, cardModel)
		if err != nil {
			return err
		}

		// --- B. Инициализируем SRS State (Status: New) ---
		srsRepo := s.repos.SRS(tx)
		initialState := &model.SRSState{
			CardID:        createdCard.ID,
			Status:        model.LearningStatusNew,
			DueDate:       nil,              // Для новых карт даты нет, пока не выучим
			AlgorithmData: map[string]any{}, // Пустой JSON (или дефолты алгоритма)
		}

		if _, err := srsRepo.Upsert(ctx, initialState); err != nil {
			return err
		}

		// --- C. Обрабатываем Теги ---
		if len(input.Tags) > 0 {
			tagRepo := s.repos.Tag(tx)
			cardTagRepo := s.repos.CardTag(tx)

			for _, tagName := range input.Tags {
				tagName = strings.TrimSpace(tagName)
				if tagName == "" {
					continue
				}

				// GetOrCreate Tag
				// Пытаемся найти
				tag, err := tagRepo.GetByName(ctx, tagName)
				if err != nil && !errors.Is(err, database.ErrNotFound) {
					return err
				}

				// Если не нашли - создаем
				if tag == nil {
					tag, err = tagRepo.Create(ctx, &model.Tag{Name: tagName})
					if err != nil {
						// Если параллельно создали такой же тег (race condition), пробуем найти снова
						if database.IsDuplicateError(err) {
							tag, err = tagRepo.GetByName(ctx, tagName)
							if err != nil {
								return err
							}
						} else {
							return err
						}
					}
				}

				// Привязываем к карточке
				if err := cardTagRepo.Attach(ctx, createdCard.ID, tag.ID); err != nil {
					return err
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return createdCard, nil
}


================================================================================

================================================================================
Файл: internal/service/card/dto.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/card/dto.go
================================================================================

package card

import "github.com/google/uuid"

type CreateCardInput struct {
	// Вариант А: Ссылка на словарь
	SenseID *uuid.UUID

	// Вариант Б: Полностью свое слово
	CustomText *string

	// Общие поля / Переопределения
	CustomTranscription *string
	CustomTranslations  []string
	CustomNote          *string
	CustomImageURL      *string

	// Теги (строки, например ["IT", "Verbs"])
	Tags []string
}

type UpdateCardInput struct {
	CustomTranscription *string
	CustomTranslations  []string
	CustomNote          *string
	CustomImageURL      *string
	Tags                []string
}

// Filter используется для поиска карточек пользователя
type Filter struct {
	Tags []string
}


================================================================================

================================================================================
Файл: internal/service/card/service.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/card/service.go
================================================================================

package card

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/repository"
	factory "github.com/heartmarshall/my-english/internal/database/repository/factory"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

type Service struct {
	repos     *factory.Factory
	txManager *database.TxManager
}

type Deps struct {
	Repos     *factory.Factory
	TxManager *database.TxManager
}

func New(deps Deps) *Service {
	return &Service{
		repos:     deps.Repos,
		txManager: deps.TxManager,
	}
}

// GetByID возвращает карточку по ID.
func (s *Service) GetByID(ctx context.Context, id uuid.UUID) (*model.Card, error) {
	// Используем обычный пул (чтение)
	card, err := s.repos.Card(s.txManager.Q()).GetByID(ctx, id)
	if err != nil {
		if database.IsNotFoundError(err) {
			return nil, service.ErrCardNotFound
		}
		return nil, err
	}
	return card, nil
}

// List возвращает список активных карточек с пагинацией.
func (s *Service) List(ctx context.Context, filter *Filter, limit, offset int) ([]model.Card, error) {
	// TODO: Реализовать фильтрацию по тегам (потребует JOIN или subquery в репозитории)
	// Пока возвращаем просто список активных

	opts := []repository.QueryOption{
		repository.WithPagination(limit, offset),
	}

	return s.repos.Card(s.txManager.Q()).ListActive(ctx, opts...)
}


================================================================================

================================================================================
Файл: internal/service/card/update.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/card/update.go
================================================================================

package card

import (
	"context"
	"errors"
	"strings"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

func (s *Service) Update(ctx context.Context, id uuid.UUID, input UpdateCardInput) (*model.Card, error) {
	var updatedCard *model.Card

	err := s.txManager.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		cardRepo := s.repos.Card(tx)

		// 1. Получаем текущую карточку (с блокировкой на обновление, если нужно, но пока просто Get)
		current, err := cardRepo.GetByID(ctx, id)
		if err != nil {
			if database.IsNotFoundError(err) {
				return service.ErrCardNotFound
			}
			return err
		}

		// 2. Обновляем поля
		current.CustomTranscription = input.CustomTranscription
		current.CustomTranslations = input.CustomTranslations
		current.CustomNote = input.CustomNote
		current.CustomImageURL = input.CustomImageURL

		// В CardRepository у нас нет метода Update, который принимает структуру целиком,
		// есть только SoftDelete. Нужно добавить метод Update в репозиторий,
		// либо использовать Base.UpdateBuilder вручную здесь (плохая практика).
		// *Предполагаем, что в repository/card/repository.go мы добавим метод Update*

		// TODO: Добавить метод Update в CardRepository.
		// Для MVP пока опустим детали реализации Update в репо, но логика сервиса такая:
		// _, err = cardRepo.Update(ctx, current)

		updatedCard = current

		// 3. Синхронизируем теги
		// Это сложная логика (найти diff и применить).
		// У нас в meaningTagRepo был метод SyncTags.
		// Стоит реализовать аналогичный SyncTags в CardTagRepository.

		if len(input.Tags) > 0 {
			tagRepo := s.repos.Tag(tx)
			cardTagRepo := s.repos.CardTag(tx)

			// Собираем ID новых тегов
			var newTagIDs []int
			for _, name := range input.Tags {
				name = strings.TrimSpace(name)
				if name == "" {
					continue
				}

				tag, err := tagRepo.GetByName(ctx, name)
				if err != nil && !errors.Is(err, database.ErrNotFound) {
					return err
				}

				if tag == nil {
					tag, err = tagRepo.Create(ctx, &model.Tag{Name: name}) // Упрощенно
					if err != nil {
						return err
					}
				}
				newTagIDs = append(newTagIDs, tag.ID)
			}

			// Удаляем старые связи
			if err := cardTagRepo.DetachAll(ctx, id); err != nil {
				return err
			}
			// Добавляем новые
			for _, tid := range newTagIDs {
				if err := cardTagRepo.Attach(ctx, id, tid); err != nil {
					return err
				}
			}
		}

		return nil
	})

	return updatedCard, err
}

func (s *Service) Delete(ctx context.Context, id uuid.UUID) error {
	// Soft Delete не требует транзакции, если мы не чистим связи
	return s.repos.Card(s.txManager.Q()).SoftDelete(ctx, id)
}


================================================================================

================================================================================
Файл: internal/service/dictionary/import.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/dictionary/import.go
================================================================================

package dictionary

import (
	"context"
	"fmt"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// SaveImportedWord сохраняет импортированное слово и все связанные данные (смыслы, переводы, примеры)
// в базу данных в рамках одной транзакции.
//
// sourceSlug — строковый идентификатор источника (например, "freedict"), который должен существовать в таблице data_sources.
func (s *Service) SaveImportedWord(ctx context.Context, word *ImportedWord, sourceSlug string) (*model.Lexeme, error) {
	var lexeme *model.Lexeme

	// Запускаем транзакцию. TxManager создаст tx и передаст её в функцию.
	err := s.txManager.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		// 1. Получаем ID источника данных по слагу
		// Это важно для FK в таблицах senses, pronunciations и т.д.
		dataSource, err := s.repos.DataSource(tx).GetBySlug(ctx, sourceSlug)
		if err != nil {
			return fmt.Errorf("failed to get data source '%s': %w", sourceSlug, err)
		}

		// 2. Создаем или находим Лексему (Слово)
		// Нормализуем текст (нижний регистр, trim) для поиска/создания
		normalizedText := strings.TrimSpace(strings.ToLower(word.Text))

		inputLexeme := &model.Lexeme{
			TextNormalized: normalizedText,
			TextDisplay:    strings.TrimSpace(word.Text),
		}

		// Используем репозиторий с внедренной транзакцией tx
		lexemeRepo := s.repos.Lexeme(tx)
		lexeme, err = lexemeRepo.CreateWithConflictIgnore(ctx, inputLexeme)
		if err != nil {
			return fmt.Errorf("failed to upsert lexeme: %w", err)
		}

		// 3. Сохраняем варианты произношения
		if len(word.Pronunciations) > 0 {
			pronRepo := s.repos.Pronunciation(tx)
			for _, p := range word.Pronunciations {
				// Создаем запись произношения
				_, err := pronRepo.Create(ctx, &model.Pronunciation{
					LexemeID:      lexeme.ID,
					AudioURL:      p.AudioURL,
					Transcription: &p.Transcription,
					Region:        string(p.Region),
					SourceID:      &dataSource.ID,
				})
				if err != nil {
					return fmt.Errorf("failed to create pronunciation: %w", err)
				}
			}
		}

		// 4. Сохраняем Смыслы (Senses) и вложенные в них данные
		senseRepo := s.repos.Sense(tx)
		transRepo := s.repos.SenseTranslation(tx)
		exRepo := s.repos.Example(tx)

		for _, senseData := range word.Senses {
			// 4.1 Создаем Sense
			sense, err := senseRepo.Create(ctx, &model.Sense{
				LexemeID:     lexeme.ID,
				PartOfSpeech: string(senseData.PartOfSpeech),
				Definition:   senseData.Definition,
				SourceID:     dataSource.ID,
				// CefrLevel и ExternalRefID можно добавить в DTO позже, если API их отдает
			})
			if err != nil {
				return fmt.Errorf("failed to create sense: %w", err)
			}

			// 4.2 Добавляем переводы к этому смыслу
			for _, tr := range senseData.Translations {
				if tr == "" {
					continue
				}
				_, err := transRepo.Create(ctx, &model.SenseTranslation{
					SenseID:     sense.ID,
					Translation: tr,
					SourceID:    &dataSource.ID,
				})
				if err != nil {
					return fmt.Errorf("failed to create translation: %w", err)
				}
			}

			// 4.3 Добавляем примеры к этому смыслу
			for _, ex := range senseData.Examples {
				// Пропускаем пустые примеры
				if ex.SentenceEn == "" {
					continue
				}

				exampleModel := &model.Example{
					SenseID:    &sense.ID,
					SentenceEn: ex.SentenceEn,
				}

				if ex.SentenceRu != "" {
					exampleModel.SentenceRu = &ex.SentenceRu
				}

				// SourceName пока оставляем пустым или можно брать DisplayName источника

				_, err := exRepo.Create(ctx, exampleModel)
				if err != nil {
					return fmt.Errorf("failed to create example: %w", err)
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return lexeme, nil
}


================================================================================

================================================================================
Файл: internal/service/dictionary/interfaces.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/dictionary/interfaces.go
================================================================================

package dictionary

import (
	"context"
)

// Provider (бывший Fetcher) — интерфейс для внешнего источника словаря.
type Provider interface {
	// SourceSlug возвращает уникальный идентификатор источника (должен совпадать с data_sources.slug).
	// Например: "freedict", "cambridge", "gpt4".
	SourceSlug() string

	// Fetch получает данные о слове.
	// Возвращает nil, nil, если слово не найдено.
	Fetch(ctx context.Context, query string) (*ImportedWord, error)
}


================================================================================

================================================================================
Файл: internal/service/dictionary/search.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/dictionary/search.go
================================================================================

package dictionary

import (
	"context"
	"log/slog"
	"strings"
	"sync"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/model"
	ctxlog "github.com/heartmarshall/my-english/pkg/context"
	"golang.org/x/sync/errgroup"
)

// Search ищет слова по запросу query.
// Логика работы (Read-Through Cache):
// 1. Ищет в локальной БД (нечеткий поиск по триграммам).
// 2. Если точного совпадения нет — параллельно опрашивает всех внешних провайдеров.
// 3. Найденные вовне данные сохраняет в БД.
// 4. Возвращает объединенный результат.
func (s *Service) Search(ctx context.Context, query string) ([]model.Lexeme, error) {
	query = strings.TrimSpace(strings.ToLower(query))
	if query == "" {
		return nil, nil
	}

	logger := ctxlog.L(ctx)

	// 1. Ищем локально (используем пул соединений вне транзакции)
	// Лимит 10, чтобы не забивать выдачу похожими словами, если их слишком много
	localResults, err := s.repos.Lexeme(s.txManager.Q()).SearchFuzzy(ctx, query, 10)
	if err != nil {
		return nil, err
	}

	// Проверяем, есть ли среди локальных результатов точное совпадение
	hasExactMatch := false
	for _, l := range localResults {
		if l.TextNormalized == query {
			hasExactMatch = true
			break
		}
	}

	// 2. Если точного совпадения нет, запускаем внешние источники
	// Если провайдеров нет, просто возвращаем локальные результаты
	if !hasExactMatch && len(s.providers) > 0 {
		var mu sync.Mutex
		foundLexemes := make([]*model.Lexeme, 0)

		// Создаем группу горутин с контекстом
		g, groupCtx := errgroup.WithContext(ctx)

		for _, provider := range s.providers {
			// Замыкание переменных для использования внутри горутины
			p := provider

			g.Go(func() error {
				// Используем groupCtx, чтобы отменить остальные запросы, если кто-то вернет критическую ошибку
				// (хотя мы здесь игнорируем ошибки провайдеров, чтобы не ломать общий поиск)
				imported, err := p.Fetch(groupCtx, query)
				if err != nil {
					// Логируем ошибку, но возвращаем nil, чтобы errgroup не отменял остальные горутины
					logger.Warn("dictionary provider failed",
						slog.String("provider", p.SourceSlug()),
						slog.String("query", query),
						slog.String("error", err.Error()))
					return nil
				}

				if imported == nil {
					return nil // Провайдер ничего не нашел
				}

				// Сохраняем результат в БД.
				// SaveImportedWord открывает свою независимую транзакцию, это безопасно в конкурентной среде.
				lexeme, err := s.SaveImportedWord(groupCtx, imported, p.SourceSlug())
				if err != nil {
					logger.Error("failed to save imported word",
						slog.String("provider", p.SourceSlug()),
						slog.String("error", err.Error()))
					return nil
				}

				// Добавляем результат в общий список (потокобезопасно)
				mu.Lock()
				foundLexemes = append(foundLexemes, lexeme)
				mu.Unlock()
				return nil
			})
		}

		// Ждем завершения всех провайдеров
		if err := g.Wait(); err != nil {
			// В текущей логике сюда мы попадем только при критических системных ошибках,
			// так как ошибки провайдеров мы подавили.
			return nil, err
		}

		// 3. Объединяем результаты
		if len(foundLexemes) > 0 {
			// Создаем мапу существующих ID, чтобы не добавить дубликаты
			// (если локальный поиск вернул нечеткое, а API вернул точное, которое совпало с нечетким)
			existingIDs := make(map[uuid.UUID]bool)
			for _, l := range localResults {
				existingIDs[l.ID] = true
			}

			// Добавляем новые найденные слова в НАЧАЛО списка
			newItems := make([]model.Lexeme, 0, len(foundLexemes))
			for _, ptr := range foundLexemes {
				if !existingIDs[ptr.ID] {
					newItems = append(newItems, *ptr)
				}
			}

			localResults = append(newItems, localResults...)
		}
	}

	return localResults, nil
}


================================================================================

================================================================================
Файл: internal/service/dictionary/service.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/dictionary/service.go
================================================================================

package dictionary

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	repository "github.com/heartmarshall/my-english/internal/database/repository/factory"
	"github.com/heartmarshall/my-english/internal/model"
)

type Service struct {
	repos     *repository.Factory
	txManager *database.TxManager
	providers []Provider
}

type Deps struct {
	Repos     *repository.Factory
	TxManager *database.TxManager
	Providers []Provider
}

func New(deps Deps) *Service {
	return &Service{
		repos:     deps.Repos,
		txManager: deps.TxManager,
		providers: deps.Providers,
	}
}

// GetLexeme возвращает лексему по ID (без вложенных связей, для простоты).
// В реальном GraphQL резолвере связи будут грузиться через DataLoaders.
func (s *Service) GetLexeme(ctx context.Context, id uuid.UUID) (*model.Lexeme, error) {
	return s.repos.Lexeme(s.txManager.Q()).GetByID(ctx, "id", id)
}


================================================================================

================================================================================
Файл: internal/service/dictionary/types.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/dictionary/types.go
================================================================================

package dictionary

import "github.com/heartmarshall/my-english/internal/model"

// ImportedWord — структура, представляющая слово, полученное из внешнего источника.
// Используется для импорта в базу данных.
type ImportedWord struct {
	Text           string
	Pronunciations []ImportedPronunciation
	Senses         []ImportedSense
}

type ImportedPronunciation struct {
	AudioURL      string
	Transcription string
	Region        model.AccentRegion
}

type ImportedSense struct {
	PartOfSpeech model.PartOfSpeech
	Definition   string
	Translations []string
	Examples     []ImportedExample
}

type ImportedExample struct {
	SentenceEn string
	SentenceRu string
}


================================================================================

================================================================================
Файл: internal/service/errors.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/errors.go
================================================================================

// Package service содержит бизнес-логику приложения.
package service

import "errors"

// Ошибки сервисного слоя.
var (
	// ErrWordNotFound — слово не найдено.
	ErrWordNotFound = errors.New("word not found")

	// ErrMeaningNotFound — значение не найдено.
	ErrMeaningNotFound = errors.New("meaning not found")

	// ErrWordAlreadyExists — слово уже существует.
	ErrWordAlreadyExists = errors.New("word already exists")

	// ErrInvalidInput — невалидные входные данные.
	ErrInvalidInput = errors.New("invalid input")

	// ErrInvalidGrade — невалидная оценка (должна быть 1-5).
	ErrInvalidGrade = errors.New("invalid grade")

	// ErrCardNotFound — карточка не найдена.
	ErrCardNotFound = errors.New("card not found")

	// ErrLexemeNotFound — лексема не найдена.
	ErrLexemeNotFound = errors.New("lexeme not found")

	// ErrSenseNotFound — смысл не найден.
	ErrSenseNotFound = errors.New("sense not found")
)



================================================================================

================================================================================
Файл: internal/service/study/queue.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/study/queue.go
================================================================================

package study

import (
	"context"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetQueue возвращает список карточек для изучения.
func (s *Service) GetQueue(ctx context.Context, limit int) ([]model.Card, error) {
	// 1. Получаем состояния SRS, которые пора учить
	// Используем обычный пул (чтение)
	srsRepo := s.repos.SRS(s.txManager.Q())

	// Метод ListDueForReview мы описали в репозитории ранее
	dueStates, err := srsRepo.ListDueForReview(ctx, limit)
	if err != nil {
		return nil, err
	}

	if len(dueStates) == 0 {
		return []model.Card{}, nil
	}

	// 2. Собираем ID карточек
	cardIDs := make([]uuid.UUID, len(dueStates))
	for i, state := range dueStates {
		cardIDs[i] = state.CardID
	}

	// 3. Загружаем сами карточки batch-запросом
	cardRepo := s.repos.Card(s.txManager.Q())
	cards, err := cardRepo.ListByIDs(ctx, cardIDs)
	if err != nil {
		return nil, err
	}

	return cards, nil
}


================================================================================

================================================================================
Файл: internal/service/study/review.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/study/review.go
================================================================================

package study

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/study/srs"
)

type ReviewResult struct {
	Card          model.Card
	SRS           model.SRSState
	StatusChanged bool
}

// Review обрабатывает ответ пользователя на карточку.
func (s *Service) Review(ctx context.Context, cardID uuid.UUID, grade int, durationMs int) (*ReviewResult, error) {
	if grade < 1 || grade > 5 {
		return nil, service.ErrInvalidGrade
	}

	var result *ReviewResult

	err := s.txManager.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		srsRepo := s.repos.SRS(tx)
		logRepo := s.repos.Review(tx)
		cardRepo := s.repos.Card(tx)

		// 1. Получаем текущее состояние SRS
		// Если его нет (странно, но возможно), создаем дефолтное
		currentState, err := srsRepo.GetByCardID(ctx, cardID)
		if err != nil && !database.IsNotFoundError(err) {
			return err
		}
		if currentState == nil {
			currentState = &model.SRSState{
				CardID:        cardID,
				Status:        model.LearningStatusNew,
				AlgorithmData: map[string]any{},
			}
		}

		// 2. Рассчитываем новое состояние
		now := time.Now()
		input := srs.Input{
			Status:        currentState.Status,
			AlgorithmData: currentState.AlgorithmData,
			Grade:         grade,
			Now:           now,
		}

		output := s.algo.Calculate(input)

		// 3. Обновляем SRS State
		newState := &model.SRSState{
			CardID:        cardID,
			Status:        output.Status,
			DueDate:       &output.NextReviewAt,
			AlgorithmData: output.AlgorithmData,
			LastReviewAt:  &now,
		}

		updatedState, err := srsRepo.Upsert(ctx, newState)
		if err != nil {
			return fmt.Errorf("failed to update srs state: %w", err)
		}

		// 4. Пишем лог (историю)
		// Используем указатель для опционального duration
		var dur *int
		if durationMs > 0 {
			dur = &durationMs
		}

		err = logRepo.Create(ctx, &model.ReviewLog{
			CardID:      cardID,
			Grade:       grade,
			DurationMs:  dur,
			ReviewedAt:  now,
			StateBefore: currentState.AlgorithmData,
			StateAfter:  output.AlgorithmData,
		})
		if err != nil {
			return fmt.Errorf("failed to create review log: %w", err)
		}

		// 5. Загружаем саму карточку для ответа
		card, err := cardRepo.GetByID(ctx, cardID)
		if err != nil {
			return err
		}

		result = &ReviewResult{
			Card:          *card,
			SRS:           *updatedState,
			StatusChanged: currentState.Status != output.Status,
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}


================================================================================

================================================================================
Файл: internal/service/study/service.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/study/service.go
================================================================================

package study

import (
	"github.com/heartmarshall/my-english/internal/database"
	factory "github.com/heartmarshall/my-english/internal/database/repository/factory"
	"github.com/heartmarshall/my-english/internal/service/study/srs"
)

type Service struct {
	repos     *factory.Factory
	txManager *database.TxManager
	algo      srs.Algorithm
}

type Deps struct {
	Repos     *factory.Factory
	TxManager *database.TxManager
	Algorithm srs.Algorithm // Опционально, иначе SM2
}

func New(deps Deps) *Service {
	algo := deps.Algorithm
	if algo == nil {
		algo = srs.NewSM2()
	}

	return &Service{
		repos:     deps.Repos,
		txManager: deps.TxManager,
		algo:      algo,
	}
}


================================================================================

================================================================================
Файл: internal/service/study/srs/algorithm.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/service/study/srs/algorithm.go
================================================================================

package srs

import (
	"math"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
)

// Constants for SM-2
const (
	defaultEaseFactor = 2.5
	minEaseFactor     = 1.3
	defaultInterval   = 1 // 1 день для новых
)

// Input — входные данные для алгоритма.
type Input struct {
	Status        model.LearningStatus
	AlgorithmData map[string]any // Сырые данные из БД (interval, ease_factor)
	Grade         int            // Оценка 1-5
	Now           time.Time
}

// Output — результат работы алгоритма.
type Output struct {
	Status        model.LearningStatus
	NextReviewAt  time.Time
	AlgorithmData map[string]any // Обновленные данные для БД
}

// Algorithm — интерфейс стратегии интервального повторения.
type Algorithm interface {
	Calculate(input Input) Output
}

// SM2 — реализация алгоритма SuperMemo-2.
type SM2 struct{}

func NewSM2() *SM2 {
	return &SM2{}
}

func (a *SM2) Calculate(in Input) Output {
	// 1. Извлекаем текущее состояние из JSONB
	interval := getInt(in.AlgorithmData, "interval", 0)
	easeFactor := getFloat(in.AlgorithmData, "ease_factor", defaultEaseFactor)
	reviewCount := getInt(in.AlgorithmData, "review_count", 0)

	var nextInterval int
	var nextStatus model.LearningStatus

	// 2. Логика SM-2
	if in.Grade < 3 {
		// Забыл: сброс
		reviewCount = 0
		nextInterval = 1
		nextStatus = model.LearningStatusLearning
		// Ease factor не меняется или немного уменьшается (опционально)
	} else {
		// Вспомнил
		reviewCount++

		if interval == 0 {
			nextInterval = 1
		} else if interval == 1 {
			nextInterval = 6
		} else {
			nextInterval = int(math.Ceil(float64(interval) * easeFactor))
		}

		// Корректировка Ease Factor
		// EF' = EF + (0.1 - (5-q) * (0.08 + (5-q) * 0.02))
		delta := 5 - float64(in.Grade)
		easeFactor = easeFactor + (0.1 - delta*(0.08+delta*0.02))
		if easeFactor < minEaseFactor {
			easeFactor = minEaseFactor
		}

		// Переход статусов
		if nextInterval > 21 {
			nextStatus = model.LearningStatusMastered
		} else {
			nextStatus = model.LearningStatusReview
		}
	}

	// 3. Формируем результат
	return Output{
		Status:       nextStatus,
		NextReviewAt: in.Now.AddDate(0, 0, nextInterval),
		AlgorithmData: map[string]any{
			"interval":     nextInterval,
			"ease_factor":  easeFactor,
			"review_count": reviewCount,
		},
	}
}

// Helpers для безопасного извлечения из map[string]any
func getInt(m map[string]any, key string, def int) int {
	if val, ok := m[key]; ok {
		// JSON числа часто приходят как float64
		if f, ok := val.(float64); ok {
			return int(f)
		}
		if i, ok := val.(int); ok {
			return i
		}
	}
	return def
}

func getFloat(m map[string]any, key string, def float64) float64 {
	if val, ok := m[key]; ok {
		if f, ok := val.(float64); ok {
			return f
		}
	}
	return def
}


================================================================================

================================================================================
Файл: internal/transport/errors.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/transport/errors.go
================================================================================

package transport

import (
	"context"
	"errors"
	"log/slog"

	"github.com/99designs/gqlgen/graphql"
	"github.com/heartmarshall/my-english/internal/service"
	ctxlog "github.com/heartmarshall/my-english/pkg/context"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// ErrorCode — коды ошибок для GraphQL.
type ErrorCode string

const (
	CodeNotFound      ErrorCode = "NOT_FOUND"
	CodeAlreadyExists ErrorCode = "ALREADY_EXISTS"
	CodeInvalidInput  ErrorCode = "INVALID_INPUT"
	CodeInternal      ErrorCode = "INTERNAL_ERROR"
)

// NewGraphQLError создаёт GraphQL ошибку с расширениями.
func NewGraphQLError(ctx context.Context, message string, code ErrorCode) *gqlerror.Error {
	return &gqlerror.Error{
		Message: message,
		Path:    graphql.GetPath(ctx),
		Extensions: map[string]interface{}{
			"code": string(code),
		},
	}
}

// HandleError преобразует service ошибки в GraphQL ошибки.
func HandleError(ctx context.Context, err error) error {
	if err == nil {
		return nil
	}

	switch {
	case errors.Is(err, service.ErrWordNotFound):
		return NewGraphQLError(ctx, "Word not found", CodeNotFound)

	case errors.Is(err, service.ErrMeaningNotFound):
		return NewGraphQLError(ctx, "Meaning not found", CodeNotFound)

	case errors.Is(err, service.ErrWordAlreadyExists):
		return NewGraphQLError(ctx, "Word already exists", CodeAlreadyExists)

	case errors.Is(err, service.ErrInvalidInput):
		return NewGraphQLError(ctx, "Invalid input", CodeInvalidInput)

	case errors.Is(err, service.ErrInvalidGrade):
		return NewGraphQLError(ctx, "Grade must be between 1 and 5", CodeInvalidInput)

	default:
		// Логируем реальную ошибку, но не показываем пользователю
		logger := ctxlog.L(ctx)
		logger.Error("internal server error",
			slog.String("error", err.Error()),
			slog.Any("error_type", err),
		)
		return NewGraphQLError(ctx, "Internal server error", CodeInternal)
	}
}


================================================================================

================================================================================
Файл: internal/transport/middleware/middleware.go
Полный путь: /home/alodi/playground/my-english/backend_v2/internal/transport/middleware/middleware.go
================================================================================

package middleware

import (
	"context"
	"log/slog"
	"net/http"
	"time"

	ctx "github.com/heartmarshall/my-english/pkg/context"
)

// LoggingMiddleware логирует HTTP запросы.
func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Wrap response writer to capture status code
			wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

			// Добавляем логгер в контекст
			requestCtx := ctx.WithLogger(r.Context(), logger)
			r = r.WithContext(requestCtx)

			next.ServeHTTP(wrapped, r)

			duration := time.Since(start)

			logger.Info("http request",
				slog.String("method", r.Method),
				slog.String("path", r.URL.Path),
				slog.Int("status", wrapped.statusCode),
				slog.Duration("duration", duration),
				slog.String("remote_addr", r.RemoteAddr),
			)
		})
	}
}

// RecoveryMiddleware обрабатывает паники.
func RecoveryMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					logger.Error("panic recovered",
						slog.Any("error", err),
						slog.String("path", r.URL.Path),
						slog.String("method", r.Method),
					)
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				}
			}()
			next.ServeHTTP(w, r)
		})
	}
}

// TimeoutMiddleware добавляет таймаут к контексту запроса.
func TimeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), timeout)
			defer cancel()

			// Канал для отслеживания завершения обработки
			done := make(chan struct{})

			go func() {
				next.ServeHTTP(w, r.WithContext(ctx))
				close(done)
			}()

			select {
			case <-done:
				// Запрос обработан успешно
			case <-ctx.Done():
				// Таймаут — возвращаем 503 если ещё не записали ответ
				if ctx.Err() == context.DeadlineExceeded {
					w.WriteHeader(http.StatusServiceUnavailable)
					w.Write([]byte(`{"error":"request timeout"}`))
				}
			}
		})
	}
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}


================================================================================

================================================================================
Файл: migrations/20260105000000_init_schema.sql
Полный путь: /home/alodi/playground/my-english/backend_v2/migrations/20260105000000_init_schema.sql
================================================================================

-- +goose Up
-- ============================================================================
-- INIT V2 SCHEMA
-- Полная перезагрузка схемы данных под архитектуру Dictionary + User Progress
-- ============================================================================

-- 1. Включаем необходимые расширения
CREATE EXTENSION IF NOT EXISTS "pgcrypto"; -- Для gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pg_trgm";  -- Для нечеткого поиска

-- 2. Очистка старой схемы (на случай, если она была)
-- Удаляем таблицы в обратном порядке зависимости
DROP TABLE IF EXISTS card_tags CASCADE;
DROP TABLE IF EXISTS review_logs CASCADE;
DROP TABLE IF EXISTS srs_states CASCADE;
DROP TABLE IF EXISTS cards CASCADE;
DROP TABLE IF EXISTS inbox_items CASCADE;
DROP TABLE IF EXISTS examples CASCADE;
DROP TABLE IF EXISTS sense_relations CASCADE;
DROP TABLE IF EXISTS sense_translations CASCADE;
DROP TABLE IF EXISTS senses CASCADE;
DROP TABLE IF EXISTS inflections CASCADE;
DROP TABLE IF EXISTS pronunciations CASCADE;
DROP TABLE IF EXISTS lexemes CASCADE;
DROP TABLE IF EXISTS data_sources CASCADE;
DROP TABLE IF EXISTS tags CASCADE;

-- Удаляем старые типы, если они были
DROP TYPE IF EXISTS morphological_type CASCADE;
DROP TYPE IF EXISTS relation_type CASCADE;
DROP TYPE IF EXISTS accent_region CASCADE;
DROP TYPE IF EXISTS part_of_speech CASCADE;
DROP TYPE IF EXISTS learning_status CASCADE;

-- 3. Создание ENUM типов
CREATE TYPE learning_status AS ENUM ('new', 'learning', 'review', 'mastered');
CREATE TYPE part_of_speech AS ENUM ('noun', 'verb', 'adjective', 'adverb', 'pronoun', 'preposition', 'conjunction', 'interjection', 'phrase', 'idiom', 'other');
CREATE TYPE accent_region AS ENUM ('us', 'uk', 'au', 'general');
CREATE TYPE relation_type AS ENUM ('synonym', 'antonym', 'related', 'collocation');
CREATE TYPE morphological_type AS ENUM ('plural', 'past_tense', 'past_participle', 'present_participle', 'comparative', 'superlative');

-- 4. SYSTEM LAYER (Источники данных)
CREATE TABLE data_sources (
    id SERIAL PRIMARY KEY,
    slug VARCHAR(50) NOT NULL UNIQUE, -- 'freedict', 'user', 'gpt4'
    display_name VARCHAR(100) NOT NULL,
    trust_level INTEGER DEFAULT 5,    -- 1-10, где 10 - максимальное доверие (юзер)
    website_url VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Заполним дефолтные источники
INSERT INTO data_sources (slug, display_name, trust_level) VALUES 
('user', 'User Manual Entry', 10),
('freedict', 'Free Dictionary API', 8),
('system', 'System Import', 9);

-- 5. LINGUISTIC LAYER (Глобальный словарь)

-- Лексемы (Слова)
CREATE TABLE lexemes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Нормализованный текст для поиска (lowercase, trim)
    text_normalized VARCHAR(100) NOT NULL UNIQUE,
    -- Оригинальное отображение (например "London" с большой буквы)
    text_display VARCHAR(100) NOT NULL,
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_lexemes_text_trgm ON lexemes USING gin (text_normalized gin_trgm_ops);

-- Произношение
CREATE TABLE pronunciations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lexeme_id UUID NOT NULL REFERENCES lexemes(id) ON DELETE CASCADE,
    
    audio_url VARCHAR(2048) NOT NULL,
    transcription VARCHAR(100),
    region accent_region DEFAULT 'general',
    
    source_id INTEGER REFERENCES data_sources(id)
);

CREATE INDEX idx_pronunciations_lexeme ON pronunciations(lexeme_id);

-- Морфология (Связи форм слов)
CREATE TABLE inflections (
    inflected_lexeme_id UUID REFERENCES lexemes(id) ON DELETE CASCADE,
    lemma_lexeme_id UUID REFERENCES lexemes(id) ON DELETE CASCADE,
    type morphological_type NOT NULL,
    
    PRIMARY KEY (inflected_lexeme_id, lemma_lexeme_id)
);

-- Смыслы (Meanings/Senses)
CREATE TABLE senses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lexeme_id UUID NOT NULL REFERENCES lexemes(id) ON DELETE CASCADE,
    
    part_of_speech part_of_speech NOT NULL,
    definition TEXT NOT NULL,
    cefr_level VARCHAR(2), -- A1, B2...
    
    source_id INTEGER NOT NULL REFERENCES data_sources(id),
    external_ref_id VARCHAR(100), -- ID во внешней системе для обновлений
    
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_senses_lexeme ON senses(lexeme_id);

-- Переводы смыслов (Словарь может давать несколько вариантов)
CREATE TABLE sense_translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sense_id UUID NOT NULL REFERENCES senses(id) ON DELETE CASCADE,
    translation TEXT NOT NULL,
    source_id INTEGER REFERENCES data_sources(id)
);

CREATE INDEX idx_sense_translations_sense ON sense_translations(sense_id);

-- Семантические связи (Синонимы и т.д.)
CREATE TABLE sense_relations (
    source_sense_id UUID NOT NULL REFERENCES senses(id) ON DELETE CASCADE,
    target_sense_id UUID NOT NULL REFERENCES senses(id) ON DELETE CASCADE,
    type relation_type NOT NULL,
    
    -- Направленность связи (true = двусторонняя, false = направленная source->target)
    is_bidirectional BOOLEAN NOT NULL DEFAULT TRUE,
    
    source_id INTEGER REFERENCES data_sources(id),
    
    PRIMARY KEY (source_sense_id, target_sense_id, type)
);

-- Примеры предложений
CREATE TABLE examples (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sense_id UUID REFERENCES senses(id) ON DELETE CASCADE,
    
    sentence_en TEXT NOT NULL,
    sentence_ru TEXT,
    
    -- Индексы [start, end] для подсветки целевого слова в sentence_en
    -- Пример: "I went home", went=[2, 6]
    target_word_range INTEGER[], 
    
    source_name VARCHAR(255) -- "Harry Potter, ch. 4"
);

CREATE INDEX idx_examples_sense ON examples(sense_id);

-- 6. USER LAYER (Пользовательские данные)

-- Inbox (GTD)
CREATE TABLE inbox_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    raw_text VARCHAR(255) NOT NULL,
    context_note TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Теги (Категории)
CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    color_hex VARCHAR(7)
);

-- Личные карточки (Cards)
CREATE TABLE cards (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Ссылка на словарь (Может быть NULL, если слово полностью кастомное)
    sense_id UUID REFERENCES senses(id) ON DELETE SET NULL,
    
    -- User Overrides (Кастомные данные пользователя)
    custom_text VARCHAR(100),
    custom_transcription VARCHAR(100),
    custom_translations TEXT[], -- Массив строк для удобства
    custom_note TEXT,           -- Личные заметки (Markdown)
    custom_image_url VARCHAR(2048),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE
);

CREATE INDEX idx_cards_sense ON cards(sense_id);
CREATE INDEX idx_cards_created_at ON cards(created_at);

-- Связь Карточки и Теги
CREATE TABLE card_tags (
    card_id UUID REFERENCES cards(id) ON DELETE CASCADE,
    tag_id INTEGER REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (card_id, tag_id)
);

-- SRS State (Текущий прогресс)
CREATE TABLE srs_states (
    card_id UUID PRIMARY KEY REFERENCES cards(id) ON DELETE CASCADE,
    
    status learning_status NOT NULL DEFAULT 'new',
    due_date TIMESTAMPTZ, -- Когда повторять
    
    -- Данные алгоритма (FSRS / SM-2)
    -- JSONB позволяет хранить stability, difficulty и т.д. без изменения схемы
    algorithm_data JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    last_review_at TIMESTAMPTZ
);

CREATE INDEX idx_srs_states_due_date ON srs_states(due_date);
CREATE INDEX idx_srs_states_status ON srs_states(status);

-- Review Logs (История для аналитики и обучения алгоритма)
CREATE TABLE review_logs (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    card_id UUID NOT NULL REFERENCES cards(id) ON DELETE CASCADE,
    
    grade SMALLINT NOT NULL CHECK (grade >= 1 AND grade <= 5),
    duration_ms INTEGER, -- Время ответа в миллисекундах
    
    reviewed_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Снапшоты состояния алгоритма (для отладки)
    state_before JSONB,
    state_after JSONB
);

CREATE INDEX idx_review_logs_card_id ON review_logs(card_id);
CREATE INDEX idx_review_logs_reviewed_at ON review_logs(reviewed_at);


-- +goose Down
-- ============================================================================
-- ROLLBACK
-- ============================================================================

DROP TABLE IF EXISTS review_logs;
DROP TABLE IF EXISTS srs_states;
DROP TABLE IF EXISTS card_tags;
DROP TABLE IF EXISTS cards;
DROP TABLE IF EXISTS tags;
DROP TABLE IF EXISTS inbox_items;
DROP TABLE IF EXISTS examples;
DROP TABLE IF EXISTS sense_relations;
DROP TABLE IF EXISTS sense_translations;
DROP TABLE IF EXISTS senses;
DROP TABLE IF EXISTS inflections;
DROP TABLE IF EXISTS pronunciations;
DROP TABLE IF EXISTS lexemes;
DROP TABLE IF EXISTS data_sources;

DROP TYPE IF EXISTS morphological_type;
DROP TYPE IF EXISTS relation_type;
DROP TYPE IF EXISTS accent_region;
DROP TYPE IF EXISTS part_of_speech;
DROP TYPE IF EXISTS learning_status;

================================================================================

================================================================================
Файл: migrations/README.md
Полный путь: /home/alodi/playground/my-english/backend_v2/migrations/README.md
================================================================================

# Миграции базы данных

Этот каталог содержит миграции базы данных, управляемые с помощью [goose](https://github.com/pressly/goose).

## Структура миграций

Миграции следуют формату `YYYYMMDDHHMMSS_description.sql` и используют директивы goose:
- `-- +goose Up` - код для применения миграции
- `-- +goose Down` - код для отката миграции

Оба блока находятся в одном файле.

## Использование

### Применить все миграции
```bash
make migrate-up DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Откатить последнюю миграцию
```bash
make migrate-down DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Проверить статус миграций
```bash
make migrate-status DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Создать новую миграцию
```bash
make migrate-create NAME=add_new_feature
```

## Порядок миграций

1. `20251223202429_create_enums` - создание ENUM типов
2. `20251223202430_create_words_table` - создание таблицы words
3. `20251223202431_create_meanings_table` - создание таблицы meanings
4. `20251223202432_create_examples_table` - создание таблицы examples
5. `20251223202433_create_tags_table` - создание таблицы tags
6. `20251223202434_create_meanings_tags_table` - создание таблицы связки meanings_tags

## Примечания

- Все миграции должны быть обратимыми (иметь соответствующий `.down.sql` файл)
- При создании новых миграций используйте команду `make migrate-create`
- Перед применением миграций убедитесь, что база данных существует



================================================================================

================================================================================
Файл: pkg/context/logger.go
Полный путь: /home/alodi/playground/my-english/backend_v2/pkg/context/logger.go
================================================================================

package context

import (
	"context"
	"log/slog"
)

type ctxKey string

const loggerKey ctxKey = "logger"

// WithLogger добавляет логгер в контекст.
func WithLogger(ctx context.Context, logger *slog.Logger) context.Context {
	return context.WithValue(ctx, loggerKey, logger)
}

// LoggerFromContext извлекает логгер из контекста.
// Если логгер не найден, возвращает default логгер.
func LoggerFromContext(ctx context.Context) *slog.Logger {
	if logger, ok := ctx.Value(loggerKey).(*slog.Logger); ok {
		return logger
	}
	return slog.Default()
}

// L — короткий алиас для LoggerFromContext.
func L(ctx context.Context) *slog.Logger {
	return LoggerFromContext(ctx)
}


================================================================================


================================================================================
ПРОПУЩЕННЫЕ ФАЙЛЫ:
================================================================================

  - go.sum
