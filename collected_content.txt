Содержимое директории: /home/alodi/playground/my-english/backend
Всего файлов собрано: 81
Пропущено файлов: 2

================================================================================


================================================================================
Файл: Makefile
Полный путь: /home/alodi/playground/my-english/backend/Makefile
================================================================================

.PHONY: generate
generate:
	@echo "Generating GraphQL code..."
	@if command -v gqlgen > /dev/null; then \
		gqlgen generate; \
	else \
		echo "gqlgen not found, installing..."; \
		go install github.com/99designs/gqlgen@latest; \
		gqlgen generate; \
	fi

.PHONY: generate-verbose
generate-verbose:
	@echo "Generating GraphQL code (verbose)..."
	@if command -v gqlgen > /dev/null; then \
		gqlgen generate -v; \
	else \
		echo "gqlgen not found, installing..."; \
		go install github.com/99designs/gqlgen@latest; \
		gqlgen generate -v; \
	fi

.PHONY: migrate-up
migrate-up:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-up DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Running migrations..."
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" up

.PHONY: migrate-down
migrate-down:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-down DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Rolling back migrations..."
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" down

.PHONY: migrate-status
migrate-status:
	@if [ -z "$(DB_URL)" ]; then \
		echo "Error: DB_URL environment variable is required"; \
		echo "Example: make migrate-status DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable"; \
		exit 1; \
	fi
	@echo "Migration status:"
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations postgres "$(DB_URL)" status

.PHONY: migrate-create
migrate-create:
	@if [ -z "$(NAME)" ]; then \
		echo "Error: NAME environment variable is required"; \
		echo "Example: make migrate-create NAME=add_new_column"; \
		exit 1; \
	fi
	@echo "Creating migration: $(NAME)"
	@go run github.com/pressly/goose/v3/cmd/goose -dir migrations create $(NAME) sql
	@echo "Migration created! Don't forget to add -- +goose Up and -- +goose Down directives."

.PHONY: help
help:
	@echo "Available commands:"
	@echo "  make generate         - Generate GraphQL code"
	@echo "  make generate-verbose - Generate GraphQL code with verbose output"
	@echo ""
	@echo "Migration commands:"
	@echo "  make migrate-up       - Apply all migrations (requires DB_URL)"
	@echo "  make migrate-down     - Rollback last migration (requires DB_URL)"
	@echo "  make migrate-status   - Show migration status (requires DB_URL)"
	@echo "  make migrate-create   - Create new migration (requires NAME)"
	@echo ""
	@echo "Examples:"
	@echo "  make migrate-up DB_URL=postgres://user:pass@localhost:5432/mydb?sslmode=disable"
	@echo "  make migrate-create NAME=add_user_table"



================================================================================

================================================================================
Файл: README.md
Полный путь: /home/alodi/playground/my-english/backend/README.md
================================================================================

# my-english

Стек: Go + postgres + graphql + squirel (для бд)

Сервис для практики английского языка.

## Генерация GraphQL кода

Для генерации GraphQL кода из схемы используйте команду:

```bash
make generate
```

Или напрямую:

```bash
go run github.com/99designs/gqlgen generate
```

После генерации будут созданы файлы:
- `graph/generated.go` - сгенерированный код сервера
- `graph/models_gen.go` - сгенерированные модели
- `graph/resolvers.go` - файлы резолверов (создаются автоматически)


================================================================================

================================================================================
Файл: cmd/server/main.go
Полный путь: /home/alodi/playground/my-english/backend/cmd/server/main.go
================================================================================

package main

import (
	"log"

	"github.com/heartmarshall/my-english/internal/app"
)

func main() {
	// Загружаем конфигурацию
	cfg := app.LoadFromEnv()

	// Создаём приложение
	application, err := app.New(cfg)
	if err != nil {
		log.Fatalf("Failed to create application: %v", err)
	}

	if err := application.Run(); err != nil {
		log.Fatalf("Application error: %v", err)
	}
}


================================================================================

================================================================================
Файл: go.mod
Полный путь: /home/alodi/playground/my-english/backend/go.mod
================================================================================

module github.com/heartmarshall/my-english

go 1.24.7

require (
	github.com/99designs/gqlgen v0.17.85
	github.com/DATA-DOG/go-sqlmock v1.5.2
	github.com/Masterminds/squirrel v1.5.4
	github.com/go-playground/validator/v10 v10.30.0
	github.com/jackc/pgx/v5 v5.7.6
	github.com/vektah/gqlparser/v2 v2.5.31
	github.com/vikstrous/dataloadgen v0.0.10
)

require (
	github.com/agnivade/levenshtein v1.2.1 // indirect
	github.com/gabriel-vasile/mimetype v1.4.12 // indirect
	github.com/georgysavva/scany/v2 v2.1.4 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-viper/mapstructure/v2 v2.4.0 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.0 // indirect
	github.com/hashicorp/golang-lru/v2 v2.0.7 // indirect
	github.com/jackc/chunkreader/v2 v2.0.1 // indirect
	github.com/jackc/pgconn v1.13.0 // indirect
	github.com/jackc/pgio v1.0.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgproto3/v2 v2.3.1 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgtype v1.12.0 // indirect
	github.com/jackc/pgx/v4 v4.17.0 // indirect
	github.com/jackc/puddle v1.2.1 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/lann/builder v0.0.0-20180802200727-47ae307949d0 // indirect
	github.com/lann/ps v0.0.0-20150810152359-62de8c46ede0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/pashagolub/pgxmock v1.8.0 // indirect
	github.com/pashagolub/pgxmock/v2 v2.12.0 // indirect
	github.com/sosodev/duration v1.3.1 // indirect
	go.opentelemetry.io/otel v1.11.1 // indirect
	go.opentelemetry.io/otel/trace v1.11.1 // indirect
	golang.org/x/crypto v0.46.0 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/sys v0.39.0 // indirect
	golang.org/x/text v0.32.0 // indirect
)


================================================================================

================================================================================
Файл: gqlgen.yml
Полный путь: /home/alodi/playground/my-english/backend/gqlgen.yml
================================================================================

# Where are all the schema files located?
schema:
  - graph/schema.graphqls

# Where should the generated server code go?
exec:
  filename: graph/generated.go
  package: graph

# Where should any generated models go?
model:
  filename: graph/models_gen.go
  package: graph

# Resolver configuration
resolver:
  layout: follow-schema
  dir: graph
  package: graph
  filename_template: "{name}.resolvers.go"

# Optional: turn on autobind
autobind:
  - "github.com/heartmarshall/my-english/graph"

# Map GraphQL types to Go types
models:
  Time:
    model: github.com/heartmarshall/my-english/graph.Time
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.IntID
  Word:
    fields:
      meanings:
        resolver: true
  Meaning:
    fields:
      examples:
        resolver: true
      tags:
        resolver: true


================================================================================

================================================================================
Файл: graph/converter.go
Полный путь: /home/alodi/playground/my-english/backend/graph/converter.go
================================================================================

package graph

import (
	"strconv"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/word"
)

// --- ID Conversion ---

// ToGraphQLID конвертирует int64 в GraphQL ID.
func ToGraphQLID(id int64) string {
	return strconv.FormatInt(id, 10)
}

// FromGraphQLID конвертирует GraphQL ID в int64.
func FromGraphQLID(id string) (int64, error) {
	return strconv.ParseInt(id, 10, 64)
}

// --- Enum Conversion ---

// ToGraphQLPartOfSpeech конвертирует domain enum в GraphQL enum.
func ToGraphQLPartOfSpeech(pos model.PartOfSpeech) PartOfSpeech {
	switch pos {
	case model.PartOfSpeechNoun:
		return PartOfSpeechNoun
	case model.PartOfSpeechVerb:
		return PartOfSpeechVerb
	case model.PartOfSpeechAdjective:
		return PartOfSpeechAdjective
	case model.PartOfSpeechAdverb:
		return PartOfSpeechAdverb
	default:
		return PartOfSpeechOther
	}
}

// FromGraphQLPartOfSpeech конвертирует GraphQL enum в domain enum.
func FromGraphQLPartOfSpeech(pos PartOfSpeech) model.PartOfSpeech {
	switch pos {
	case PartOfSpeechNoun:
		return model.PartOfSpeechNoun
	case PartOfSpeechVerb:
		return model.PartOfSpeechVerb
	case PartOfSpeechAdjective:
		return model.PartOfSpeechAdjective
	case PartOfSpeechAdverb:
		return model.PartOfSpeechAdverb
	default:
		return model.PartOfSpeechOther
	}
}

// ToGraphQLLearningStatus конвертирует domain enum в GraphQL enum.
func ToGraphQLLearningStatus(status model.LearningStatus) LearningStatus {
	switch status {
	case model.LearningStatusNew:
		return LearningStatusNew
	case model.LearningStatusLearning:
		return LearningStatusLearning
	case model.LearningStatusReview:
		return LearningStatusReview
	case model.LearningStatusMastered:
		return LearningStatusMastered
	default:
		return LearningStatusNew
	}
}

// ToGraphQLExampleSource конвертирует domain enum в GraphQL enum.
func ToGraphQLExampleSource(src *model.ExampleSource) *ExampleSource {
	if src == nil || *src == "" {
		return nil
	}
	var result ExampleSource
	switch *src {
	case model.ExampleSourceFilm:
		result = ExampleSourceFilm
	case model.ExampleSourceBook:
		result = ExampleSourceBook
	case model.ExampleSourceChat:
		result = ExampleSourceChat
	case model.ExampleSourceVideo:
		result = ExampleSourceVideo
	case model.ExampleSourcePodcast:
		result = ExampleSourcePodcast
	default:
		return nil
	}
	return &result
}

// FromGraphQLExampleSource конвертирует GraphQL string в domain enum.
func FromGraphQLExampleSource(src *string) *model.ExampleSource {
	if src == nil {
		return nil
	}
	var result model.ExampleSource
	switch *src {
	case "FILM", "film":
		result = model.ExampleSourceFilm
	case "BOOK", "book":
		result = model.ExampleSourceBook
	case "CHAT", "chat":
		result = model.ExampleSourceChat
	case "VIDEO", "video":
		result = model.ExampleSourceVideo
	case "PODCAST", "podcast":
		result = model.ExampleSourcePodcast
	default:
		return nil
	}
	return &result
}

// --- Model Conversion ---

// ToGraphQLWord конвертирует domain Word в GraphQL Word.
func ToGraphQLWord(w *model.Word, meanings []*Meaning) *Word {
	if w == nil {
		return nil
	}
	return &Word{
		ID:            ToGraphQLID(w.ID),
		Text:          w.Text,
		Transcription: w.Transcription,
		AudioURL:      w.AudioURL,
		FrequencyRank: w.FrequencyRank,
		Meanings:      meanings,
	}
}

// ToGraphQLMeaning конвертирует domain Meaning в GraphQL Meaning.
func ToGraphQLMeaning(m *model.Meaning, examples []*Example, tags []*Tag) *Meaning {
	if m == nil {
		return nil
	}

	reviewCount := 0
	if m.ReviewCount != nil {
		reviewCount = *m.ReviewCount
	}

	var nextReviewAt *Time
	if m.NextReviewAt != nil {
		t := Time(*m.NextReviewAt)
		nextReviewAt = &t
	}

	return &Meaning{
		ID:            ToGraphQLID(m.ID),
		WordID:        ToGraphQLID(m.WordID),
		PartOfSpeech:  ToGraphQLPartOfSpeech(m.PartOfSpeech),
		DefinitionEn:  m.DefinitionEn,
		TranslationRu: m.TranslationRu,
		CefrLevel:     m.CefrLevel,
		ImageURL:      m.ImageURL,
		Status:        ToGraphQLLearningStatus(m.LearningStatus),
		NextReviewAt:  nextReviewAt,
		ReviewCount:   reviewCount,
		Examples:      examples,
		Tags:          tags,
	}
}

// ToGraphQLExample конвертирует domain Example в GraphQL Example.
func ToGraphQLExample(e *model.Example) *Example {
	if e == nil {
		return nil
	}
	return &Example{
		ID:         ToGraphQLID(e.ID),
		SentenceEn: e.SentenceEn,
		SentenceRu: e.SentenceRu,
		SourceName: ToGraphQLExampleSource(e.SourceName),
	}
}

// ToGraphQLExamples конвертирует slice domain Examples в GraphQL Examples.
func ToGraphQLExamples(examples []*model.Example) []*Example {
	result := make([]*Example, 0, len(examples))
	for _, e := range examples {
		result = append(result, ToGraphQLExample(e))
	}
	return result
}

// ToGraphQLTag конвертирует domain Tag в GraphQL Tag.
func ToGraphQLTag(t *model.Tag) *Tag {
	if t == nil {
		return nil
	}
	return &Tag{
		ID:   ToGraphQLID(t.ID),
		Name: t.Name,
	}
}

// ToGraphQLTags конвертирует slice domain Tags в GraphQL Tags.
func ToGraphQLTags(tags []*model.Tag) []*Tag {
	result := make([]*Tag, 0, len(tags))
	for _, t := range tags {
		result = append(result, ToGraphQLTag(t))
	}
	return result
}

// ToGraphQLStats конвертирует domain Stats в GraphQL DashboardStats.
func ToGraphQLStats(s *model.Stats) *DashboardStats {
	if s == nil {
		return nil
	}
	return &DashboardStats{
		TotalWords:        s.TotalWords,
		MasteredCount:     s.MasteredCount,
		LearningCount:     s.LearningCount,
		DueForReviewCount: s.DueForReviewCount,
	}
}

// --- Input Conversion ---

// ToCreateWordInput конвертирует GraphQL input в service input.
func ToCreateWordInput(input AddWordInput) word.CreateWordInput {
	meanings := make([]word.CreateMeaningInput, 0, len(input.Meanings))
	for _, m := range input.Meanings {
		meanings = append(meanings, ToCreateMeaningInput(m))
	}

	return word.CreateWordInput{
		Text:          input.Text,
		Transcription: input.Transcription,
		AudioURL:      input.AudioURL,
		Meanings:      meanings,
	}
}

// ToCreateMeaningInput конвертирует GraphQL MeaningInput в service input.
func ToCreateMeaningInput(input *MeaningInput) word.CreateMeaningInput {
	if input == nil {
		return word.CreateMeaningInput{}
	}

	examples := make([]word.CreateExampleInput, 0, len(input.Examples))
	for _, e := range input.Examples {
		examples = append(examples, ToCreateExampleInput(e))
	}

	return word.CreateMeaningInput{
		PartOfSpeech:  FromGraphQLPartOfSpeech(input.PartOfSpeech),
		DefinitionEn:  input.DefinitionEn,
		TranslationRu: input.TranslationRu,
		ImageURL:      input.ImageURL,
		Examples:      examples,
		Tags:          input.Tags,
	}
}

// ToCreateExampleInput конвертирует GraphQL ExampleInput в service input.
func ToCreateExampleInput(input *ExampleInput) word.CreateExampleInput {
	if input == nil {
		return word.CreateExampleInput{}
	}

	return word.CreateExampleInput{
		SentenceEn: input.SentenceEn,
		SentenceRu: input.SentenceRu,
		SourceName: FromGraphQLExampleSource(input.SourceName),
	}
}

// ToUpdateWordInput конвертирует GraphQL input в service update input.
func ToUpdateWordInput(input AddWordInput) word.UpdateWordInput {
	meanings := make([]word.UpdateMeaningInput, 0, len(input.Meanings))
	for _, m := range input.Meanings {
		meanings = append(meanings, ToUpdateMeaningInput(m))
	}

	return word.UpdateWordInput{
		Text:          input.Text,
		Transcription: input.Transcription,
		AudioURL:      input.AudioURL,
		Meanings:      meanings,
	}
}

// ToUpdateMeaningInput конвертирует GraphQL MeaningInput в service update input.
func ToUpdateMeaningInput(input *MeaningInput) word.UpdateMeaningInput {
	if input == nil {
		return word.UpdateMeaningInput{}
	}

	examples := make([]word.CreateExampleInput, 0, len(input.Examples))
	for _, e := range input.Examples {
		examples = append(examples, ToCreateExampleInput(e))
	}

	return word.UpdateMeaningInput{
		PartOfSpeech:  FromGraphQLPartOfSpeech(input.PartOfSpeech),
		DefinitionEn:  input.DefinitionEn,
		TranslationRu: input.TranslationRu,
		ImageURL:      input.ImageURL,
		Examples:      examples,
		Tags:          input.Tags,
	}
}

// ToWordFilter конвертирует GraphQL WordFilter в service filter.
func ToWordFilter(filter *WordFilter) *word.WordFilter {
	if filter == nil {
		return nil
	}
	return &word.WordFilter{
		Search: filter.Search,
	}
}

// --- WordWithRelations Conversion ---

// WordWithRelationsToGraphQL конвертирует WordWithRelations в GraphQL Word.
func WordWithRelationsToGraphQL(wr *word.WordWithRelations) *Word {
	if wr == nil {
		return nil
	}

	meanings := make([]*Meaning, 0, len(wr.Meanings))
	for _, mr := range wr.Meanings {
		meanings = append(meanings, MeaningWithRelationsToGraphQL(&mr))
	}

	return ToGraphQLWord(&wr.Word, meanings)
}

// MeaningWithRelationsToGraphQL конвертирует MeaningWithRelations в GraphQL Meaning.
func MeaningWithRelationsToGraphQL(mr *word.MeaningWithRelations) *Meaning {
	if mr == nil {
		return nil
	}

	examples := make([]*model.Example, len(mr.Examples))
	for i := range mr.Examples {
		examples[i] = &mr.Examples[i]
	}
	tags := make([]*model.Tag, len(mr.Tags))
	for i := range mr.Tags {
		tags[i] = &mr.Tags[i]
	}

	return ToGraphQLMeaning(
		&mr.Meaning,
		ToGraphQLExamples(examples),
		ToGraphQLTags(tags),
	)
}

// ToGraphQLMeaningBasic конвертирует domain Meaning в GraphQL Meaning без examples и tags.
// Используется с field resolvers, которые загружают relations через DataLoader.
func ToGraphQLMeaningBasic(m *model.Meaning) *Meaning {
	if m == nil {
		return nil
	}

	reviewCount := 0
	if m.ReviewCount != nil {
		reviewCount = *m.ReviewCount
	}

	var nextReviewAt *Time
	if m.NextReviewAt != nil {
		t := Time(*m.NextReviewAt)
		nextReviewAt = &t
	}

	return &Meaning{
		ID:            ToGraphQLID(m.ID),
		WordID:        ToGraphQLID(m.WordID),
		PartOfSpeech:  ToGraphQLPartOfSpeech(m.PartOfSpeech),
		DefinitionEn:  m.DefinitionEn,
		TranslationRu: m.TranslationRu,
		CefrLevel:     m.CefrLevel,
		ImageURL:      m.ImageURL,
		Status:        ToGraphQLLearningStatus(m.LearningStatus),
		NextReviewAt:  nextReviewAt,
		ReviewCount:   reviewCount,
		// Examples и Tags загрузятся через field resolvers
	}
}

// ToGraphQLWordBasic конвертирует domain Word в GraphQL Word без meanings.
// Используется с field resolvers, которые загружают meanings через DataLoader.
func ToGraphQLWordBasic(w *model.Word) *Word {
	if w == nil {
		return nil
	}
	return &Word{
		ID:            ToGraphQLID(w.ID),
		Text:          w.Text,
		Transcription: w.Transcription,
		AudioURL:      w.AudioURL,
		FrequencyRank: w.FrequencyRank,
		// Meanings загрузятся через field resolver
	}
}


================================================================================

================================================================================
Файл: graph/dataloader.go
Полный путь: /home/alodi/playground/my-english/backend/graph/dataloader.go
================================================================================

package graph

import (
	"context"
	"net/http"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/vikstrous/dataloadgen"
)

// ctxKey — ключ для хранения loaders в context.
type ctxKey string

const loadersKey ctxKey = "dataloaders"

// Loaders содержит все DataLoaders.
type Loaders struct {
	ExamplesByMeaningID *dataloadgen.Loader[int64, *[]*model.Example]
	TagsByMeaningID     *dataloadgen.Loader[int64, *[]*model.Tag]
	MeaningsByWordID    *dataloadgen.Loader[int64, *[]*model.Meaning]
}

// LoaderService определяет интерфейс для batch-загрузки данных.
// Реализуется сервисом loader.Service.
type LoaderService interface {
	GetMeaningsByWordIDs(ctx context.Context, wordIDs []int64) ([]model.Meaning, error)
	GetExamplesByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error)
	GetTagsByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error)
	GetTagsByIDs(ctx context.Context, ids []int64) ([]model.Tag, error)
}

// LoaderDeps — зависимости для DataLoaders.
type LoaderDeps struct {
	Loader LoaderService
}

// NewLoaders создаёт новые DataLoaders.
func NewLoaders(deps LoaderDeps) *Loaders {
	return &Loaders{
		ExamplesByMeaningID: dataloadgen.NewLoader(
			newExampleBatchFunc(deps.Loader),
			dataloadgen.WithWait(2*time.Millisecond),
		),
		TagsByMeaningID: dataloadgen.NewLoader(
			newTagBatchFunc(deps.Loader),
			dataloadgen.WithWait(2*time.Millisecond),
		),
		MeaningsByWordID: dataloadgen.NewLoader(
			newMeaningBatchFunc(deps.Loader),
			dataloadgen.WithWait(2*time.Millisecond),
		),
	}
}

// newMeaningBatchFunc создаёт batch функцию для загрузки meanings.
func newMeaningBatchFunc(loader LoaderService) func(ctx context.Context, wordIDs []int64) ([]*[]*model.Meaning, []error) {
	return func(ctx context.Context, wordIDs []int64) ([]*[]*model.Meaning, []error) {
		meanings, err := loader.GetMeaningsByWordIDs(ctx, wordIDs)
		if err != nil {
			errs := make([]error, len(wordIDs))
			for i := range errs {
				errs[i] = err
			}
			return nil, errs
		}

		// Группируем по wordID
		grouped := make(map[int64][]*model.Meaning)
		for i := range meanings {
			m := &meanings[i]
			grouped[m.WordID] = append(grouped[m.WordID], m)
		}

		// Формируем результат
		result := make([]*[]*model.Meaning, len(wordIDs))
		for i, id := range wordIDs {
			ms := grouped[id]
			if ms == nil {
				ms = make([]*model.Meaning, 0)
			}
			result[i] = &ms
		}

		return result, nil
	}
}

// newExampleBatchFunc создаёт batch функцию для загрузки examples.
func newExampleBatchFunc(loader LoaderService) func(ctx context.Context, meaningIDs []int64) ([]*[]*model.Example, []error) {
	return func(ctx context.Context, meaningIDs []int64) ([]*[]*model.Example, []error) {
		// Загружаем все examples одним запросом
		examples, err := loader.GetExamplesByMeaningIDs(ctx, meaningIDs)
		if err != nil {
			// Возвращаем ошибку для всех ключей
			errs := make([]error, len(meaningIDs))
			for i := range errs {
				errs[i] = err
			}
			return nil, errs
		}

		// Группируем по meaningID
		grouped := make(map[int64][]*model.Example)
		for i := range examples {
			ex := &examples[i]
			grouped[ex.MeaningID] = append(grouped[ex.MeaningID], ex)
		}

		// Формируем результат в том же порядке, что и входные ключи
		result := make([]*[]*model.Example, len(meaningIDs))
		for i, id := range meaningIDs {
			exs := grouped[id]
			if exs == nil {
				exs = make([]*model.Example, 0)
			}
			result[i] = &exs
		}

		return result, nil
	}
}

// newTagBatchFunc создаёт batch функцию для загрузки tags.
func newTagBatchFunc(loader LoaderService) func(ctx context.Context, meaningIDs []int64) ([]*[]*model.Tag, []error) {
	return func(ctx context.Context, meaningIDs []int64) ([]*[]*model.Tag, []error) {
		// Загружаем связи meaning-tag
		meaningTags, err := loader.GetTagsByMeaningIDs(ctx, meaningIDs)
		if err != nil {
			errs := make([]error, len(meaningIDs))
			for i := range errs {
				errs[i] = err
			}
			return nil, errs
		}

		// Собираем уникальные tagIDs
		tagIDSet := make(map[int64]struct{})
		for i := range meaningTags {
			tagIDSet[meaningTags[i].TagID] = struct{}{}
		}

		tagIDs := make([]int64, 0, len(tagIDSet))
		for id := range tagIDSet {
			tagIDs = append(tagIDs, id)
		}

		// Загружаем теги
		var tagMap map[int64]*model.Tag
		if len(tagIDs) > 0 {
			tags, err := loader.GetTagsByIDs(ctx, tagIDs)
			if err != nil {
				errs := make([]error, len(meaningIDs))
				for i := range errs {
					errs[i] = err
				}
				return nil, errs
			}

			tagMap = make(map[int64]*model.Tag, len(tags))
			for i := range tags {
				t := &tags[i]
				tagMap[t.ID] = t
			}
		} else {
			tagMap = make(map[int64]*model.Tag)
		}

		// Группируем теги по meaningID
		grouped := make(map[int64][]*model.Tag)
		for i := range meaningTags {
			mt := &meaningTags[i]
			if tag, ok := tagMap[mt.TagID]; ok {
				grouped[mt.MeaningID] = append(grouped[mt.MeaningID], tag)
			}
		}

		// Формируем результат
		result := make([]*[]*model.Tag, len(meaningIDs))
		for i, id := range meaningIDs {
			tags := grouped[id]
			if tags == nil {
				tags = make([]*model.Tag, 0)
			}
			result[i] = &tags
		}

		return result, nil
	}
}

// DataLoaderMiddleware добавляет DataLoaders в context для каждого запроса.
func DataLoaderMiddleware(deps LoaderDeps) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Создаём новые loaders для каждого запроса (важно для батчинга)
			loaders := NewLoaders(deps)
			ctx := context.WithValue(r.Context(), loadersKey, loaders)
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

// GetLoaders извлекает Loaders из context.
func GetLoaders(ctx context.Context) *Loaders {
	loaders, ok := ctx.Value(loadersKey).(*Loaders)
	if !ok {
		return nil
	}
	return loaders
}

// LoadExamplesForMeaning загружает examples для meaning через DataLoader.
func LoadExamplesForMeaning(ctx context.Context, meaningID int64) ([]*model.Example, error) {
	loaders := GetLoaders(ctx)
	if loaders == nil {
		return make([]*model.Example, 0), nil
	}
	examples, err := loaders.ExamplesByMeaningID.Load(ctx, meaningID)
	if err != nil {
		return nil, err
	}
	if examples == nil {
		return make([]*model.Example, 0), nil
	}
	return *examples, nil
}

// LoadTagsForMeaning загружает tags для meaning через DataLoader.
func LoadTagsForMeaning(ctx context.Context, meaningID int64) ([]*model.Tag, error) {
	loaders := GetLoaders(ctx)
	if loaders == nil {
		return make([]*model.Tag, 0), nil
	}
	tags, err := loaders.TagsByMeaningID.Load(ctx, meaningID)
	if err != nil {
		return nil, err
	}
	if tags == nil {
		return make([]*model.Tag, 0), nil
	}
	return *tags, nil
}

// LoadMeaningsForWord загружает meanings для word через DataLoader.
func LoadMeaningsForWord(ctx context.Context, wordID int64) ([]*model.Meaning, error) {
	loaders := GetLoaders(ctx)
	if loaders == nil {
		return make([]*model.Meaning, 0), nil
	}
	meanings, err := loaders.MeaningsByWordID.Load(ctx, wordID)
	if err != nil {
		return nil, err
	}
	if meanings == nil {
		return make([]*model.Meaning, 0), nil
	}
	return *meanings, nil
}


================================================================================

================================================================================
Файл: graph/handler.go
Полный путь: /home/alodi/playground/my-english/backend/graph/handler.go
================================================================================

package graph

import (
	"net/http"
	"time"

	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/99designs/gqlgen/graphql/handler/extension"
	"github.com/99designs/gqlgen/graphql/handler/lru"
	"github.com/99designs/gqlgen/graphql/handler/transport"
	"github.com/99designs/gqlgen/graphql/playground"
	"github.com/vektah/gqlparser/v2/ast"
)

// ServerConfig — конфигурация GraphQL сервера.
type ServerConfig struct {
	// EnablePlayground включает GraphQL Playground.
	EnablePlayground bool
	// EnableIntrospection включает introspection запросы.
	EnableIntrospection bool
	// QueryCacheSize — размер кэша для запросов.
	QueryCacheSize int
}

// DefaultServerConfig возвращает конфигурацию по умолчанию.
func DefaultServerConfig() ServerConfig {
	return ServerConfig{
		EnablePlayground:    true,
		EnableIntrospection: true,
		QueryCacheSize:      1000,
	}
}

// NewHandler создаёт HTTP handler для GraphQL.
func NewHandler(resolver *Resolver, cfg ServerConfig) http.Handler {
	srv := handler.New(NewExecutableSchema(Config{
		Resolvers: resolver,
	}))

	// Transports
	srv.AddTransport(transport.Options{})
	srv.AddTransport(transport.GET{})
	srv.AddTransport(transport.POST{})
	srv.AddTransport(transport.MultipartForm{})

	// Кэширование
	srv.SetQueryCache(lru.New[*ast.QueryDocument](cfg.QueryCacheSize))

	// Расширения
	if cfg.EnableIntrospection {
		srv.Use(extension.Introspection{})
	}
	srv.Use(extension.AutomaticPersistedQuery{
		Cache: lru.New[string](100),
	})

	return srv
}

// NewPlaygroundHandler создаёт handler для GraphQL Playground.
func NewPlaygroundHandler(endpoint string) http.Handler {
	return playground.Handler("GraphQL Playground", endpoint)
}

// Server — HTTP сервер для GraphQL.
type Server struct {
	graphqlHandler http.Handler
	config         ServerConfig
}

// NewServer создаёт новый GraphQL сервер.
func NewServer(resolver *Resolver, cfg ServerConfig) *Server {
	return &Server{
		graphqlHandler: NewHandler(resolver, cfg),
		config:         cfg,
	}
}

// Handler возвращает HTTP handler для GraphQL.
func (s *Server) Handler() http.Handler {
	return s.graphqlHandler
}

// Routes регистрирует маршруты на mux.
func (s *Server) Routes(mux *http.ServeMux, path string) {
	mux.Handle(path, s.graphqlHandler)

	if s.config.EnablePlayground {
		mux.Handle("/playground", NewPlaygroundHandler(path))
	}
}

// --- Middleware ---

// CORSMiddleware добавляет CORS заголовки.
func CORSMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// RecoveryMiddleware обрабатывает паники.
func RecoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				// TODO: добавить логирование
				http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			}
		}()
		next.ServeHTTP(w, r)
	})
}

// LoggingMiddleware логирует HTTP запросы.
func LoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Wrap response writer to capture status code
		wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		next.ServeHTTP(wrapped, r)

		// TODO: заменить на структурированный логгер
		_ = time.Since(start)
	})
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}


================================================================================

================================================================================
Файл: graph/helpers.go
Полный путь: /home/alodi/playground/my-english/backend/graph/helpers.go
================================================================================

package graph

// ptrToInt безопасно разыменовывает указатель на int.
func ptrToInt(p *int) int {
	if p == nil {
		return 0
	}
	return *p
}


================================================================================

================================================================================
Файл: graph/models_gen.go
Полный путь: /home/alodi/playground/my-english/backend/graph/models_gen.go
================================================================================

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AddWordInput struct {
	Text          string          `json:"text"`
	Transcription *string         `json:"transcription,omitempty"`
	AudioURL      *string         `json:"audioUrl,omitempty"`
	Meanings      []*MeaningInput `json:"meanings"`
}

type DashboardStats struct {
	TotalWords        int `json:"totalWords"`
	MasteredCount     int `json:"masteredCount"`
	LearningCount     int `json:"learningCount"`
	DueForReviewCount int `json:"dueForReviewCount"`
}

type Example struct {
	ID         string         `json:"id"`
	SentenceEn string         `json:"sentenceEn"`
	SentenceRu *string        `json:"sentenceRu,omitempty"`
	SourceName *ExampleSource `json:"sourceName,omitempty"`
}

type ExampleInput struct {
	SentenceEn string  `json:"sentenceEn"`
	SentenceRu *string `json:"sentenceRu,omitempty"`
	SourceName *string `json:"sourceName,omitempty"`
}

type Meaning struct {
	ID            string         `json:"id"`
	WordID        string         `json:"wordId"`
	PartOfSpeech  PartOfSpeech   `json:"partOfSpeech"`
	DefinitionEn  *string        `json:"definitionEn,omitempty"`
	TranslationRu string         `json:"translationRu"`
	CefrLevel     *string        `json:"cefrLevel,omitempty"`
	ImageURL      *string        `json:"imageUrl,omitempty"`
	Status        LearningStatus `json:"status"`
	NextReviewAt  *Time          `json:"nextReviewAt,omitempty"`
	ReviewCount   int            `json:"reviewCount"`
	Examples      []*Example     `json:"examples"`
	Tags          []*Tag         `json:"tags"`
}

type MeaningInput struct {
	PartOfSpeech  PartOfSpeech    `json:"partOfSpeech"`
	DefinitionEn  *string         `json:"definitionEn,omitempty"`
	TranslationRu string          `json:"translationRu"`
	ImageURL      *string         `json:"imageUrl,omitempty"`
	Examples      []*ExampleInput `json:"examples,omitempty"`
	Tags          []string        `json:"tags,omitempty"`
}

type Mutation struct {
}

type Query struct {
}

type Tag struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type Word struct {
	ID            string     `json:"id"`
	Text          string     `json:"text"`
	Transcription *string    `json:"transcription,omitempty"`
	AudioURL      *string    `json:"audioUrl,omitempty"`
	FrequencyRank *int       `json:"frequencyRank,omitempty"`
	Meanings      []*Meaning `json:"meanings"`
}

type WordFilter struct {
	Search *string         `json:"search,omitempty"`
	Status *LearningStatus `json:"status,omitempty"`
	Tags   []string        `json:"tags,omitempty"`
}

type ExampleSource string

const (
	ExampleSourceFilm    ExampleSource = "FILM"
	ExampleSourceBook    ExampleSource = "BOOK"
	ExampleSourceChat    ExampleSource = "CHAT"
	ExampleSourceVideo   ExampleSource = "VIDEO"
	ExampleSourcePodcast ExampleSource = "PODCAST"
)

var AllExampleSource = []ExampleSource{
	ExampleSourceFilm,
	ExampleSourceBook,
	ExampleSourceChat,
	ExampleSourceVideo,
	ExampleSourcePodcast,
}

func (e ExampleSource) IsValid() bool {
	switch e {
	case ExampleSourceFilm, ExampleSourceBook, ExampleSourceChat, ExampleSourceVideo, ExampleSourcePodcast:
		return true
	}
	return false
}

func (e ExampleSource) String() string {
	return string(e)
}

func (e *ExampleSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExampleSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExampleSource", str)
	}
	return nil
}

func (e ExampleSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExampleSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExampleSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LearningStatus string

const (
	LearningStatusNew      LearningStatus = "NEW"
	LearningStatusLearning LearningStatus = "LEARNING"
	LearningStatusReview   LearningStatus = "REVIEW"
	LearningStatusMastered LearningStatus = "MASTERED"
)

var AllLearningStatus = []LearningStatus{
	LearningStatusNew,
	LearningStatusLearning,
	LearningStatusReview,
	LearningStatusMastered,
}

func (e LearningStatus) IsValid() bool {
	switch e {
	case LearningStatusNew, LearningStatusLearning, LearningStatusReview, LearningStatusMastered:
		return true
	}
	return false
}

func (e LearningStatus) String() string {
	return string(e)
}

func (e *LearningStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LearningStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LearningStatus", str)
	}
	return nil
}

func (e LearningStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LearningStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LearningStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PartOfSpeech string

const (
	PartOfSpeechNoun      PartOfSpeech = "NOUN"
	PartOfSpeechVerb      PartOfSpeech = "VERB"
	PartOfSpeechAdjective PartOfSpeech = "ADJECTIVE"
	PartOfSpeechAdverb    PartOfSpeech = "ADVERB"
	PartOfSpeechOther     PartOfSpeech = "OTHER"
)

var AllPartOfSpeech = []PartOfSpeech{
	PartOfSpeechNoun,
	PartOfSpeechVerb,
	PartOfSpeechAdjective,
	PartOfSpeechAdverb,
	PartOfSpeechOther,
}

func (e PartOfSpeech) IsValid() bool {
	switch e {
	case PartOfSpeechNoun, PartOfSpeechVerb, PartOfSpeechAdjective, PartOfSpeechAdverb, PartOfSpeechOther:
		return true
	}
	return false
}

func (e PartOfSpeech) String() string {
	return string(e)
}

func (e *PartOfSpeech) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PartOfSpeech(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PartOfSpeech", str)
	}
	return nil
}

func (e PartOfSpeech) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PartOfSpeech) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PartOfSpeech) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}


================================================================================

================================================================================
Файл: graph/resolver.go
Полный путь: /home/alodi/playground/my-english/backend/graph/resolver.go
================================================================================

package graph

import (
	"context"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/word"
)

//go:generate go run github.com/99designs/gqlgen generate

// WordService определяет интерфейс для работы со словами.
type WordService interface {
	Create(ctx context.Context, input word.CreateWordInput) (*word.WordWithRelations, error)
	GetByID(ctx context.Context, id int64) (*word.WordWithRelations, error)
	GetByText(ctx context.Context, text string) (*word.WordWithRelations, error)
	List(ctx context.Context, filter *word.WordFilter, limit, offset int) ([]model.Word, error)
	Count(ctx context.Context, filter *word.WordFilter) (int, error)
	Update(ctx context.Context, id int64, input word.UpdateWordInput) (*word.WordWithRelations, error)
	Delete(ctx context.Context, id int64) error
}

// StudyService определяет интерфейс для системы изучения.
type StudyService interface {
	GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error)
	GetStats(ctx context.Context) (*model.Stats, error)
	ReviewMeaning(ctx context.Context, meaningID int64, grade int) (model.Meaning, error)
}

// Deps — зависимости для резолвера.
// Resolver использует только сервисы, не репозитории.
type Deps struct {
	Words WordService
	Study StudyService
}

// Resolver — корневой резолвер GraphQL.
// Использует только сервисы. DataLoaders инжектируются через middleware.
type Resolver struct {
	words WordService
	study StudyService
}

// NewResolver создаёт новый резолвер с зависимостями.
func NewResolver(deps Deps) *Resolver {
	return &Resolver{
		words: deps.Words,
		study: deps.Study,
	}
}


================================================================================

================================================================================
Файл: graph/scalars.go
Полный путь: /home/alodi/playground/my-english/backend/graph/scalars.go
================================================================================

package graph

import (
	"io"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Time is a custom scalar type for GraphQL Time
type Time time.Time

// MarshalGQL implements the graphql.Marshaler interface
func (t Time) MarshalGQL(w io.Writer) {
	w.Write([]byte(`"` + time.Time(t).Format(time.RFC3339) + `"`))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface
func (t *Time) UnmarshalGQL(v interface{}) error {
	if str, ok := v.(string); ok {
		parsed, err := time.Parse(time.RFC3339, str)
		if err != nil {
			return err
		}
		*t = Time(parsed)
		return nil
	}
	return nil
}

// MarshalTime serializes a Time to graphql.Marshaler
func MarshalTime(t Time) graphql.Marshaler {
	return t
}

// UnmarshalTime deserializes a string to a Time
func UnmarshalTime(v interface{}) (Time, error) {
	if str, ok := v.(string); ok {
		t, err := time.Parse(time.RFC3339, str)
		if err != nil {
			return Time{}, err
		}
		return Time(t), nil
	}
	return Time{}, nil
}


================================================================================

================================================================================
Файл: graph/schema.graphqls
Полный путь: /home/alodi/playground/my-english/backend/graph/schema.graphqls
================================================================================

scalar Time

# ---------------------------------------------------
# ENUMS (Совпадают с базой данных)
# ---------------------------------------------------

enum LearningStatus {
  NEW
  LEARNING
  REVIEW
  MASTERED
}

enum PartOfSpeech {
  NOUN
  VERB
  ADJECTIVE
  ADVERB
  OTHER
}

enum ExampleSource {
  FILM
  BOOK
  CHAT
  VIDEO
  PODCAST
}

# ---------------------------------------------------
# TYPES (То, что отдаем на фронт)
# ---------------------------------------------------

type Word {
  id: ID!
  text: String!
  transcription: String
  audioUrl: String
  frequencyRank: Int
  meanings: [Meaning!]!
}

type Meaning {
  id: ID!
  wordId: ID!
  partOfSpeech: PartOfSpeech!
  definitionEn: String
  translationRu: String!
  cefrLevel: String
  imageUrl: String
  
  status: LearningStatus!
  nextReviewAt: Time
  reviewCount: Int!
  
  examples: [Example!]!
  tags: [Tag!]!
}

type Example {
  id: ID!
  sentenceEn: String!
  sentenceRu: String
  sourceName: ExampleSource
}

type Tag {
  id: ID!
  name: String!
}

type DashboardStats {
  totalWords: Int!
  masteredCount: Int!
  learningCount: Int!
  dueForReviewCount: Int! 
}

# ---------------------------------------------------
# INPUTS (То, что принимаем с фронта)
# ---------------------------------------------------

input WordFilter {
  search: String          # Поиск по тексту (LIKE %...%)
  status: LearningStatus  # Фильтр по статусу (например, показать только New)
  tags: [String!]         # Фильтр по тегам
}

# Input для создания нового слова (Complex Mutation)
# Мы принимаем сразу и слово, и его смысл, и примеры
input AddWordInput {
  text: String!
  transcription: String
  audioUrl: String
  meanings: [MeaningInput!]!
}

input MeaningInput {
  partOfSpeech: PartOfSpeech!
  definitionEn: String
  translationRu: String!
  imageUrl: String
  examples: [ExampleInput!]
  tags: [String!]
}

input ExampleInput {
  sentenceEn: String!
  sentenceRu: String
  sourceName: String
}

# ---------------------------------------------------
# OPERATIONS
# ---------------------------------------------------

type Query {
  # Основной список слов (словарь) с пагинацией
  words(filter: WordFilter, limit: Int = 20, offset: Int = 0): [Word!]!
  
  # Детальный просмотр одного слова
  word(id: ID!): Word
  
  # Режим "Учить/Повторять". Возвращает список значений (Meanings),
  # у которых nextReviewAt < NOW или status = NEW.
  studyQueue(limit: Int = 10): [Meaning!]!
  
  # Дашборд
  stats: DashboardStats!
}

type Mutation {
  # Добавление нового слова со всеми потрохами
  createWord(input: AddWordInput!): Word!
  
  # Обновление слова (исправление опечаток)
  updateWord(id: ID!, input: AddWordInput!): Word!
  
  # Самая важная мутация для прогресса.
  # Пользователь оценил, как хорошо он помнит слово.
  # grade: Оценка от 1 (не помню) до 5 (отлично помню).
  # Бэкенд сам пересчитает nextReviewAt и status.
  reviewMeaning(meaningId: ID!, grade: Int!): Meaning!
  
  # Удаление (например, если добавил по ошибке)
  deleteWord(id: ID!): Boolean!
}

================================================================================

================================================================================
Файл: graph/schema.resolvers.go
Полный путь: /home/alodi/playground/my-english/backend/graph/schema.resolvers.go
================================================================================

package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/transport"
)

// Examples is the resolver for the examples field.
func (r *meaningResolver) Examples(ctx context.Context, obj *Meaning) ([]*Example, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	examples, err := LoadExamplesForMeaning(ctx, meaningID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return ToGraphQLExamples(examples), nil
}

// Tags is the resolver for the tags field.
func (r *meaningResolver) Tags(ctx context.Context, obj *Meaning) ([]*Tag, error) {
	meaningID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	tags, err := LoadTagsForMeaning(ctx, meaningID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return ToGraphQLTags(tags), nil
}

// CreateWord is the resolver for the createWord field.
func (r *mutationResolver) CreateWord(ctx context.Context, input AddWordInput) (*Word, error) {
	result, err := r.words.Create(ctx, ToCreateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return WordWithRelationsToGraphQL(result), nil
}

// UpdateWord is the resolver for the updateWord field.
func (r *mutationResolver) UpdateWord(ctx context.Context, id string, input AddWordInput) (*Word, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	result, err := r.words.Update(ctx, wordID, ToUpdateWordInput(input))
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return WordWithRelationsToGraphQL(result), nil
}

// ReviewMeaning is the resolver for the reviewMeaning field.
func (r *mutationResolver) ReviewMeaning(ctx context.Context, meaningID string, grade int) (*Meaning, error) {
	mID, err := FromGraphQLID(meaningID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid meaning ID", transport.CodeInvalidInput)
	}

	meaning, err := r.study.ReviewMeaning(ctx, mID, grade)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers
	return ToGraphQLMeaningBasic(&meaning), nil
}

// DeleteWord is the resolver for the deleteWord field.
func (r *mutationResolver) DeleteWord(ctx context.Context, id string) (bool, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return false, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	if err := r.words.Delete(ctx, wordID); err != nil {
		return false, transport.HandleError(ctx, err)
	}
	return true, nil
}

// Words is the resolver for the words field.
func (r *queryResolver) Words(ctx context.Context, filter *WordFilter, limit *int, offset *int) ([]*Word, error) {
	l, o := database.NormalizePagination(ptrToInt(limit), ptrToInt(offset))

	words, err := r.words.List(ctx, ToWordFilter(filter), l, o)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Используем ToGraphQLWordBasic — meanings загрузятся через field resolver
	result := make([]*Word, 0, len(words))
	for i := range words {
		result = append(result, ToGraphQLWordBasic(&words[i]))
	}

	return result, nil
}

// Word is the resolver for the word field.
func (r *queryResolver) Word(ctx context.Context, id string) (*Word, error) {
	wordID, err := FromGraphQLID(id)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	wordWithRelations, err := r.words.GetByID(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	return WordWithRelationsToGraphQL(wordWithRelations), nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, limit *int) ([]*Meaning, error) {
	l := database.NormalizeLimit(ptrToInt(limit), database.DefaultSRSLimit)

	meanings, err := r.study.GetStudyQueue(ctx, l)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Examples и Tags загрузятся через field resolvers с DataLoader
	result := make([]*Meaning, 0, len(meanings))
	for i := range meanings {
		result = append(result, ToGraphQLMeaningBasic(&meanings[i]))
	}

	return result, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*DashboardStats, error) {
	stats, err := r.study.GetStats(ctx)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}
	return ToGraphQLStats(stats), nil
}

// Meanings is the resolver for the meanings field.
func (r *wordResolver) Meanings(ctx context.Context, obj *Word) ([]*Meaning, error) {
	wordID, err := FromGraphQLID(obj.ID)
	if err != nil {
		return nil, transport.NewGraphQLError(ctx, "Invalid word ID", transport.CodeInvalidInput)
	}

	meanings, err := LoadMeaningsForWord(ctx, wordID)
	if err != nil {
		return nil, transport.HandleError(ctx, err)
	}

	// Конвертируем в GraphQL тип (без examples и tags — они загрузятся через field resolvers)
	result := make([]*Meaning, 0, len(meanings))
	for _, m := range meanings {
		result = append(result, ToGraphQLMeaningBasic(m))
	}

	return result, nil
}

// Meaning returns MeaningResolver implementation.
func (r *Resolver) Meaning() MeaningResolver { return &meaningResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Word returns WordResolver implementation.
func (r *Resolver) Word() WordResolver { return &wordResolver{r} }

type meaningResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type wordResolver struct{ *Resolver }


================================================================================

================================================================================
Файл: internal/app/adapters.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/adapters.go
================================================================================

package app

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/service/study"
)

// --- SRS Adapter ---

// SRSAdapter адаптирует meaning.Repo для study.MeaningSRSRepository.
type SRSAdapter struct {
	repo *meaning.Repo
}

// NewSRSAdapter создаёт адаптер.
func NewSRSAdapter(repo *meaning.Repo) *SRSAdapter {
	return &SRSAdapter{repo: repo}
}

// UpdateSRS реализует study.MeaningSRSRepository.
func (a *SRSAdapter) UpdateSRS(ctx context.Context, id int64, srs *study.SRSUpdate) error {
	// Конвертируем study.SRSUpdate в meaning.SRSUpdate
	meaningUpdate := &meaning.SRSUpdate{
		LearningStatus: srs.LearningStatus,
		NextReviewAt:   srs.NextReviewAt,
		Interval:       srs.Interval,
		EaseFactor:     srs.EaseFactor,
		ReviewCount:    srs.ReviewCount,
	}
	return a.repo.UpdateSRS(ctx, id, meaningUpdate)
}


================================================================================

================================================================================
Файл: internal/app/app.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/app.go
================================================================================

package app

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/heartmarshall/my-english/graph"
	"github.com/jackc/pgx/v5/pgxpool"
)

// App — главная структура приложения.
type App struct {
	config Config
	logger *slog.Logger
	deps   *Dependencies
	server *http.Server
}

// New создаёт новое приложение.
func New(cfg Config) (*App, error) {
	// Инициализация логгера
	logger := NewLogger(cfg.Log)
	slog.SetDefault(logger)

	// Подключение к базе данных
	pool, err := connectDB(cfg.Database, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Инициализация зависимостей
	deps := NewDependencies(pool)

	// HTTP сервер
	server := newHTTPServer(cfg, deps, logger)

	return &App{
		config: cfg,
		logger: logger,
		deps:   deps,
		server: server,
	}, nil
}

// Run запускает приложение и ожидает сигнала завершения.
func (a *App) Run() error {
	// Канал для ошибок сервера
	errChan := make(chan error, 1)

	// Запуск сервера в горутине
	go func() {
		a.logger.Info("starting server",
			slog.String("addr", a.config.Server.Addr()),
			slog.String("graphql", fmt.Sprintf("http://%s/graphql", a.config.Server.Addr())),
		)
		if a.config.GraphQL.EnablePlayground {
			a.logger.Info("playground enabled",
				slog.String("url", fmt.Sprintf("http://%s/playground", a.config.Server.Addr())),
			)
		}

		if err := a.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			errChan <- err
		}
	}()

	// Ожидание сигнала завершения
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	select {
	case err := <-errChan:
		return fmt.Errorf("server error: %w", err)
	case sig := <-quit:
		a.logger.Info("received shutdown signal", slog.String("signal", sig.String()))
	}

	return a.Shutdown()
}

// Shutdown gracefully завершает приложение.
func (a *App) Shutdown() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Остановка HTTP сервера
	if err := a.server.Shutdown(ctx); err != nil {
		return fmt.Errorf("failed to shutdown server: %w", err)
	}

	// Закрытие соединения с БД
	a.deps.DB.Close()

	a.logger.Info("application stopped gracefully")
	return nil
}

// connectDB устанавливает соединение с базой данных через pgxpool.
func connectDB(cfg DatabaseConfig, logger *slog.Logger) (*pgxpool.Pool, error) {
	config, err := pgxpool.ParseConfig(cfg.DSN())
	if err != nil {
		return nil, fmt.Errorf("failed to parse database config: %w", err)
	}

	// Настройка пула соединений
	config.MaxConns = int32(cfg.MaxOpenConns)
	config.MinConns = int32(cfg.MaxIdleConns)
	config.MaxConnLifetime = cfg.ConnMaxLifetime

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection pool: %w", err)
	}

	// Проверка соединения
	if err := pool.Ping(context.Background()); err != nil {
		pool.Close()
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	logger.Info("connected to database",
		slog.String("host", cfg.Host),
		slog.Int("port", cfg.Port),
		slog.String("database", cfg.Database),
		slog.Int("max_conns", cfg.MaxOpenConns),
	)
	return pool, nil
}

// newHTTPServer создаёт HTTP сервер.
func newHTTPServer(cfg Config, deps *Dependencies, logger *slog.Logger) *http.Server {
	mux := http.NewServeMux()

	// GraphQL handler
	graphqlServer := graph.NewServer(deps.Resolver, graph.ServerConfig{
		EnablePlayground:    cfg.GraphQL.EnablePlayground,
		EnableIntrospection: cfg.GraphQL.EnableIntrospection,
		QueryCacheSize:      cfg.GraphQL.QueryCacheSize,
	})
	graphqlServer.Routes(mux, "/graphql")

	// Health checks
	healthChecker := NewHealthChecker(deps.DB)
	mux.HandleFunc("/health", healthChecker.Handler())
	mux.HandleFunc("/live", healthChecker.LivenessHandler())
	mux.HandleFunc("/ready", healthChecker.ReadinessHandler())

	// DataLoader dependencies — использует сервис, не репозитории
	loaderDeps := graph.LoaderDeps{
		Loader: deps.Services.Loader,
	}

	// Middleware chain (порядок: снаружи → внутрь)
	// Recovery → Logging → Timeout → DataLoader → CORS → Handler
	handler := RecoveryMiddleware(logger)(
		LoggingMiddleware(logger)(
			TimeoutMiddleware(cfg.Server.RequestTimeout)(
				graph.DataLoaderMiddleware(loaderDeps)(
					graph.CORSMiddleware(mux),
				),
			),
		),
	)

	return &http.Server{
		Addr:         cfg.Server.Addr(),
		Handler:      handler,
		ReadTimeout:  cfg.Server.ReadTimeout,
		WriteTimeout: cfg.Server.WriteTimeout,
	}
}


================================================================================

================================================================================
Файл: internal/app/config.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/config.go
================================================================================

package app

import (
	"fmt"
	"os"
	"strconv"
	"time"
)

// Config — конфигурация приложения.
type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
	GraphQL  GraphQLConfig
	Log      LogConfig
}

// ServerConfig — конфигурация HTTP сервера.
type ServerConfig struct {
	Host           string
	Port           int
	ReadTimeout    time.Duration
	WriteTimeout   time.Duration
	RequestTimeout time.Duration // Таймаут на обработку запроса
}

// DatabaseConfig — конфигурация базы данных.
type DatabaseConfig struct {
	Host            string
	Port            int
	User            string
	Password        string
	Database        string
	SSLMode         string
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
}

// DSN возвращает строку подключения к PostgreSQL в формате URL для pgx.
func (c DatabaseConfig) DSN() string {
	return fmt.Sprintf(
		"postgres://%s:%s@%s:%d/%s?sslmode=%s",
		c.User, c.Password, c.Host, c.Port, c.Database, c.SSLMode,
	)
}

// GraphQLConfig — конфигурация GraphQL.
type GraphQLConfig struct {
	EnablePlayground    bool
	EnableIntrospection bool
	QueryCacheSize      int
}

// DefaultConfig возвращает конфигурацию по умолчанию.
func DefaultConfig() Config {
	return Config{
		Server: ServerConfig{
			Host:           "0.0.0.0",
			Port:           8080,
			ReadTimeout:    15 * time.Second,
			WriteTimeout:   15 * time.Second,
			RequestTimeout: 30 * time.Second,
		},
		Database: DatabaseConfig{
			Host:            "localhost",
			Port:            5432,
			User:            "postgres",
			Password:        "postgres",
			Database:        "my_english",
			SSLMode:         "disable",
			MaxOpenConns:    25,
			MaxIdleConns:    5,
			ConnMaxLifetime: 5 * time.Minute,
		},
		GraphQL: GraphQLConfig{
			EnablePlayground:    true,
			EnableIntrospection: true,
			QueryCacheSize:      1000,
		},
		Log: DefaultLogConfig(),
	}
}

// LoadFromEnv загружает конфигурацию из переменных окружения.
// Использует дефолтные значения, если переменная не установлена.
func LoadFromEnv() Config {
	cfg := DefaultConfig()

	// Server
	if host := os.Getenv("SERVER_HOST"); host != "" {
		cfg.Server.Host = host
	}
	if port := os.Getenv("SERVER_PORT"); port != "" {
		if p, err := strconv.Atoi(port); err == nil {
			cfg.Server.Port = p
		}
	}
	if timeout := os.Getenv("SERVER_REQUEST_TIMEOUT"); timeout != "" {
		if d, err := time.ParseDuration(timeout); err == nil {
			cfg.Server.RequestTimeout = d
		}
	}

	// Database
	if host := os.Getenv("DB_HOST"); host != "" {
		cfg.Database.Host = host
	}
	if port := os.Getenv("DB_PORT"); port != "" {
		if p, err := strconv.Atoi(port); err == nil {
			cfg.Database.Port = p
		}
	}
	if user := os.Getenv("DB_USER"); user != "" {
		cfg.Database.User = user
	}
	if pass := os.Getenv("DB_PASSWORD"); pass != "" {
		cfg.Database.Password = pass
	}
	if db := os.Getenv("DB_NAME"); db != "" {
		cfg.Database.Database = db
	}
	if ssl := os.Getenv("DB_SSLMODE"); ssl != "" {
		cfg.Database.SSLMode = ssl
	}

	// GraphQL
	if env := os.Getenv("GRAPHQL_PLAYGROUND"); env == "false" {
		cfg.GraphQL.EnablePlayground = false
	}
	if env := os.Getenv("GRAPHQL_INTROSPECTION"); env == "false" {
		cfg.GraphQL.EnableIntrospection = false
	}

	// Logging
	if level := os.Getenv("LOG_LEVEL"); level != "" {
		cfg.Log.Level = LogLevel(level)
	}
	if format := os.Getenv("LOG_FORMAT"); format != "" {
		cfg.Log.Format = format
	}

	return cfg
}

// Addr возвращает адрес сервера.
func (c ServerConfig) Addr() string {
	return fmt.Sprintf("%s:%d", c.Host, c.Port)
}


================================================================================

================================================================================
Файл: internal/app/deps.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/deps.go
================================================================================

package app

import (
	"context"

	"github.com/heartmarshall/my-english/graph"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/example"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/meaningtag"
	"github.com/heartmarshall/my-english/internal/database/tag"
	"github.com/heartmarshall/my-english/internal/database/word"
	"github.com/heartmarshall/my-english/internal/service/loader"
	"github.com/heartmarshall/my-english/internal/service/study"
	wordservice "github.com/heartmarshall/my-english/internal/service/word"
	"github.com/jackc/pgx/v5/pgxpool"
)

// TxRunner реализует интерфейс wordservice.TxRunner.
type TxRunner struct {
	txManager *database.TxManager
}

// NewTxRunner создаёт новый TxRunner.
func NewTxRunner(pool *pgxpool.Pool) *TxRunner {
	return &TxRunner{
		txManager: database.NewTxManager(pool),
	}
}

// RunInTx выполняет функцию в транзакции.
func (r *TxRunner) RunInTx(ctx context.Context, fn func(ctx context.Context, tx database.Querier) error) error {
	return r.txManager.RunInTx(ctx, fn)
}

// Compile-time check
var _ wordservice.TxRunner = (*TxRunner)(nil)

// Repositories содержит все репозитории.
type Repositories struct {
	Words      *word.Repo
	Meanings   *meaning.Repo
	Examples   *example.Repo
	Tags       *tag.Repo
	MeaningTag *meaningtag.Repo
}

// Services содержит все сервисы.
type Services struct {
	Words  *wordservice.Service
	Study  *study.Service
	Loader *loader.Service
}

// Dependencies содержит все зависимости приложения.
type Dependencies struct {
	DB           *pgxpool.Pool
	Repositories *Repositories
	Services     *Services
	Resolver     *graph.Resolver
}

// NewDependencies создаёт все зависимости приложения.
func NewDependencies(pool *pgxpool.Pool) *Dependencies {
	// Репозитории
	repos := newRepositories(pool)

	// TxRunner и RepositoryFactory
	txRunner := NewTxRunner(pool)
	repoFactory := NewRepositoryFactory()

	// Сервисы
	services := newServices(repos, txRunner, repoFactory)

	// GraphQL Resolver (использует только сервисы)
	resolver := newResolver(services)

	return &Dependencies{
		DB:           pool,
		Repositories: repos,
		Services:     services,
		Resolver:     resolver,
	}
}

func newRepositories(pool *pgxpool.Pool) *Repositories {
	return &Repositories{
		Words:      word.New(pool),
		Meanings:   meaning.New(pool, meaning.WithClock(database.RealClock{})),
		Examples:   example.New(pool),
		Tags:       tag.New(pool),
		MeaningTag: meaningtag.New(pool),
	}
}

func newServices(repos *Repositories, txRunner *TxRunner, repoFactory *RepositoryFactory) *Services {
	// Word Service
	wordSvc := wordservice.New(wordservice.Deps{
		Words:       repos.Words,
		Meanings:    repos.Meanings,
		Examples:    repos.Examples,
		Tags:        repos.Tags,
		MeaningTag:  repos.MeaningTag,
		TxRunner:    txRunner,
		RepoFactory: repoFactory,
	})

	// Study Service — используем SRS адаптер
	srsAdapter := NewSRSAdapter(repos.Meanings)
	studySvc := study.New(study.Deps{
		Meanings: repos.Meanings,
		SRS:      srsAdapter,
		Clock:    study.RealClock{},
	})

	// Loader Service для DataLoaders
	loaderSvc := loader.New(loader.Deps{
		Meanings:    repos.Meanings,
		Examples:    repos.Examples,
		Tags:        repos.Tags,
		MeaningTags: repos.MeaningTag,
	})

	return &Services{
		Words:  wordSvc,
		Study:  studySvc,
		Loader: loaderSvc,
	}
}

func newResolver(services *Services) *graph.Resolver {
	// Resolver использует только сервисы
	return graph.NewResolver(graph.Deps{
		Words: services.Words,
		Study: services.Study,
	})
}


================================================================================

================================================================================
Файл: internal/app/factory.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/factory.go
================================================================================

package app

import (
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/example"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/meaningtag"
	"github.com/heartmarshall/my-english/internal/database/tag"
	"github.com/heartmarshall/my-english/internal/database/word"
	wordservice "github.com/heartmarshall/my-english/internal/service/word"
)

// RepositoryFactory создаёт репозитории с указанным Querier.
type RepositoryFactory struct{}

// NewRepositoryFactory создаёт новую фабрику репозиториев.
func NewRepositoryFactory() *RepositoryFactory {
	return &RepositoryFactory{}
}

// Words создаёт репозиторий слов.
func (f *RepositoryFactory) Words(q database.Querier) wordservice.WordRepository {
	return word.New(q)
}

// Meanings создаёт репозиторий значений.
func (f *RepositoryFactory) Meanings(q database.Querier) wordservice.MeaningRepository {
	return meaning.New(q, meaning.WithClock(database.RealClock{}))
}

// Examples создаёт репозиторий примеров.
func (f *RepositoryFactory) Examples(q database.Querier) wordservice.ExampleRepository {
	return example.New(q)
}

// Tags создаёт репозиторий тегов.
func (f *RepositoryFactory) Tags(q database.Querier) wordservice.TagRepository {
	return tag.New(q)
}

// MeaningTags создаёт репозиторий связей meaning-tag.
func (f *RepositoryFactory) MeaningTags(q database.Querier) wordservice.MeaningTagRepository {
	return meaningtag.New(q)
}

// Compile-time check
var _ wordservice.RepositoryFactory = (*RepositoryFactory)(nil)


================================================================================

================================================================================
Файл: internal/app/health.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/health.go
================================================================================

package app

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
)

// HealthStatus — статус компонента.
type HealthStatus string

const (
	HealthStatusUp   HealthStatus = "up"
	HealthStatusDown HealthStatus = "down"
)

// HealthResponse — ответ health check endpoint.
type HealthResponse struct {
	Status     HealthStatus               `json:"status"`
	Components map[string]ComponentHealth `json:"components"`
	Timestamp  time.Time                  `json:"timestamp"`
}

// ComponentHealth — здоровье отдельного компонента.
type ComponentHealth struct {
	Status  HealthStatus `json:"status"`
	Latency string       `json:"latency,omitempty"`
	Error   string       `json:"error,omitempty"`
}

// HealthChecker проверяет здоровье приложения.
type HealthChecker struct {
	pool *pgxpool.Pool
}

// NewHealthChecker создаёт новый HealthChecker.
func NewHealthChecker(pool *pgxpool.Pool) *HealthChecker {
	return &HealthChecker{pool: pool}
}

// Handler возвращает HTTP handler для health check.
func (h *HealthChecker) Handler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
		defer cancel()

		response := h.Check(ctx)

		w.Header().Set("Content-Type", "application/json")

		if response.Status == HealthStatusDown {
			w.WriteHeader(http.StatusServiceUnavailable)
		} else {
			w.WriteHeader(http.StatusOK)
		}

		json.NewEncoder(w).Encode(response)
	}
}

// LivenessHandler — простой liveness probe (для Kubernetes).
func (h *HealthChecker) LivenessHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
	}
}

// ReadinessHandler — readiness probe с проверкой БД.
func (h *HealthChecker) ReadinessHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
		defer cancel()

		if err := h.pool.Ping(ctx); err != nil {
			w.WriteHeader(http.StatusServiceUnavailable)
			w.Write([]byte("NOT READY"))
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte("READY"))
	}
}

// Check выполняет полную проверку здоровья.
func (h *HealthChecker) Check(ctx context.Context) HealthResponse {
	components := make(map[string]ComponentHealth)

	// Проверка БД
	dbHealth := h.checkDatabase(ctx)
	components["database"] = dbHealth

	// Определяем общий статус
	overallStatus := HealthStatusUp
	for _, comp := range components {
		if comp.Status == HealthStatusDown {
			overallStatus = HealthStatusDown
			break
		}
	}

	return HealthResponse{
		Status:     overallStatus,
		Components: components,
		Timestamp:  time.Now().UTC(),
	}
}

// checkDatabase проверяет соединение с БД.
func (h *HealthChecker) checkDatabase(ctx context.Context) ComponentHealth {
	start := time.Now()

	err := h.pool.Ping(ctx)
	latency := time.Since(start)

	if err != nil {
		return ComponentHealth{
			Status:  HealthStatusDown,
			Latency: latency.String(),
			Error:   err.Error(),
		}
	}

	return ComponentHealth{
		Status:  HealthStatusUp,
		Latency: latency.String(),
	}
}


================================================================================

================================================================================
Файл: internal/app/logger.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/logger.go
================================================================================

package app

import (
	"context"
	"log/slog"
	"os"
)

// LogLevel определяет уровень логирования.
type LogLevel string

const (
	LogLevelDebug LogLevel = "debug"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
	LogLevelError LogLevel = "error"
)

// LogConfig — конфигурация логгера.
type LogConfig struct {
	Level  LogLevel
	Format string // "json" или "text"
}

// DefaultLogConfig возвращает конфигурацию по умолчанию.
func DefaultLogConfig() LogConfig {
	return LogConfig{
		Level:  LogLevelInfo,
		Format: "text",
	}
}

// NewLogger создаёт новый логгер.
func NewLogger(cfg LogConfig) *slog.Logger {
	var level slog.Level
	switch cfg.Level {
	case LogLevelDebug:
		level = slog.LevelDebug
	case LogLevelWarn:
		level = slog.LevelWarn
	case LogLevelError:
		level = slog.LevelError
	default:
		level = slog.LevelInfo
	}

	opts := &slog.HandlerOptions{
		Level: level,
	}

	var handler slog.Handler
	if cfg.Format == "json" {
		handler = slog.NewJSONHandler(os.Stdout, opts)
	} else {
		handler = slog.NewTextHandler(os.Stdout, opts)
	}

	return slog.New(handler)
}

// --- Context helpers ---

type ctxKey string

const loggerKey ctxKey = "logger"

// WithLogger добавляет логгер в контекст.
func WithLogger(ctx context.Context, logger *slog.Logger) context.Context {
	return context.WithValue(ctx, loggerKey, logger)
}

// LoggerFromContext извлекает логгер из контекста.
// Если логгер не найден, возвращает default логгер.
func LoggerFromContext(ctx context.Context) *slog.Logger {
	if logger, ok := ctx.Value(loggerKey).(*slog.Logger); ok {
		return logger
	}
	return slog.Default()
}

// L — короткий алиас для LoggerFromContext.
func L(ctx context.Context) *slog.Logger {
	return LoggerFromContext(ctx)
}


================================================================================

================================================================================
Файл: internal/app/middleware.go
Полный путь: /home/alodi/playground/my-english/backend/internal/app/middleware.go
================================================================================

package app

import (
	"context"
	"log/slog"
	"net/http"
	"time"
)

// LoggingMiddleware логирует HTTP запросы.
func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Wrap response writer to capture status code
			wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

			// Добавляем логгер в контекст
			ctx := WithLogger(r.Context(), logger)
			r = r.WithContext(ctx)

			next.ServeHTTP(wrapped, r)

			duration := time.Since(start)

			logger.Info("http request",
				slog.String("method", r.Method),
				slog.String("path", r.URL.Path),
				slog.Int("status", wrapped.statusCode),
				slog.Duration("duration", duration),
				slog.String("remote_addr", r.RemoteAddr),
			)
		})
	}
}

// RecoveryMiddleware обрабатывает паники.
func RecoveryMiddleware(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer func() {
				if err := recover(); err != nil {
					logger.Error("panic recovered",
						slog.Any("error", err),
						slog.String("path", r.URL.Path),
						slog.String("method", r.Method),
					)
					http.Error(w, "Internal Server Error", http.StatusInternalServerError)
				}
			}()
			next.ServeHTTP(w, r)
		})
	}
}

// TimeoutMiddleware добавляет таймаут к контексту запроса.
func TimeoutMiddleware(timeout time.Duration) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), timeout)
			defer cancel()

			// Канал для отслеживания завершения обработки
			done := make(chan struct{})

			go func() {
				next.ServeHTTP(w, r.WithContext(ctx))
				close(done)
			}()

			select {
			case <-done:
				// Запрос обработан успешно
			case <-ctx.Done():
				// Таймаут — возвращаем 503 если ещё не записали ответ
				if ctx.Err() == context.DeadlineExceeded {
					w.WriteHeader(http.StatusServiceUnavailable)
					w.Write([]byte(`{"error":"request timeout"}`))
				}
			}
		})
	}
}

type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}


================================================================================

================================================================================
Файл: internal/database/database.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/database.go
================================================================================

package database

import (
	"context"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/georgysavva/scany/v2/pgxscan"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Pagination defaults
const (
	DefaultLimit    = 20
	MaxLimit        = 100
	DefaultSRSLimit = 10
)

type Querier interface {
	Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error)
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

var (
	_ Querier = (*pgxpool.Pool)(nil)
	_ Querier = (pgx.Tx)(nil)
)

var Builder = squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)

type Clock interface {
	Now() time.Time
}

type RealClock struct{}

func (RealClock) Now() time.Time {
	return time.Now()
}

var DefaultClock Clock = RealClock{}

type TxFunc func(ctx context.Context, q Querier) error

func WithTx(ctx context.Context, pool *pgxpool.Pool, fn TxFunc) error {
	tx, err := pool.Begin(ctx)
	if err != nil {
		return err
	}

	defer func() {
		if p := recover(); p != nil {
			_ = tx.Rollback(ctx)
			panic(p)
		}
	}()

	if err := fn(ctx, tx); err != nil {
		_ = tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}

// --- Scany Helpers ---

// GetOne сканирует одну структуру.
func GetOne[T any](ctx context.Context, q Querier, sql string, args ...any) (*T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return nil, ErrNotFound
		}
		return nil, err
	}
	return &dest, nil
}

// Select сканирует список структур. Возвращает []*T.
func Select[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T // Слайс значений
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// GetScalar сканирует одно скалярное значение (int, string, bool).
func GetScalar[T any](ctx context.Context, q Querier, sql string, args ...any) (T, error) {
	var dest T
	err := pgxscan.Get(ctx, q, &dest, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return dest, nil
		}
		return dest, err
	}
	return dest, nil
}

// SelectScalars сканирует список скалярных значений (например, []int64).
func SelectScalars[T any](ctx context.Context, q Querier, sql string, args ...any) ([]T, error) {
	var dest []T
	err := pgxscan.Select(ctx, q, &dest, sql, args...)
	if err != nil {
		return nil, err
	}
	return dest, nil
}

// CheckExists проверяет наличие строки.
func CheckExists(ctx context.Context, q Querier, sql string, args ...any) (bool, error) {
	var dummy int
	err := pgxscan.Get(ctx, q, &dummy, sql, args...)
	if err != nil {
		if pgxscan.NotFound(err) {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

func NormalizePagination(limit, offset int) (int, int) {
	if limit <= 0 {
		limit = DefaultLimit
	}

	if limit > MaxLimit {
		limit = MaxLimit
	}
	if offset < 0 {
		offset = 0
	}
	return limit, offset
}

func NormalizeLimit(limit, defaultVal int) int {
	if limit <= 0 {
		limit = defaultVal
	}
	if limit > MaxLimit {
		limit = MaxLimit
	}
	return limit
}


================================================================================

================================================================================
Файл: internal/database/errors.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/errors.go
================================================================================

package database

import (
	"errors"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// Кастомные ошибки слоя данных.
// Позволяют бизнес-логике не зависеть от sql пакета.
var (
	// ErrNotFound возвращается, когда запись не найдена.
	ErrNotFound = errors.New("record not found")

	// ErrDuplicate возвращается при попытке создать дубликат
	// (нарушение UNIQUE constraint).
	ErrDuplicate = errors.New("record already exists")

	// ErrInvalidInput возвращается при невалидных входных данных.
	ErrInvalidInput = errors.New("invalid input")
)

// PostgreSQL error codes
// https://www.postgresql.org/docs/current/errcodes-appendix.html
const (
	// pgUniqueViolation — код ошибки нарушения уникальности в PostgreSQL.
	pgUniqueViolation = "23505"
)

// IsNotFoundError проверяет, является ли ошибка "запись не найдена".
func IsNotFoundError(err error) bool {
	return errors.Is(err, pgx.ErrNoRows)
}

// IsDuplicateError проверяет, является ли ошибка нарушением UNIQUE constraint.
// Работает с github.com/jackc/pgx/v5.
func IsDuplicateError(err error) bool {
	if err == nil {
		return false
	}

	// Проверка для pgx v5 через pgconn.PgError
	var pgErr *pgconn.PgError
	if errors.As(err, &pgErr) {
		return pgErr.Code == pgUniqueViolation
	}

	// Fallback: проверка по строке (для совместимости)
	errStr := err.Error()
	if strings.Contains(errStr, pgUniqueViolation) ||
		strings.Contains(errStr, "duplicate key value violates unique constraint") {
		return true
	}

	return false
}

// WrapDBError оборачивает ошибку базы данных в domain-specific ошибку.
func WrapDBError(err error) error {
	if err == nil {
		return nil
	}

	if IsDuplicateError(err) {
		return ErrDuplicate
	}

	return err
}


================================================================================

================================================================================
Файл: internal/database/example/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/read.go
================================================================================

package example

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает example по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (*model.Example, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.GetOne[model.Example](ctx, r.q, query, args...)
}

// GetByMeaningID возвращает все examples для указанного meaning.
func (r *Repo) GetByMeaningID(ctx context.Context, meaningID int64) ([]model.Example, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"meaning_id": meaningID}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Example](ctx, r.q, query, args...)
}

// GetByMeaningIDs возвращает examples для нескольких meanings (для batch loading).
func (r *Repo) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error) {
	if len(meaningIDs) == 0 {
		return make([]model.Example, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"meaning_id": meaningIDs}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Example](ctx, r.q, query, args...)
}


================================================================================

================================================================================
Файл: internal/database/example/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/repository.go
================================================================================

package example

import (
	"github.com/heartmarshall/my-english/internal/database"
)

const (
	tableName = "examples"
)

var columns = []string{
	"id",
	"meaning_id",
	"sentence_en",
	"sentence_ru",
	"source_name",
}

// Repo — реализация репозитория для работы с examples.
type Repo struct {
	q database.Querier
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repo {
	return &Repo{q: q}
}


================================================================================

================================================================================
Файл: internal/database/example/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/repository_test.go
================================================================================

package example_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/example"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var exampleColumns = []string{"id", "meaning_id", "sentence_en", "sentence_ru", "source_name"}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		src := model.ExampleSourceFilm
		ex := &model.Example{
			MeaningID:  1,
			SentenceEn: "Hello, world!",
			SentenceRu: ptr("Привет, мир!"),
			SourceName: &src,
		}

		mock.ExpectQuery(`INSERT INTO examples`).
			WithArgs(int64(1), "Hello, world!", "Привет, мир!", &src).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, ex)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ex.ID != 1 {
			t.Errorf("expected ID=1, got %d", ex.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil example", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing sentence", func(t *testing.T) {
		ex := &model.Example{MeaningID: 1}

		err := repo.Create(ctx, ex)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns).
			AddRow(1, 1, "Hello!", "Привет!", "film")

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		ex, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ex.SentenceEn != "Hello!" {
			t.Errorf("expected SentenceEn='Hello!', got %q", ex.SentenceEn)
		}
		if ex.SourceName == nil || *ex.SourceName != model.ExampleSourceFilm {
			t.Error("expected SourceName=film")
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns).
			AddRow(1, 1, "First", nil, nil).
			AddRow(2, 1, "Second", nil, "book")

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		examples, err := repo.GetByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(examples) != 2 {
			t.Errorf("expected 2 examples, got %d", len(examples))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows(exampleColumns)

		mock.ExpectQuery(`SELECT (.+) FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		examples, err := repo.GetByMeaningID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if examples == nil {
			t.Error("expected empty slice, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DeleteByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := example.New(q)
	ctx := context.Background()

	t.Run("deletes multiple", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM examples WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		count, err := repo.DeleteByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 3 {
			t.Errorf("expected count=3, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func ptr(s string) *string {
	return &s
}


================================================================================

================================================================================
Файл: internal/database/example/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/example/write.go
================================================================================

package example

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
)

// Create создаёт новый example.
func (r *Repo) Create(ctx context.Context, example *model.Example) error {
	if example == nil || example.MeaningID == 0 || example.SentenceEn == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Insert(tableName).
		Columns("meaning_id", "sentence_en", "sentence_ru", "source_name").
		Values(
			example.MeaningID,
			example.SentenceEn,
			example.SentenceRu,
			example.SourceName,
		).
		Suffix("RETURNING id").
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&example.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	return nil
}

// CreateBatch создаёт несколько examples за один запрос.
// Использует pgx.CollectRows для эффективного сбора ID.
func (r *Repo) CreateBatch(ctx context.Context, examples []*model.Example) error {
	if len(examples) == 0 {
		return nil
	}

	qb := database.Builder.
		Insert(tableName).
		Columns("meaning_id", "sentence_en", "sentence_ru", "source_name")

	for _, ex := range examples {
		if ex == nil || ex.MeaningID == 0 || ex.SentenceEn == "" {
			return database.ErrInvalidInput
		}
		qb = qb.Values(
			ex.MeaningID,
			ex.SentenceEn,
			ex.SentenceRu,
			ex.SourceName,
		)
	}

	qb = qb.Suffix("RETURNING id")

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}

	// Выполняем запрос
	rows, err := r.q.Query(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	// pgx.CollectRows автоматически закрывает rows и обрабатывает ошибки сканирования.
	// pgx.RowTo[int64] — эффективный маппер для одиночной колонки.
	ids, err := pgx.CollectRows(rows, pgx.RowTo[int64])
	if err != nil {
		return database.WrapDBError(err)
	}

	// Присваиваем полученные ID обратно в структуры
	// Порядок RETURNING в PostgreSQL соответствует порядку VALUES (для INSERT).
	for i, id := range ids {
		if i < len(examples) {
			examples[i].ID = id
		}
	}

	return nil
}

// Update обновляет example.
func (r *Repo) Update(ctx context.Context, example *model.Example) error {
	if example == nil || example.SentenceEn == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Update(tableName).
		Set("sentence_en", example.SentenceEn).
		Set("sentence_ru", example.SentenceRu).
		Set("source_name", example.SourceName).
		Where(squirrel.Eq{"id": example.ID}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}

// Delete удаляет example по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}

// DeleteByMeaningID удаляет все examples для указанного meaning.
func (r *Repo) DeleteByMeaningID(ctx context.Context, meaningID int64) (int64, error) {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"meaning_id": meaningID}).
		ToSql()
	if err != nil {
		return 0, err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return 0, database.WrapDBError(err)
	}

	return commandTag.RowsAffected(), nil
}


================================================================================

================================================================================
Файл: internal/database/meaning/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/read.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает meaning по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (model.Meaning, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return model.Meaning{}, err
	}

	meaning, err := database.GetOne[model.Meaning](ctx, r.q, query, args...)
	if err != nil {
		return model.Meaning{}, err
	}
	return *meaning, nil
}

// GetByWordID возвращает все meanings для указанного слова.
func (r *Repo) GetByWordID(ctx context.Context, wordID int64) ([]model.Meaning, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"word_id": wordID}).
		OrderBy("created_at ASC").
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetByWordIDs возвращает все meanings для нескольких слов (batch loading).
func (r *Repo) GetByWordIDs(ctx context.Context, wordIDs []int64) ([]model.Meaning, error) {
	if len(wordIDs) == 0 {
		return make([]model.Meaning, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"word_id": wordIDs}).
		OrderBy("word_id ASC", "created_at ASC").
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// List возвращает список meanings с фильтрацией и пагинацией.
func (r *Repo) List(ctx context.Context, filter *Filter, limit, offset int) ([]model.Meaning, error) {
	limit, offset = database.NormalizePagination(limit, offset)

	qb := database.Builder.
		Select(columns...).
		From(tableName)

	qb = applyFilter(qb, filter)

	qb = qb.
		OrderBy("created_at DESC").
		Limit(uint64(limit)).
		Offset(uint64(offset))

	query, args, err := qb.ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// Count возвращает количество meanings, соответствующих фильтру.
func (r *Repo) Count(ctx context.Context, filter *Filter) (int, error) {
	qb := database.Builder.Select("COUNT(*)").From(tableName)
	qb = applyFilter(qb, filter)

	query, args, err := qb.ToSql()
	if err != nil {
		return 0, err
	}

	return database.GetScalar[int](ctx, r.q, query, args...)
}

// Exists проверяет существование meaning по ID.
func (r *Repo) Exists(ctx context.Context, id int64) (bool, error) {
	query, args, err := database.Builder.
		Select("1").
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		Limit(1).
		ToSql()
	if err != nil {
		return false, err
	}

	return database.CheckExists(ctx, r.q, query, args...)
}

// applyFilter применяет фильтры к query builder.
func applyFilter(qb squirrel.SelectBuilder, filter *Filter) squirrel.SelectBuilder {
	if filter == nil {
		return qb
	}
	if filter.WordID != nil {
		qb = qb.Where(squirrel.Eq{"word_id": *filter.WordID})
	}
	if filter.PartOfSpeech != nil {
		qb = qb.Where(squirrel.Eq{"part_of_speech": *filter.PartOfSpeech})
	}
	if filter.LearningStatus != nil {
		qb = qb.Where(squirrel.Eq{"learning_status": *filter.LearningStatus})
	}
	return qb
}


================================================================================

================================================================================
Файл: internal/database/meaning/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/repository.go
================================================================================

package meaning

import (
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

const (
	tableName = "meanings"
)

var columns = []string{
	"id",
	"word_id",
	"part_of_speech",
	"definition_en",
	"translation_ru",
	"cefr_level",
	"image_url",
	"learning_status",
	"next_review_at",
	"interval",
	"ease_factor",
	"review_count",
	"created_at",
	"updated_at",
}

// Filter содержит параметры фильтрации для запросов поиска.
type Filter struct {
	WordID         *int64
	PartOfSpeech   *model.PartOfSpeech
	LearningStatus *model.LearningStatus
}

// SRSUpdate содержит поля для обновления SRS данных.
type SRSUpdate struct {
	LearningStatus model.LearningStatus
	NextReviewAt   *time.Time
	Interval       *int
	EaseFactor     *float64
	ReviewCount    *int
}

// Repo — реализация репозитория для работы с meanings.
type Repo struct {
	q     database.Querier
	clock database.Clock
}

// Option — функциональная опция для конфигурации Repo.
type Option func(*Repo)

// WithClock устанавливает объект clock для работы с временем.
func WithClock(c database.Clock) Option {
	return func(r *Repo) {
		r.clock = c
	}
}

// New создаёт новый репозиторий.
func New(q database.Querier, opts ...Option) *Repo {
	r := &Repo{
		q:     q,
		clock: database.DefaultClock,
	}

	for _, opt := range opts {
		opt(r)
	}

	return r
}


================================================================================

================================================================================
Файл: internal/database/meaning/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/repository_test.go
================================================================================

package meaning_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var meaningColumns = []string{
	"id", "word_id", "part_of_speech", "definition_en", "translation_ru",
	"cefr_level", "image_url", "learning_status", "next_review_at",
	"interval", "ease_factor", "review_count", "created_at", "updated_at",
}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		m := &model.Meaning{
			WordID:        1,
			PartOfSpeech:  model.PartOfSpeechNoun,
			TranslationRu: "привет",
			DefinitionEn:  ptr("a greeting"),
		}

		mock.ExpectQuery(`INSERT INTO meanings`).
			WithArgs(
				int64(1),                // word_id
				model.PartOfSpeechNoun,  // part_of_speech
				"a greeting",            // definition_en
				"привет",                // translation_ru
				nil,                     // cefr_level
				nil,                     // image_url
				model.LearningStatusNew, // learning_status (default)
				nil,                     // next_review_at
				nil,                     // interval
				nil,                     // ease_factor
				nil,                     // review_count
				clock.Now(),             // created_at
				clock.Now(),             // updated_at
			).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, m)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.ID != 1 {
			t.Errorf("expected ID=1, got %d", m.ID)
		}
		if m.LearningStatus != model.LearningStatusNew {
			t.Errorf("expected status=new, got %s", m.LearningStatus)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil meaning", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing word_id", func(t *testing.T) {
		m := &model.Meaning{TranslationRu: "тест"}

		err := repo.Create(ctx, m)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("missing translation", func(t *testing.T) {
		m := &model.Meaning{WordID: 1}

		err := repo.Create(ctx, m)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("default part_of_speech", func(t *testing.T) {
		m := &model.Meaning{
			WordID:        1,
			TranslationRu: "тест",
		}

		mock.ExpectQuery(`INSERT INTO meanings`).
			WithArgs(
				int64(1),
				model.PartOfSpeechOther, // default
				nil,
				"тест",
				nil, nil, model.LearningStatusNew, nil, nil, nil, nil,
				clock.Now(), clock.Now(),
			).
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, m)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.PartOfSpeech != model.PartOfSpeechOther {
			t.Errorf("expected part_of_speech=other, got %s", m.PartOfSpeech)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", "a greeting", "привет", "A1", nil, "new", nil, nil, 2.5, 0, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		m, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if m.ID != 1 {
			t.Errorf("expected ID=1, got %d", m.ID)
		}
		if m.TranslationRu != "привет" {
			t.Errorf("expected translation='привет', got %q", m.TranslationRu)
		}
		if m.PartOfSpeech != model.PartOfSpeechNoun {
			t.Errorf("expected part_of_speech=noun, got %s", m.PartOfSpeech)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByWordID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "привет", nil, nil, "new", nil, nil, nil, nil, now, now).
			AddRow(2, 1, "verb", nil, "приветствовать", nil, nil, "learning", nil, nil, nil, nil, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE word_id = \$1 ORDER BY created_at ASC`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		meanings, err := repo.GetByWordID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 2 {
			t.Errorf("expected 2 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows(meaningColumns)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		meanings, err := repo.GetByWordID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if meanings == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(meanings) != 0 {
			t.Errorf("expected 0 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DeleteByWordID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("deletes multiple", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		count, err := repo.DeleteByWordID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 3 {
			t.Errorf("expected count=3, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("no rows affected", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings WHERE word_id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		count, err := repo.DeleteByWordID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 0 {
			t.Errorf("expected count=0, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

// Helper function
func ptr(s string) *string {
	return &s
}


================================================================================

================================================================================
Файл: internal/database/meaning/srs.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/srs.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetDueForReview возвращает meanings, которые нужно повторить (next_review_at < NOW()).
func (r *Repo) GetDueForReview(ctx context.Context, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Lt{"next_review_at": r.clock.Now()}).
		OrderBy("next_review_at ASC").
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetByStatus возвращает meanings с указанным статусом обучения.
func (r *Repo) GetByStatus(ctx context.Context, status model.LearningStatus, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"learning_status": status}).
		OrderBy("created_at ASC").
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetStudyQueue возвращает очередь для изучения.
func (r *Repo) GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error) {
	limit = database.NormalizeLimit(limit, database.DefaultSRSLimit)

	now := r.clock.Now()

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Or{
			squirrel.Eq{"learning_status": model.LearningStatusNew},
			squirrel.Lt{"next_review_at": now},
		}).
		OrderBy("COALESCE(next_review_at, created_at) ASC").
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Meaning](ctx, r.q, query, args...)
}

// GetStats возвращает статистику.
// Используем SQL Aliases (as total_words), чтобы scany мог замапить колонки на поля структуры Stats.
func (r *Repo) GetStats(ctx context.Context) (*model.Stats, error) {
	now := r.clock.Now()

	const query = `
		SELECT 
			COUNT(DISTINCT word_id) as total_words,
			COUNT(*) FILTER (WHERE learning_status = $1) as mastered_count,
			COUNT(*) FILTER (WHERE learning_status = $2) as learning_count,
			COUNT(*) FILTER (WHERE next_review_at < $3 OR learning_status = $4) as due_for_review_count
		FROM meanings
	`

	return database.GetOne[model.Stats](ctx, r.q, query,
		model.LearningStatusMastered,
		model.LearningStatusLearning,
		now,
		model.LearningStatusNew,
	)
}

// UpdateSRS обновляет только SRS-поля meaning.
func (r *Repo) UpdateSRS(ctx context.Context, id int64, srs *SRSUpdate) error {
	if srs == nil {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	qb := database.Builder.
		Update(tableName).
		Set("learning_status", srs.LearningStatus).
		Set("updated_at", now).
		Where(squirrel.Eq{"id": id})

	if srs.NextReviewAt != nil {
		qb = qb.Set("next_review_at", srs.NextReviewAt)
	}
	if srs.Interval != nil {
		qb = qb.Set("interval", srs.Interval)
	}
	if srs.EaseFactor != nil {
		qb = qb.Set("ease_factor", srs.EaseFactor)
	}
	if srs.ReviewCount != nil {
		qb = qb.Set("review_count", srs.ReviewCount)
	}

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}


================================================================================

================================================================================
Файл: internal/database/meaning/srs_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/srs_test.go
================================================================================

package meaning_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/meaning"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_GetDueForReview(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns due meanings", func(t *testing.T) {
		pastTime := clock.Now().Add(-1 * time.Hour)
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "тест", nil, nil, "review", pastTime, 7, 2.5, 3, pastTime, pastTime)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE next_review_at < \$1 ORDER BY next_review_at ASC LIMIT 10`).
			WithArgs(clock.Now()).
			WillReturnRows(rows)

		meanings, err := repo.GetDueForReview(ctx, 0) // default limit

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 1 {
			t.Errorf("expected 1 meaning, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByStatus(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaning.New(q)
	ctx := context.Background()

	t.Run("returns meanings with status", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "тест", nil, nil, "new", nil, nil, nil, nil, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE learning_status = \$1 ORDER BY created_at ASC LIMIT 10`).
			WithArgs(model.LearningStatusNew).
			WillReturnRows(rows)

		meanings, err := repo.GetByStatus(ctx, model.LearningStatusNew, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 1 {
			t.Errorf("expected 1 meaning, got %d", len(meanings))
		}
		if meanings[0].LearningStatus != model.LearningStatusNew {
			t.Errorf("expected status=new, got %s", meanings[0].LearningStatus)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetStudyQueue(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns new and due meanings", func(t *testing.T) {
		now := clock.Now()
		pastTime := now.Add(-1 * time.Hour)
		rows := pgxmock.NewRows(meaningColumns).
			AddRow(1, 1, "noun", nil, "новое", nil, nil, "new", nil, nil, nil, nil, now, now).
			AddRow(2, 2, "verb", nil, "на повторение", nil, nil, "review", pastTime, 7, 2.5, 3, now, now)

		mock.ExpectQuery(`SELECT (.+) FROM meanings WHERE \(learning_status = \$1 OR next_review_at < \$2\)`).
			WithArgs(model.LearningStatusNew, now).
			WillReturnRows(rows)

		meanings, err := repo.GetStudyQueue(ctx, 10)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(meanings) != 2 {
			t.Errorf("expected 2 meanings, got %d", len(meanings))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetStats(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("returns stats", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"total", "mastered", "learning", "due"}).
			AddRow(100, 50, 30, 20)

		mock.ExpectQuery(`SELECT (.+) FROM meanings`).
			WithArgs(
				model.LearningStatusMastered,
				model.LearningStatusLearning,
				clock.Now(),
				model.LearningStatusNew,
			).
			WillReturnRows(rows)

		stats, err := repo.GetStats(ctx)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if stats.TotalWords != 100 {
			t.Errorf("expected TotalWords=100, got %d", stats.TotalWords)
		}
		if stats.MasteredCount != 50 {
			t.Errorf("expected MasteredCount=50, got %d", stats.MasteredCount)
		}
		if stats.LearningCount != 30 {
			t.Errorf("expected LearningCount=30, got %d", stats.LearningCount)
		}
		if stats.DueForReviewCount != 20 {
			t.Errorf("expected DueForReviewCount=20, got %d", stats.DueForReviewCount)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_UpdateSRS(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := meaning.New(q, meaning.WithClock(clock))
	ctx := context.Background()

	t.Run("success with all fields", func(t *testing.T) {
		nextReview := clock.Now().Add(24 * time.Hour)
		interval := 7
		easeFactor := 2.5
		reviewCount := 5

		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusLearning,
			NextReviewAt:   &nextReview,
			Interval:       &interval,
			EaseFactor:     &easeFactor,
			ReviewCount:    &reviewCount,
		}

		// Порядок: SET поля (learning_status, updated_at, next_review_at, interval, ease_factor, review_count), затем WHERE id
		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusLearning,
				clock.Now(),
				nextReview,
				interval,
				easeFactor,
				reviewCount,
				int64(1), // id в WHERE в конце
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.UpdateSRS(ctx, 1, srs)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("success with minimal fields", func(t *testing.T) {
		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusMastered,
		}

		// Только learning_status, updated_at, затем id в WHERE
		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusMastered,
				clock.Now(),
				int64(1),
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.UpdateSRS(ctx, 1, srs)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil srs", func(t *testing.T) {
		err := repo.UpdateSRS(ctx, 1, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("not found", func(t *testing.T) {
		srs := &meaning.SRSUpdate{
			LearningStatus: model.LearningStatusNew,
		}

		mock.ExpectExec(`UPDATE meanings SET`).
			WithArgs(
				model.LearningStatusNew,
				clock.Now(),
				int64(999),
			).
			WillReturnResult(pgxmock.NewResult("UPDATE", 0))

		err := repo.UpdateSRS(ctx, 999, srs)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}


================================================================================

================================================================================
Файл: internal/database/meaning/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaning/write.go
================================================================================

package meaning

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// Create создаёт новое meaning в базе данных.
func (r *Repo) Create(ctx context.Context, meaning *model.Meaning) error {
	if meaning == nil {
		return database.ErrInvalidInput
	}

	if meaning.WordID == 0 || meaning.TranslationRu == "" {
		return database.ErrInvalidInput
	}

	// Значения по умолчанию
	if meaning.LearningStatus == "" {
		meaning.LearningStatus = model.LearningStatusNew
	}
	if meaning.PartOfSpeech == "" {
		meaning.PartOfSpeech = model.PartOfSpeechOther
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Insert(tableName).
		Columns(
			"word_id", "part_of_speech", "definition_en", "translation_ru",
			"cefr_level", "image_url", "learning_status", "next_review_at",
			"interval", "ease_factor", "review_count", "created_at", "updated_at",
		).
		Values(
			meaning.WordID,
			meaning.PartOfSpeech,
			meaning.DefinitionEn, // Прямая передача *string
			meaning.TranslationRu,
			meaning.CefrLevel, // Прямая передача *string
			meaning.ImageURL,  // Прямая передача *string
			meaning.LearningStatus,
			meaning.NextReviewAt, // Прямая передача *time.Time
			meaning.Interval,     // Прямая передача *int
			meaning.EaseFactor,   // Прямая передача *float64
			meaning.ReviewCount,  // Прямая передача *int
			now,
			now,
		).
		Suffix("RETURNING id").
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&meaning.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	meaning.CreatedAt = now
	meaning.UpdatedAt = now
	return nil
}

// Update обновляет лингвистические поля meaning (не SRS).
func (r *Repo) Update(ctx context.Context, meaning *model.Meaning) error {
	if meaning == nil || meaning.TranslationRu == "" {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Update(tableName).
		Set("word_id", meaning.WordID).
		Set("part_of_speech", meaning.PartOfSpeech).
		Set("definition_en", meaning.DefinitionEn). // Прямая передача
		Set("translation_ru", meaning.TranslationRu).
		Set("cefr_level", meaning.CefrLevel). // Прямая передача
		Set("image_url", meaning.ImageURL).   // Прямая передача
		Set("updated_at", now).
		Where(squirrel.Eq{"id": meaning.ID}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	meaning.UpdatedAt = now
	return nil
}

// Delete удаляет meaning по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}
	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}
	return nil
}

// DeleteByWordID удаляет все meanings для указанного слова.
func (r *Repo) DeleteByWordID(ctx context.Context, wordID int64) (int64, error) {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"word_id": wordID}).
		ToSql()
	if err != nil {
		return 0, err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	return commandTag.RowsAffected(), nil
}


================================================================================

================================================================================
Файл: internal/database/meaningtag/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaningtag/repository.go
================================================================================

package meaningtag

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

const (
	tableName = "meanings_tags"
)

type Repo struct {
	q database.Querier
}

func New(q database.Querier) *Repo {
	return &Repo{q: q}
}

func (r *Repo) AttachTag(ctx context.Context, meaningID, tagID int64) error {
	query, args, err := database.Builder.
		Insert(tableName).
		Columns("meaning_id", "tag_id").
		Values(meaningID, tagID).
		Suffix("ON CONFLICT DO NOTHING").
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) AttachTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	if len(tagIDs) == 0 {
		return nil
	}
	qb := database.Builder.
		Insert(tableName).
		Columns("meaning_id", "tag_id")

	for _, tagID := range tagIDs {
		qb = qb.Values(meaningID, tagID)
	}
	qb = qb.Suffix("ON CONFLICT DO NOTHING")

	query, args, err := qb.ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) DetachTag(ctx context.Context, meaningID, tagID int64) error {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"meaning_id": meaningID, "tag_id": tagID}).
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

func (r *Repo) DetachAllFromMeaning(ctx context.Context, meaningID int64) error {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"meaning_id": meaningID}).
		ToSql()
	if err != nil {
		return err
	}
	_, err = r.q.Exec(ctx, query, args...)
	return err
}

// GetTagIDsByMeaningID возвращает ID тегов для meaning.
// Используем SelectScalars для получения []int64.
func (r *Repo) GetTagIDsByMeaningID(ctx context.Context, meaningID int64) ([]int64, error) {
	query, args, err := database.Builder.
		Select("tag_id").
		From(tableName).
		Where(squirrel.Eq{"meaning_id": meaningID}).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.SelectScalars[int64](ctx, r.q, query, args...)
}

// GetMeaningIDsByTagID возвращает ID meanings для tag.
func (r *Repo) GetMeaningIDsByTagID(ctx context.Context, tagID int64) ([]int64, error) {
	query, args, err := database.Builder.
		Select("meaning_id").
		From(tableName).
		Where(squirrel.Eq{"tag_id": tagID}).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.SelectScalars[int64](ctx, r.q, query, args...)
}

// GetByMeaningIDs возвращает все связи для нескольких meanings.
// Используем Select для получения списка структур.
func (r *Repo) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error) {
	if len(meaningIDs) == 0 {
		return make([]model.MeaningTag, 0), nil
	}
	query, args, err := database.Builder.
		Select("meaning_id", "tag_id").
		From(tableName).
		Where(squirrel.Eq{"meaning_id": meaningIDs}).
		ToSql()
	if err != nil {
		return nil, err
	}
	return database.Select[model.MeaningTag](ctx, r.q, query, args...)
}

func (r *Repo) SyncTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	// TODO: Оптимизировать через вычисление Diff (insert/delete), чтобы избежать bloat таблицы
	if err := r.DetachAllFromMeaning(ctx, meaningID); err != nil {
		return err
	}
	return r.AttachTags(ctx, meaningID, tagIDs)
}


================================================================================

================================================================================
Файл: internal/database/meaningtag/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/meaningtag/repository_test.go
================================================================================

package meaningtag_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database/meaningtag"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_AttachTag(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(2)).
			WillReturnResult(pgxmock.NewResult("INSERT", 1))

		err := repo.AttachTag(ctx, 1, 2)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_AttachTags(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("attaches multiple", func(t *testing.T) {
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(2), int64(1), int64(3), int64(1), int64(4)).
			WillReturnResult(pgxmock.NewResult("INSERT", 3))

		err := repo.AttachTags(ctx, 1, []int64{2, 3, 4})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty list", func(t *testing.T) {
		err := repo.AttachTags(ctx, 1, []int64{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
	})
}

func TestRepo_DetachTag(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1 AND tag_id = \$2`).
			WithArgs(int64(1), int64(2)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.DetachTag(ctx, 1, 2)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_DetachAllFromMeaning(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 3))

		err := repo.DetachAllFromMeaning(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetTagIDsByMeaningID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("returns tag ids", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"tag_id"}).
			AddRow(1).
			AddRow(2).
			AddRow(3)

		mock.ExpectQuery(`SELECT tag_id FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		ids, err := repo.GetTagIDsByMeaningID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(ids) != 3 {
			t.Errorf("expected 3 ids, got %d", len(ids))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"tag_id"})

		mock.ExpectQuery(`SELECT tag_id FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(999)).
			WillReturnRows(rows)

		ids, err := repo.GetTagIDsByMeaningID(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if ids == nil {
			t.Error("expected empty slice, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByMeaningIDs(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("returns all relations", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"meaning_id", "tag_id"}).
			AddRow(1, 10).
			AddRow(1, 20).
			AddRow(2, 10)

		mock.ExpectQuery(`SELECT meaning_id, tag_id FROM meanings_tags WHERE meaning_id IN \(\$1,\$2\)`).
			WithArgs(int64(1), int64(2)).
			WillReturnRows(rows)

		relations, err := repo.GetByMeaningIDs(ctx, []int64{1, 2})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(relations) != 3 {
			t.Errorf("expected 3 relations, got %d", len(relations))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty input", func(t *testing.T) {
		relations, err := repo.GetByMeaningIDs(ctx, []int64{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if relations == nil {
			t.Error("expected empty slice, got nil")
		}
	})
}

func TestRepo_SyncTags(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := meaningtag.New(q)
	ctx := context.Background()

	t.Run("syncs tags", func(t *testing.T) {
		// Сначала удаляет старые
		mock.ExpectExec(`DELETE FROM meanings_tags WHERE meaning_id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 2))

		// Затем добавляет новые
		mock.ExpectExec(`INSERT INTO meanings_tags`).
			WithArgs(int64(1), int64(5), int64(1), int64(6)).
			WillReturnResult(pgxmock.NewResult("INSERT", 2))

		err := repo.SyncTags(ctx, 1, []int64{5, 6})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}


================================================================================

================================================================================
Файл: internal/database/tag/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/read.go
================================================================================

package tag

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// GetByID возвращает tag по ID.
func (r *Repo) GetByID(ctx context.Context, id int64) (*model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.GetOne[model.Tag](ctx, r.q, query, args...)
}

// GetByName возвращает tag по имени.
func (r *Repo) GetByName(ctx context.Context, name string) (model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"name": name}).
		ToSql()
	if err != nil {
		return model.Tag{}, err
	}

	tag, err := database.GetOne[model.Tag](ctx, r.q, query, args...)
	if err != nil {
		return model.Tag{}, err
	}
	return *tag, nil
}

// GetByNames возвращает tags по списку имён.
func (r *Repo) GetByNames(ctx context.Context, names []string) ([]model.Tag, error) {
	if len(names) == 0 {
		return make([]model.Tag, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"name": names}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}

// GetByIDs возвращает tags по списку ID.
func (r *Repo) GetByIDs(ctx context.Context, ids []int64) ([]model.Tag, error) {
	if len(ids) == 0 {
		return make([]model.Tag, 0), nil
	}

	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"id": ids}).
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}

// List возвращает все tags.
func (r *Repo) List(ctx context.Context) ([]model.Tag, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		OrderBy("name ASC").
		ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Tag](ctx, r.q, query, args...)
}


================================================================================

================================================================================
Файл: internal/database/tag/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/repository.go
================================================================================

package tag

import (
	"github.com/heartmarshall/my-english/internal/database"
)

const (
	tableName = "tags"
)

var columns = []string{
	"id",
	"name",
}

// Repo — реализация репозитория для работы с tags.
type Repo struct {
	q database.Querier
}

// New создаёт новый репозиторий.
func New(q database.Querier) *Repo {
	return &Repo{q: q}
}


================================================================================

================================================================================
Файл: internal/database/tag/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/repository_test.go
================================================================================

package tag_test

import (
	"context"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/tag"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

var tagColumns = []string{"id", "name"}

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		tg := &model.Tag{Name: "vocabulary"}

		mock.ExpectQuery(`INSERT INTO tags`).
			WithArgs("vocabulary").
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(1))

		err := repo.Create(ctx, tg)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 1 {
			t.Errorf("expected ID=1, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil tag", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("empty name", func(t *testing.T) {
		tg := &model.Tag{Name: "   "}

		err := repo.Create(ctx, tg)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "business")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		tg, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.Name != "business" {
			t.Errorf("expected Name='business', got %q", tg.Name)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByName(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "travel")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("travel").
			WillReturnRows(rows)

		tg, err := repo.GetByName(ctx, "travel")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.Name != "travel" {
			t.Errorf("expected Name='travel', got %q", tg.Name)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("nonexistent").
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByName(ctx, "nonexistent")

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByNames(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("found multiple", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).
			AddRow(1, "business").
			AddRow(2, "travel")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name IN \(\$1,\$2\)`).
			WithArgs("business", "travel").
			WillReturnRows(rows)

		tags, err := repo.GetByNames(ctx, []string{"business", "travel"})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(tags) != 2 {
			t.Errorf("expected 2 tags, got %d", len(tags))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty input", func(t *testing.T) {
		tags, err := repo.GetByNames(ctx, []string{})

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tags == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(tags) != 0 {
			t.Errorf("expected 0 tags, got %d", len(tags))
		}
	})
}

func TestRepo_List(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("returns all", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).
			AddRow(1, "a-tag").
			AddRow(2, "b-tag")

		mock.ExpectQuery(`SELECT (.+) FROM tags ORDER BY name ASC`).
			WillReturnRows(rows)

		tags, err := repo.List(ctx)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(tags) != 2 {
			t.Errorf("expected 2 tags, got %d", len(tags))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM tags WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM tags WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetOrCreate(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := tag.New(q)
	ctx := context.Background()

	t.Run("returns existing", func(t *testing.T) {
		rows := pgxmock.NewRows(tagColumns).AddRow(1, "existing")

		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("existing").
			WillReturnRows(rows)

		tg, err := repo.GetOrCreate(ctx, "existing")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 1 {
			t.Errorf("expected ID=1, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("creates new", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM tags WHERE name = \$1`).
			WithArgs("new-tag").
			WillReturnError(pgx.ErrNoRows)

		mock.ExpectQuery(`INSERT INTO tags`).
			WithArgs("new-tag").
			WillReturnRows(pgxmock.NewRows([]string{"id"}).AddRow(5))

		tg, err := repo.GetOrCreate(ctx, "new-tag")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if tg.ID != 5 {
			t.Errorf("expected ID=5, got %d", tg.ID)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty name", func(t *testing.T) {
		_, err := repo.GetOrCreate(ctx, "   ")

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}


================================================================================

================================================================================
Файл: internal/database/tag/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tag/write.go
================================================================================

package tag

import (
	"context"
	"strings"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// Create создаёт новый tag.
func (r *Repo) Create(ctx context.Context, tag *model.Tag) error {
	if tag == nil {
		return database.ErrInvalidInput
	}

	name := strings.TrimSpace(tag.Name)
	if name == "" {
		return database.ErrInvalidInput
	}

	query, args, err := database.Builder.
		Insert(tableName).
		Columns("name").
		Values(name).
		Suffix("RETURNING id").
		ToSql()
	if err != nil {
		return err
	}

	err = r.q.QueryRow(ctx, query, args...).Scan(&tag.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	tag.Name = name
	return nil
}

// GetOrCreate возвращает существующий tag или создаёт новый.
func (r *Repo) GetOrCreate(ctx context.Context, name string) (model.Tag, error) {
	name = strings.TrimSpace(name)
	if name == "" {
		return model.Tag{}, database.ErrInvalidInput
	}

	// Пробуем найти существующий
	tag, err := r.GetByName(ctx, name)
	if err == nil {
		return tag, nil
	}

	if err != database.ErrNotFound {
		return model.Tag{}, err
	}

	// Создаём новый
	tagPtr := &model.Tag{Name: name}
	if err := r.Create(ctx, tagPtr); err != nil {
		// Возможен race condition — проверяем ещё раз
		if database.IsDuplicateError(err) {
			return r.GetByName(ctx, name)
		}
		return model.Tag{}, err
	}

	return *tagPtr, nil
}

// Delete удаляет tag по ID.
func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.
		Delete(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return err
	}

	commandTag, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}

	if commandTag.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	return nil
}


================================================================================

================================================================================
Файл: internal/database/testutil/testutil.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/testutil/testutil.go
================================================================================

// Package testutil содержит утилиты для тестирования репозиториев.
package testutil

import (
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

// MockClock — мок для database.Clock.
type MockClock struct {
	Time time.Time
}

// Now возвращает заранее заданное время.
func (m *MockClock) Now() time.Time {
	return m.Time
}

// FixedTime возвращает фиксированное время для тестов.
func FixedTime() time.Time {
	return time.Date(2025, 1, 15, 10, 30, 0, 0, time.UTC)
}

// NewMockClock создаёт MockClock с фиксированным временем.
func NewMockClock() *MockClock {
	return &MockClock{Time: FixedTime()}
}

// Compile-time проверка.
var _ database.Clock = (*MockClock)(nil)

// NewMockQuerier создаёт мок Querier для тестов.
func NewMockQuerier(t *testing.T) (database.Querier, pgxmock.PgxPoolIface) {
	t.Helper()

	mock, err := pgxmock.NewPool()
	if err != nil {
		t.Fatalf("failed to create pgxmock: %v", err)
	}

	t.Cleanup(func() {
		mock.Close()
	})

	return mock, mock
}

// ExpectationsWereMet проверяет, что все ожидания pgxmock выполнены.
func ExpectationsWereMet(t *testing.T, mock pgxmock.PgxPoolIface) {
	t.Helper()

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("unfulfilled expectations: %v", err)
	}
}


================================================================================

================================================================================
Файл: internal/database/tx.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/tx.go
================================================================================

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
)

// TxManager управляет транзакциями и создаёт репозитории с tx.
type TxManager struct {
	pool *pgxpool.Pool
}

// NewTxManager создаёт новый TxManager.
func NewTxManager(pool *pgxpool.Pool) *TxManager {
	return &TxManager{pool: pool}
}

// RunInTx выполняет функцию в рамках транзакции.
// Querier передаётся в функцию для создания репозиториев.
func (m *TxManager) RunInTx(ctx context.Context, fn func(ctx context.Context, tx Querier) error) error {
	return WithTx(ctx, m.pool, fn)
}

// Pool возвращает пул соединений с БД.
func (m *TxManager) Pool() *pgxpool.Pool {
	return m.pool
}


================================================================================

================================================================================
Файл: internal/database/word/read.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/read.go
================================================================================

package word

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

func (r *Repo) GetByID(ctx context.Context, id int64) (model.Word, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		ToSql()
	if err != nil {
		return model.Word{}, err
	}

	word, err := database.GetOne[model.Word](ctx, r.q, query, args...)
	if err != nil {
		return model.Word{}, err
	}
	return *word, nil
}

func (r *Repo) GetByText(ctx context.Context, text string) (model.Word, error) {
	query, args, err := database.Builder.
		Select(columns...).
		From(tableName).
		Where(squirrel.Eq{"text": text}).
		ToSql()
	if err != nil {
		return model.Word{}, err
	}

	word, err := database.GetOne[model.Word](ctx, r.q, query, args...)
	if err != nil {
		return model.Word{}, err
	}
	return *word, nil
}

func (r *Repo) List(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error) {
	limit, offset = database.NormalizePagination(limit, offset)

	qb := database.Builder.
		Select(columns...).
		From(tableName)

	qb = applyFilter(qb, filter)

	qb = qb.
		OrderBy("created_at DESC").
		Limit(uint64(limit)).
		Offset(uint64(offset))

	query, args, err := qb.ToSql()
	if err != nil {
		return nil, err
	}

	return database.Select[model.Word](ctx, r.q, query, args...)
}

func (r *Repo) Count(ctx context.Context, filter *model.WordFilter) (int, error) {
	qb := database.Builder.Select("COUNT(*)").From(tableName)
	qb = applyFilter(qb, filter)

	query, args, err := qb.ToSql()
	if err != nil {
		return 0, err
	}

	return database.GetScalar[int](ctx, r.q, query, args...)
}

func (r *Repo) Exists(ctx context.Context, id int64) (bool, error) {
	query, args, err := database.Builder.
		Select("1").
		From(tableName).
		Where(squirrel.Eq{"id": id}).
		Limit(1).
		ToSql()
	if err != nil {
		return false, err
	}
	return database.CheckExists(ctx, r.q, query, args...)
}

func applyFilter(qb squirrel.SelectBuilder, filter *model.WordFilter) squirrel.SelectBuilder {
	if filter == nil {
		return qb
	}
	if filter.Search != nil && *filter.Search != "" {
		return qb.Where(squirrel.ILike{"text": "%" + *filter.Search + "%"})
	}
	return qb
}


================================================================================

================================================================================
Файл: internal/database/word/repository.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/repository.go
================================================================================

// Package word содержит репозиторий для работы с таблицей words.
package word

import (
	"github.com/heartmarshall/my-english/internal/database"
)

// Константы таблицы.
const (
	tableName = "words"
)

// columns — список колонок таблицы words.
var columns = []string{
	"id",
	"text",
	"transcription",
	"audio_url",
	"frequency_rank",
	"created_at",
}

// Repo — реализация репозитория для PostgreSQL.
type Repo struct {
	q     database.Querier
	clock database.Clock
}

// Option — функциональная опция для конфигурации Repo.
type Option func(*Repo)

// WithClock устанавливает кастомный clock (полезно для тестов).
func WithClock(c database.Clock) Option {
	return func(r *Repo) {
		r.clock = c
	}
}

// New создаёт новый репозиторий.
func New(q database.Querier, opts ...Option) *Repo {
	r := &Repo{
		q:     q,
		clock: database.DefaultClock,
	}

	for _, opt := range opts {
		opt(r)
	}

	return r
}


================================================================================

================================================================================
Файл: internal/database/word/repository_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/repository_test.go
================================================================================

package word_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/database/testutil"
	"github.com/heartmarshall/my-english/internal/database/word"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/jackc/pgx/v5"
	pgxmock "github.com/pashagolub/pgxmock/v2"
)

func TestRepo_Create(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	clock := testutil.NewMockClock()
	repo := word.New(q, word.WithClock(clock))
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		w := &model.Word{
			Text:          "Hello",
			Transcription: ptr("həˈloʊ"),
			AudioURL:      ptr("https://example.com/hello.mp3"),
			FrequencyRank: intPtr(100),
		}

		transcription := "həˈloʊ"
		audioURL := "https://example.com/hello.mp3"
		freqRank := int64(100)
		rows := pgxmock.NewRows([]string{"id"}).AddRow(int64(1))
		mock.ExpectQuery(`INSERT INTO words`).
			WithArgs("hello", &transcription, &audioURL, &freqRank, clock.Now()).
			WillReturnRows(rows)

		err := repo.Create(ctx, w)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.ID != 1 {
			t.Errorf("expected ID=1, got %d", w.ID)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil word", func(t *testing.T) {
		err := repo.Create(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("empty text", func(t *testing.T) {
		w := &model.Word{Text: "   "}

		err := repo.Create(ctx, w)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("duplicate", func(t *testing.T) {
		w := &model.Word{Text: "duplicate"}

		mock.ExpectQuery(`INSERT INTO words`).
			WithArgs("duplicate", nil, nil, nil, clock.Now()).
			WillReturnError(pgx.ErrNoRows) // simplified; real error would be postgres duplicate key

		err := repo.Create(ctx, w)

		if err == nil {
			t.Error("expected error, got nil")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByID(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("found", func(t *testing.T) {
		now := time.Now()
		transcription := "həˈloʊ"
		audioURL := "https://example.com/hello.mp3"
		freqRank := int64(100)
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", &transcription, &audioURL, &freqRank, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		w, err := repo.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.ID != 1 {
			t.Errorf("expected ID=1, got %d", w.ID)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM words WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByID(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_GetByText(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("found with trimming and lowercasing", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text = \$1`).
			WithArgs("hello"). // trimmed and lowercased
			WillReturnRows(rows)

		w, err := repo.GetByText(ctx, "  HELLO  ")

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.Text != "hello" {
			t.Errorf("expected text='hello', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text = \$1`).
			WithArgs("nonexistent").
			WillReturnError(pgx.ErrNoRows)

		_, err := repo.GetByText(ctx, "nonexistent")

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_List(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("without filter", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now).
			AddRow(int64(2), "world", nil, nil, nil, &now)

		mock.ExpectQuery(`SELECT (.+) FROM words ORDER BY created_at DESC LIMIT 20 OFFSET 0`).
			WillReturnRows(rows)

		words, err := repo.List(ctx, nil, 0, 0) // default limit

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(words) != 2 {
			t.Errorf("expected 2 words, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("with search filter", func(t *testing.T) {
		now := time.Now()
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"}).
			AddRow(int64(1), "hello", nil, nil, nil, &now)

		search := "hel"
		filter := &model.WordFilter{Search: &search}

		mock.ExpectQuery(`SELECT (.+) FROM words WHERE text ILIKE \$1 ORDER BY created_at DESC LIMIT 10 OFFSET 0`).
			WithArgs("%hel%").
			WillReturnRows(rows)

		words, err := repo.List(ctx, filter, 10, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(words) != 1 {
			t.Errorf("expected 1 word, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("empty result", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"id", "text", "transcription", "audio_url", "frequency_rank", "created_at"})

		mock.ExpectQuery(`SELECT (.+) FROM words`).
			WillReturnRows(rows)

		words, err := repo.List(ctx, nil, 20, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if words == nil {
			t.Error("expected empty slice, got nil")
		}
		if len(words) != 0 {
			t.Errorf("expected 0 words, got %d", len(words))
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Count(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"count"}).AddRow(int64(42))

		mock.ExpectQuery(`SELECT COUNT\(\*\) FROM words`).
			WillReturnRows(rows)

		count, err := repo.Count(ctx, nil)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 42 {
			t.Errorf("expected count=42, got %d", count)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Update(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		w := &model.Word{
			ID:   1,
			Text: "Updated",
		}

		mock.ExpectExec(`UPDATE words SET`).
			WithArgs("updated", nil, nil, nil, int64(1)).
			WillReturnResult(pgxmock.NewResult("UPDATE", 1))

		err := repo.Update(ctx, w)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if w.Text != "updated" {
			t.Errorf("expected text='updated', got %q", w.Text)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		w := &model.Word{ID: 999, Text: "test"}

		mock.ExpectExec(`UPDATE words SET`).
			WithArgs("test", nil, nil, nil, int64(999)).
			WillReturnResult(pgxmock.NewResult("UPDATE", 0))

		err := repo.Update(ctx, w)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("nil word", func(t *testing.T) {
		err := repo.Update(ctx, nil)

		if err != database.ErrInvalidInput {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func TestRepo_Delete(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM words WHERE id = \$1`).
			WithArgs(int64(1)).
			WillReturnResult(pgxmock.NewResult("DELETE", 1))

		err := repo.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not found", func(t *testing.T) {
		mock.ExpectExec(`DELETE FROM words WHERE id = \$1`).
			WithArgs(int64(999)).
			WillReturnResult(pgxmock.NewResult("DELETE", 0))

		err := repo.Delete(ctx, 999)

		if err != database.ErrNotFound {
			t.Errorf("expected ErrNotFound, got %v", err)
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

func TestRepo_Exists(t *testing.T) {
	q, mock := testutil.NewMockQuerier(t)
	repo := word.New(q)
	ctx := context.Background()

	t.Run("exists", func(t *testing.T) {
		rows := pgxmock.NewRows([]string{"1"}).AddRow(int64(1))

		mock.ExpectQuery(`SELECT 1 FROM words WHERE id = \$1 LIMIT 1`).
			WithArgs(int64(1)).
			WillReturnRows(rows)

		exists, err := repo.Exists(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !exists {
			t.Error("expected exists=true")
		}
		testutil.ExpectationsWereMet(t, mock)
	})

	t.Run("not exists", func(t *testing.T) {
		mock.ExpectQuery(`SELECT 1 FROM words WHERE id = \$1 LIMIT 1`).
			WithArgs(int64(999)).
			WillReturnError(pgx.ErrNoRows)

		exists, err := repo.Exists(ctx, 999)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if exists {
			t.Error("expected exists=false")
		}
		testutil.ExpectationsWereMet(t, mock)
	})
}

// Helper functions
func ptr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}


================================================================================

================================================================================
Файл: internal/database/word/write.go
Полный путь: /home/alodi/playground/my-english/backend/internal/database/word/write.go
================================================================================

package word

import (
	"context"
	"strings"

	"github.com/Masterminds/squirrel"
	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

func (r *Repo) Create(ctx context.Context, word *model.Word) error {
	if word == nil || strings.TrimSpace(word.Text) == "" {
		return database.ErrInvalidInput
	}

	now := r.clock.Now()

	query, args, err := database.Builder.
		Insert(tableName).
		Columns("text", "transcription", "audio_url", "frequency_rank", "created_at").
		Values(
			word.Text,
			word.Transcription,
			word.AudioURL,
			word.FrequencyRank,
			now,
		).
		Suffix("RETURNING id").
		ToSql()
	if err != nil {
		return err
	}

	// Для возврата ID используем стандартный Scan, так как это одно поле
	err = r.q.QueryRow(ctx, query, args...).Scan(&word.ID)
	if err != nil {
		return database.WrapDBError(err)
	}

	word.CreatedAt = now
	return nil
}

func (r *Repo) Update(ctx context.Context, word *model.Word) error {
	if word == nil || strings.TrimSpace(word.Text) == "" {
		return database.ErrInvalidInput
	}

	text := strings.TrimSpace(strings.ToLower(word.Text))

	query, args, err := database.Builder.
		Update(tableName).
		Set("text", text).
		Set("transcription", word.Transcription). // Прямая передача
		Set("audio_url", word.AudioURL).
		Set("frequency_rank", word.FrequencyRank).
		Where(squirrel.Eq{"id": word.ID}).
		ToSql()
	if err != nil {
		return err
	}

	cmd, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return database.WrapDBError(err)
	}
	if cmd.RowsAffected() == 0 {
		return database.ErrNotFound
	}

	word.Text = text
	return nil
}

func (r *Repo) Delete(ctx context.Context, id int64) error {
	query, args, err := database.Builder.Delete(tableName).Where(squirrel.Eq{"id": id}).ToSql()
	if err != nil {
		return err
	}
	cmd, err := r.q.Exec(ctx, query, args...)
	if err != nil {
		return err
	}
	if cmd.RowsAffected() == 0 {
		return database.ErrNotFound
	}
	return nil
}


================================================================================

================================================================================
Файл: internal/model/model.go
Полный путь: /home/alodi/playground/my-english/backend/internal/model/model.go
================================================================================

package model

import (
	"database/sql/driver"
	"fmt"
	"time"
)

// Word представляет модель слова
type Word struct {
	ID            int64     `db:"id"`
	Text          string    `db:"text"`
	Transcription *string   `db:"transcription"`
	AudioURL      *string   `db:"audio_url"`
	FrequencyRank *int      `db:"frequency_rank"`
	CreatedAt     time.Time `db:"created_at"`
}

// WordFilter содержит параметры фильтрации при поиске слов
type WordFilter struct {
	Search *string
}

// LearningStatus представляет статус изучения слова
type LearningStatus string

const (
	LearningStatusNew      LearningStatus = "new"
	LearningStatusLearning LearningStatus = "learning"
	LearningStatusReview   LearningStatus = "review"
	LearningStatusMastered LearningStatus = "mastered"
)

// Value реализует driver.Valuer для LearningStatus
func (ls LearningStatus) Value() (driver.Value, error) {
	return string(ls), nil
}

// Scan реализует sql.Scanner для LearningStatus
func (ls *LearningStatus) Scan(value interface{}) error {
	if value == nil {
		*ls = LearningStatusNew
		return nil
	}
	switch v := value.(type) {
	case string:
		*ls = LearningStatus(v)
	case []byte:
		*ls = LearningStatus(v)
	default:
		return fmt.Errorf("cannot scan %T into LearningStatus", value)
	}
	return nil
}

// IsValid проверяет, является ли статус валидным значением enum.
func (ls LearningStatus) IsValid() bool {
	switch ls {
	case LearningStatusNew, LearningStatusLearning, LearningStatusReview, LearningStatusMastered:
		return true
	}
	return false
}

// PartOfSpeech представляет часть речи
type PartOfSpeech string

const (
	PartOfSpeechNoun      PartOfSpeech = "noun"
	PartOfSpeechVerb      PartOfSpeech = "verb"
	PartOfSpeechAdjective PartOfSpeech = "adjective"
	PartOfSpeechAdverb    PartOfSpeech = "adverb"
	PartOfSpeechOther     PartOfSpeech = "other"
)

// Value реализует driver.Valuer для PartOfSpeech
func (pos PartOfSpeech) Value() (driver.Value, error) {
	return string(pos), nil
}

// Scan реализует sql.Scanner для PartOfSpeech
func (pos *PartOfSpeech) Scan(value interface{}) error {
	if value == nil {
		return fmt.Errorf("PartOfSpeech cannot be nil")
	}
	switch v := value.(type) {
	case string:
		*pos = PartOfSpeech(v)
	case []byte:
		*pos = PartOfSpeech(v)
	default:
		return fmt.Errorf("cannot scan %T into PartOfSpeech", value)
	}
	return nil
}

// IsValid проверяет, является ли часть речи валидным значением enum.
func (pos PartOfSpeech) IsValid() bool {
	switch pos {
	case PartOfSpeechNoun, PartOfSpeechVerb, PartOfSpeechAdjective,
		PartOfSpeechAdverb, PartOfSpeechOther:
		return true
	}
	return false
}

// Meaning представляет модель значения слова из таблицы meanings
type Meaning struct {
	ID             int64          `db:"id"`
	WordID         int64          `db:"word_id"`
	PartOfSpeech   PartOfSpeech   `db:"part_of_speech"`
	DefinitionEn   *string        `db:"definition_en"`
	TranslationRu  string         `db:"translation_ru"`
	CefrLevel      *string        `db:"cefr_level"`
	ImageURL       *string        `db:"image_url"`
	LearningStatus LearningStatus `db:"learning_status"`
	NextReviewAt   *time.Time     `db:"next_review_at"`
	Interval       *int           `db:"interval"`
	EaseFactor     *float64       `db:"ease_factor"`
	ReviewCount    *int           `db:"review_count"`
	CreatedAt      time.Time      `db:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at"`
}

// Stats представляет статистику по изучению слов
type Stats struct {
	TotalWords        int
	MasteredCount     int
	LearningCount     int
	DueForReviewCount int
}

// ExampleSource представляет источник примера
type ExampleSource string

const (
	ExampleSourceFilm    ExampleSource = "film"
	ExampleSourceBook    ExampleSource = "book"
	ExampleSourceChat    ExampleSource = "chat"
	ExampleSourceVideo   ExampleSource = "video"
	ExampleSourcePodcast ExampleSource = "podcast"
)

// Value реализует driver.Valuer для ExampleSource
func (es ExampleSource) Value() (driver.Value, error) {
	if es == "" {
		return nil, nil
	}
	return string(es), nil
}

// Scan реализует sql.Scanner для ExampleSource
func (es *ExampleSource) Scan(value interface{}) error {
	if value == nil {
		*es = ""
		return nil
	}
	switch v := value.(type) {
	case string:
		*es = ExampleSource(v)
	case []byte:
		*es = ExampleSource(v)
	default:
		return fmt.Errorf("cannot scan %T into ExampleSource", value)
	}
	return nil
}

// IsValid проверяет, является ли источник валидным значением enum.
func (es ExampleSource) IsValid() bool {
	switch es {
	case ExampleSourceFilm, ExampleSourceBook, ExampleSourceChat,
		ExampleSourceVideo, ExampleSourcePodcast, "":
		return true
	}
	return false
}

// Example представляет пример использования слова
type Example struct {
	ID         int64          `db:"id"`
	MeaningID  int64          `db:"meaning_id"`
	SentenceEn string         `db:"sentence_en"`
	SentenceRu *string        `db:"sentence_ru"`
	SourceName *ExampleSource `db:"source_name"`
}

// Tag представляет тег для категоризации значений
type Tag struct {
	ID   int64  `db:"id"`
	Name string `db:"name"`
}

// MeaningTag представляет связь meaning-tag (many-to-many)
type MeaningTag struct {
	MeaningID int64 `db:"meaning_id"`
	TagID     int64 `db:"tag_id"`
}


================================================================================

================================================================================
Файл: internal/model/validate.go
Полный путь: /home/alodi/playground/my-english/backend/internal/model/validate.go
================================================================================

package model

import (
	"errors"
	"fmt"
	"reflect"
	"strings"
	"sync"

	"github.com/go-playground/validator/v10"
)

// Validation constants
const (
	MaxWordLength        = 100
	MaxTranslationLength = 500
	MaxDefinitionLength  = 1000
	MaxSentenceLength    = 1000
	MaxTagNameLength     = 50
	MaxURLLength         = 2048
)

// Validator — глобальный валидатор (thread-safe).
var (
	validate     *validator.Validate
	validateOnce sync.Once
)

// GetValidator возвращает настроенный валидатор.
func GetValidator() *validator.Validate {
	validateOnce.Do(func() {
		validate = validator.New(validator.WithRequiredStructEnabled())

		// Регистрируем кастомные валидаторы
		validate.RegisterValidation("part_of_speech", validatePartOfSpeech)
		validate.RegisterValidation("learning_status", validateLearningStatus)
		validate.RegisterValidation("example_source", validateExampleSource)
	})
	return validate
}

// --- Custom validators ---

func validatePartOfSpeech(fl validator.FieldLevel) bool {
	pos, ok := fl.Field().Interface().(PartOfSpeech)
	if !ok {
		return false
	}
	return pos.IsValid()
}

func validateLearningStatus(fl validator.FieldLevel) bool {
	status, ok := fl.Field().Interface().(LearningStatus)
	if !ok {
		return false
	}
	return status.IsValid()
}

func validateExampleSource(fl validator.FieldLevel) bool {
	field := fl.Field()

	// Проверяем тип поля
	switch field.Kind() {
	case reflect.Ptr:
		if field.IsNil() {
			return true // nil допустим
		}
		src, ok := field.Interface().(*ExampleSource)
		if !ok {
			return false
		}
		return src.IsValid()
	case reflect.String:
		src := ExampleSource(field.String())
		return src.IsValid()
	default:
		return false
	}
}

// --- ValidationError ---

// ValidationError представляет ошибку валидации.
type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
	Tag     string `json:"tag"`
	Value   any    `json:"value,omitempty"`
}

func (e *ValidationError) Error() string {
	return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

// ValidationErrors — список ошибок валидации.
type ValidationErrors []*ValidationError

func (ve ValidationErrors) Error() string {
	if len(ve) == 0 {
		return ""
	}
	var sb strings.Builder
	for i, e := range ve {
		if i > 0 {
			sb.WriteString("; ")
		}
		sb.WriteString(e.Error())
	}
	return sb.String()
}

// translateError преобразует ошибку validator в понятное сообщение.
func translateError(fe validator.FieldError) *ValidationError {
	field := toSnakeCase(fe.Field())
	tag := fe.Tag()

	var message string
	switch tag {
	case "required":
		message = "is required"
	case "max":
		message = fmt.Sprintf("must be at most %s characters", fe.Param())
	case "min":
		message = fmt.Sprintf("must be at least %s characters", fe.Param())
	case "url":
		message = "must be a valid URL"
	case "part_of_speech":
		message = "must be one of: noun, verb, adjective, adverb, other"
	case "learning_status":
		message = "must be one of: new, learning, review, mastered"
	case "example_source":
		message = "must be one of: film, book, chat, video, podcast"
	default:
		message = fmt.Sprintf("failed on '%s' validation", tag)
	}

	return &ValidationError{
		Field:   field,
		Message: message,
		Tag:     tag,
		Value:   fe.Value(),
	}
}

// toSnakeCase конвертирует CamelCase в snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteByte('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

// --- Validate functions ---

// Validate валидирует любую структуру.
func Validate(s any) error {
	err := GetValidator().Struct(s)
	if err == nil {
		return nil
	}

	var validationErrs validator.ValidationErrors
	if errors.As(err, &validationErrs) {
		result := make(ValidationErrors, 0, len(validationErrs))
		for _, fe := range validationErrs {
			result = append(result, translateError(fe))
		}
		return result
	}

	return err
}

// --- Validatable structs with tags ---

// WordInput — структура для валидации входных данных слова.
type WordInput struct {
	Text          string  `validate:"required,min=1,max=100"`
	Transcription *string `validate:"omitempty,max=100"`
	AudioURL      *string `validate:"omitempty,url,max=2048"`
}

// MeaningInput — структура для валидации входных данных значения.
type MeaningInput struct {
	PartOfSpeech  PartOfSpeech `validate:"required,part_of_speech"`
	TranslationRu string       `validate:"required,min=1,max=500"`
	DefinitionEn  *string      `validate:"omitempty,max=1000"`
	CefrLevel     *string      `validate:"omitempty,max=10"`
	ImageURL      *string      `validate:"omitempty,url,max=2048"`
}

// ExampleInput — структура для валидации входных данных примера.
type ExampleInput struct {
	SentenceEn string         `validate:"required,min=1,max=1000"`
	SentenceRu *string        `validate:"omitempty,max=1000"`
	SourceName *ExampleSource `validate:"omitempty,example_source"`
}

// TagInput — структура для валидации входных данных тега.
type TagInput struct {
	Name string `validate:"required,min=1,max=50"`
}

// --- Model Validate methods ---

// Validate проверяет валидность Word.
func (w *Word) Validate() error {
	input := WordInput{
		Text:          w.Text,
		Transcription: w.Transcription,
		AudioURL:      w.AudioURL,
	}
	return Validate(input)
}

// Validate проверяет валидность Meaning.
func (m *Meaning) Validate() error {
	input := MeaningInput{
		PartOfSpeech:  m.PartOfSpeech,
		TranslationRu: m.TranslationRu,
		DefinitionEn:  m.DefinitionEn,
		CefrLevel:     m.CefrLevel,
		ImageURL:      m.ImageURL,
	}
	return Validate(input)
}

// Validate проверяет валидность Example.
func (e *Example) Validate() error {
	input := ExampleInput{
		SentenceEn: e.SentenceEn,
		SentenceRu: e.SentenceRu,
		SourceName: e.SourceName,
	}
	return Validate(input)
}

// Validate проверяет валидность Tag.
func (t *Tag) Validate() error {
	input := TagInput{
		Name: t.Name,
	}
	return Validate(input)
}


================================================================================

================================================================================
Файл: internal/model/validate_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/model/validate_test.go
================================================================================

package model

import (
	"strings"
	"testing"
)

func TestWordValidate(t *testing.T) {
	tests := []struct {
		name    string
		word    Word
		wantErr bool
		errMsg  string
	}{
		{
			name:    "valid word",
			word:    Word{Text: "hello"},
			wantErr: false,
		},
		{
			name:    "empty text",
			word:    Word{Text: ""},
			wantErr: true,
			errMsg:  "text",
		},
		{
			name:    "text too long",
			word:    Word{Text: strings.Repeat("a", 101)},
			wantErr: true,
			errMsg:  "text",
		},
		{
			name:    "valid with transcription",
			word:    Word{Text: "hello", Transcription: ptr("həˈloʊ")},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.word.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr && err != nil && tt.errMsg != "" {
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("error should contain %q, got %q", tt.errMsg, err.Error())
				}
			}
		})
	}
}

func TestMeaningValidate(t *testing.T) {
	tests := []struct {
		name    string
		meaning Meaning
		wantErr bool
		errMsg  string
	}{
		{
			name: "valid meaning",
			meaning: Meaning{
				PartOfSpeech:  PartOfSpeechNoun,
				TranslationRu: "привет",
			},
			wantErr: false,
		},
		{
			name: "empty translation",
			meaning: Meaning{
				PartOfSpeech:  PartOfSpeechNoun,
				TranslationRu: "",
			},
			wantErr: true,
			errMsg:  "translation_ru",
		},
		{
			name: "invalid part of speech",
			meaning: Meaning{
				PartOfSpeech:  PartOfSpeech("invalid"),
				TranslationRu: "тест",
			},
			wantErr: true,
			errMsg:  "part_of_speech",
		},
		{
			name: "translation too long",
			meaning: Meaning{
				PartOfSpeech:  PartOfSpeechVerb,
				TranslationRu: strings.Repeat("а", 501),
			},
			wantErr: true,
			errMsg:  "translation_ru",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.meaning.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr && err != nil && tt.errMsg != "" {
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("error should contain %q, got %q", tt.errMsg, err.Error())
				}
			}
		})
	}
}

func TestExampleValidate(t *testing.T) {
	tests := []struct {
		name    string
		example Example
		wantErr bool
		errMsg  string
	}{
		{
			name:    "valid example",
			example: Example{SentenceEn: "Hello, world!"},
			wantErr: false,
		},
		{
			name:    "empty sentence",
			example: Example{SentenceEn: ""},
			wantErr: true,
			errMsg:  "sentence_en",
		},
		{
			name:    "with valid source",
			example: Example{SentenceEn: "Hello!", SourceName: ptrSource(ExampleSourceFilm)},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.example.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr && err != nil && tt.errMsg != "" {
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("error should contain %q, got %q", tt.errMsg, err.Error())
				}
			}
		})
	}
}

func TestTagValidate(t *testing.T) {
	tests := []struct {
		name    string
		tag     Tag
		wantErr bool
	}{
		{
			name:    "valid tag",
			tag:     Tag{Name: "greetings"},
			wantErr: false,
		},
		{
			name:    "empty name",
			tag:     Tag{Name: ""},
			wantErr: true,
		},
		{
			name:    "name too long",
			tag:     Tag{Name: strings.Repeat("a", 51)},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.tag.Validate()
			if (err != nil) != tt.wantErr {
				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestValidationErrors(t *testing.T) {
	// Тест множественных ошибок
	meaning := Meaning{
		PartOfSpeech:  PartOfSpeech("invalid"),
		TranslationRu: "",
	}

	err := meaning.Validate()
	if err == nil {
		t.Fatal("expected validation error")
	}

	validationErrs, ok := err.(ValidationErrors)
	if !ok {
		t.Fatalf("expected ValidationErrors, got %T", err)
	}

	if len(validationErrs) < 2 {
		t.Errorf("expected at least 2 errors, got %d", len(validationErrs))
	}
}

// Helper functions
func ptr(s string) *string {
	return &s
}

func ptrSource(s ExampleSource) *ExampleSource {
	return &s
}


================================================================================

================================================================================
Файл: internal/service/loader/service.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/loader/service.go
================================================================================

// Package loader предоставляет сервис для batch-загрузки данных.
// Используется DataLoader'ами в транспортном слое.
package loader

import (
	"context"

	"github.com/heartmarshall/my-english/internal/model"
)

// MeaningRepository определяет интерфейс для загрузки meanings.
type MeaningRepository interface {
	GetByWordIDs(ctx context.Context, wordIDs []int64) ([]model.Meaning, error)
}

// ExampleRepository определяет интерфейс для загрузки examples.
type ExampleRepository interface {
	GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error)
}

// TagRepository определяет интерфейс для загрузки tags.
type TagRepository interface {
	GetByIDs(ctx context.Context, ids []int64) ([]model.Tag, error)
}

// MeaningTagRepository определяет интерфейс для связей meaning-tag.
type MeaningTagRepository interface {
	GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error)
}

// Deps — зависимости сервиса.
type Deps struct {
	Meanings    MeaningRepository
	Examples    ExampleRepository
	Tags        TagRepository
	MeaningTags MeaningTagRepository
}

// Service предоставляет batch-операции для DataLoader.
type Service struct {
	meanings    MeaningRepository
	examples    ExampleRepository
	tags        TagRepository
	meaningTags MeaningTagRepository
}

// New создаёт новый сервис.
func New(deps Deps) *Service {
	return &Service{
		meanings:    deps.Meanings,
		examples:    deps.Examples,
		tags:        deps.Tags,
		meaningTags: deps.MeaningTags,
	}
}

// GetMeaningsByWordIDs загружает meanings для нескольких слов.
func (s *Service) GetMeaningsByWordIDs(ctx context.Context, wordIDs []int64) ([]model.Meaning, error) {
	return s.meanings.GetByWordIDs(ctx, wordIDs)
}

// GetExamplesByMeaningIDs загружает examples для нескольких meanings.
func (s *Service) GetExamplesByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error) {
	return s.examples.GetByMeaningIDs(ctx, meaningIDs)
}

// GetTagsByMeaningIDs загружает теги для нескольких meanings.
// Возвращает связи MeaningTag для группировки.
func (s *Service) GetTagsByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error) {
	return s.meaningTags.GetByMeaningIDs(ctx, meaningIDs)
}

// GetTagsByIDs загружает теги по ID.
func (s *Service) GetTagsByIDs(ctx context.Context, ids []int64) ([]model.Tag, error) {
	return s.tags.GetByIDs(ctx, ids)
}


================================================================================

================================================================================
Файл: internal/service/service.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/service.go
================================================================================

// Package service содержит бизнес-логику приложения (use cases).
// Сервисы принимают и возвращают доменные модели из пакета model.
// На сервисный слой опирается транспортный слой (GraphQL resolvers).
package service

import "errors"

// Бизнес-ошибки сервисного слоя.
var (
	// ErrWordNotFound возвращается, когда слово не найдено.
	ErrWordNotFound = errors.New("word not found")

	// ErrWordAlreadyExists возвращается при попытке создать дубликат слова.
	ErrWordAlreadyExists = errors.New("word already exists")

	// ErrMeaningNotFound возвращается, когда значение не найдено.
	ErrMeaningNotFound = errors.New("meaning not found")

	// ErrInvalidInput возвращается при невалидных входных данных.
	ErrInvalidInput = errors.New("invalid input")

	// ErrInvalidGrade возвращается при невалидной оценке (должна быть 1-5).
	ErrInvalidGrade = errors.New("grade must be between 1 and 5")
)


================================================================================

================================================================================
Файл: internal/service/study/interfaces.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/interfaces.go
================================================================================

package study

import (
	"context"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
)

// MeaningRepository определяет интерфейс для работы со значениями.
type MeaningRepository interface {
	GetByID(ctx context.Context, id int64) (model.Meaning, error)
	GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error)
	GetStats(ctx context.Context) (*model.Stats, error)
}

// MeaningSRSRepository определяет интерфейс для обновления SRS данных.
type MeaningSRSRepository interface {
	UpdateSRS(ctx context.Context, id int64, srs *SRSUpdate) error
}

// SRSUpdate содержит поля для обновления SRS данных.
type SRSUpdate struct {
	LearningStatus model.LearningStatus
	NextReviewAt   *time.Time
	Interval       *int
	EaseFactor     *float64
	ReviewCount    *int
}

// Clock — интерфейс для получения времени (для тестирования).
type Clock interface {
	Now() time.Time
}

// RealClock — реальная реализация Clock.
type RealClock struct{}

// Now возвращает текущее время.
func (RealClock) Now() time.Time {
	return time.Now()
}


================================================================================

================================================================================
Файл: internal/service/study/mocks_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/mocks_test.go
================================================================================

package study_test

import (
	"context"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/study"
)

// --- Mock Clock ---

type mockClock struct {
	now time.Time
}

func (c *mockClock) Now() time.Time {
	return c.now
}

// --- Mock Repositories ---

type mockMeaningRepository struct {
	GetByIDFunc       func(ctx context.Context, id int64) (model.Meaning, error)
	GetStudyQueueFunc func(ctx context.Context, limit int) ([]model.Meaning, error)
	GetStatsFunc      func(ctx context.Context) (*model.Stats, error)
}

func (m *mockMeaningRepository) GetByID(ctx context.Context, id int64) (model.Meaning, error) {
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(ctx, id)
	}
	return model.Meaning{}, nil
}

func (m *mockMeaningRepository) GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error) {
	if m.GetStudyQueueFunc != nil {
		return m.GetStudyQueueFunc(ctx, limit)
	}
	return []model.Meaning{}, nil
}

func (m *mockMeaningRepository) GetStats(ctx context.Context) (*model.Stats, error) {
	if m.GetStatsFunc != nil {
		return m.GetStatsFunc(ctx)
	}
	return &model.Stats{}, nil
}

type mockSRSRepository struct {
	UpdateSRSFunc func(ctx context.Context, id int64, srs *study.SRSUpdate) error
}

func (m *mockSRSRepository) UpdateSRS(ctx context.Context, id int64, srs *study.SRSUpdate) error {
	if m.UpdateSRSFunc != nil {
		return m.UpdateSRSFunc(ctx, id, srs)
	}
	return nil
}


================================================================================

================================================================================
Файл: internal/service/study/queue.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/queue.go
================================================================================

package study

import (
	"context"

	"github.com/heartmarshall/my-english/internal/model"
)

// GetStudyQueue возвращает очередь слов для изучения/повторения.
// Включает: новые слова (status=NEW) и слова для повторения (next_review_at < NOW).
func (s *Service) GetStudyQueue(ctx context.Context, limit int) ([]model.Meaning, error) {
	if limit <= 0 {
		limit = 10
	}
	if limit > 100 {
		limit = 100
	}

	return s.meanings.GetStudyQueue(ctx, limit)
}


================================================================================

================================================================================
Файл: internal/service/study/queue_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/queue_test.go
================================================================================

package study_test

import (
	"context"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/study"
)

func TestService_GetStudyQueue(t *testing.T) {
	ctx := context.Background()

	t.Run("returns queue", func(t *testing.T) {
		now := time.Now()

		meaningRepo := &mockMeaningRepository{
			GetStudyQueueFunc: func(ctx context.Context, limit int) ([]model.Meaning, error) {
				return []model.Meaning{
					{ID: 1, WordID: 1, TranslationRu: "привет", LearningStatus: model.LearningStatusNew},
					{ID: 2, WordID: 1, TranslationRu: "здравствуй", LearningStatus: model.LearningStatusLearning},
				}, nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: now},
		})

		queue, err := svc.GetStudyQueue(ctx, 10)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(queue) != 2 {
			t.Errorf("expected 2 meanings, got %d", len(queue))
		}
	})

	t.Run("respects limit", func(t *testing.T) {
		var capturedLimit int

		meaningRepo := &mockMeaningRepository{
			GetStudyQueueFunc: func(ctx context.Context, limit int) ([]model.Meaning, error) {
				capturedLimit = limit
				return []model.Meaning{}, nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		_, err := svc.GetStudyQueue(ctx, 5)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if capturedLimit != 5 {
			t.Errorf("expected limit=5, got %d", capturedLimit)
		}
	})
}


================================================================================

================================================================================
Файл: internal/service/study/review.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/review.go
================================================================================

package study

import (
	"context"
	"errors"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

// SM-2 Algorithm constants
// https://en.wikipedia.org/wiki/SuperMemo#Description_of_SM-2_algorithm
const (
	minEaseFactor     = 1.3
	defaultEaseFactor = 2.5
)

// ReviewMeaning обрабатывает оценку пользователя и обновляет SRS данные.
// grade: 1-5, где 1 = не помню, 5 = отлично помню
//
// Использует упрощённый алгоритм SM-2:
// - grade < 3: сбрасываем интервал, уменьшаем ease factor
// - grade >= 3: увеличиваем интервал, корректируем ease factor
func (s *Service) ReviewMeaning(ctx context.Context, meaningID int64, grade int) (model.Meaning, error) {
	// Валидация
	if grade < 1 || grade > 5 {
		return model.Meaning{}, service.ErrInvalidGrade
	}

	// Получаем текущее состояние
	meaning, err := s.meanings.GetByID(ctx, meaningID)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return model.Meaning{}, service.ErrMeaningNotFound
		}
		return model.Meaning{}, err
	}

	// Рассчитываем новые SRS параметры
	srsUpdate := s.calculateSRS(&meaning, grade)

	// Обновляем в БД
	if err := s.srs.UpdateSRS(ctx, meaningID, srsUpdate); err != nil {
		return model.Meaning{}, err
	}

	// Обновляем модель для возврата
	meaning.LearningStatus = srsUpdate.LearningStatus
	meaning.NextReviewAt = srsUpdate.NextReviewAt
	meaning.Interval = srsUpdate.Interval
	meaning.EaseFactor = srsUpdate.EaseFactor
	meaning.ReviewCount = srsUpdate.ReviewCount

	return meaning, nil
}

// calculateSRS рассчитывает новые SRS параметры на основе оценки.
func (s *Service) calculateSRS(meaning *model.Meaning, grade int) *SRSUpdate {
	now := s.clock.Now()

	// Текущие значения или дефолты
	currentInterval := 1
	if meaning.Interval != nil {
		currentInterval = *meaning.Interval
	}

	currentEase := defaultEaseFactor
	if meaning.EaseFactor != nil {
		currentEase = *meaning.EaseFactor
	}

	currentReviewCount := 0
	if meaning.ReviewCount != nil {
		currentReviewCount = *meaning.ReviewCount
	}

	var (
		newInterval int
		newEase     float64
		newStatus   model.LearningStatus
	)

	if grade < 3 {
		// Неудачный ответ — сбрасываем прогресс
		newInterval = 1
		newEase = max(minEaseFactor, currentEase-0.2)
		newStatus = model.LearningStatusLearning
	} else {
		// Успешный ответ — увеличиваем интервал
		if meaning.LearningStatus == model.LearningStatusNew {
			// Первое повторение нового слова
			newInterval = 1
		} else if currentInterval == 1 {
			newInterval = 6
		} else {
			newInterval = int(float64(currentInterval) * currentEase)
		}

		// Корректируем ease factor по формуле SM-2
		newEase = currentEase + (0.1 - float64(5-grade)*(0.08+float64(5-grade)*0.02))
		newEase = max(minEaseFactor, newEase)

		// Определяем статус
		if newInterval >= 21 {
			newStatus = model.LearningStatusMastered
		} else {
			newStatus = model.LearningStatusReview
		}
	}

	nextReview := now.Add(time.Duration(newInterval) * 24 * time.Hour)
	newReviewCount := currentReviewCount + 1

	return &SRSUpdate{
		LearningStatus: newStatus,
		NextReviewAt:   &nextReview,
		Interval:       &newInterval,
		EaseFactor:     &newEase,
		ReviewCount:    &newReviewCount,
	}
}


================================================================================

================================================================================
Файл: internal/service/study/review_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/review_test.go
================================================================================

package study_test

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/study"
)

func intPtr(i int) *int           { return &i }
func floatPtr(f float64) *float64 { return &f }

func TestService_ReviewMeaning(t *testing.T) {
	ctx := context.Background()

	t.Run("first review correct", func(t *testing.T) {
		now := time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)

		existingMeaning := model.Meaning{
			ID:             1,
			WordID:         1,
			TranslationRu:  "привет",
			LearningStatus: model.LearningStatusNew,
			EaseFactor:     floatPtr(2.5),
			Interval:       nil,
			ReviewCount:    nil,
		}

		var capturedUpdate *study.SRSUpdate

		meaningRepo := &mockMeaningRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Meaning, error) {
				if id == 1 {
					return existingMeaning, nil
				}
				return model.Meaning{}, database.ErrNotFound
			},
		}

		srsRepo := &mockSRSRepository{
			UpdateSRSFunc: func(ctx context.Context, id int64, srs *study.SRSUpdate) error {
				capturedUpdate = srs
				return nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      srsRepo,
			Clock:    &mockClock{now: now},
		})

		result, err := svc.ReviewMeaning(ctx, 1, 4) // grade = 4 (correct, easy)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Проверяем результат
		if result.ReviewCount == nil || *result.ReviewCount != 1 {
			t.Errorf("expected ReviewCount=1, got %v", result.ReviewCount)
		}
		// Первый ответ нового слова - интервал = 1
		if result.Interval == nil || *result.Interval != 1 {
			t.Errorf("expected Interval=1, got %v", result.Interval)
		}

		// Проверяем update
		if capturedUpdate == nil {
			t.Fatal("UpdateSRS was not called")
		}
		if capturedUpdate.Interval == nil || *capturedUpdate.Interval != 1 {
			t.Errorf("expected update Interval=1, got %v", capturedUpdate.Interval)
		}
	})

	t.Run("incorrect answer resets interval", func(t *testing.T) {
		now := time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)

		existingMeaning := model.Meaning{
			ID:             1,
			WordID:         1,
			TranslationRu:  "привет",
			LearningStatus: model.LearningStatusLearning,
			EaseFactor:     floatPtr(2.5),
			Interval:       intPtr(6),
			ReviewCount:    intPtr(3),
		}

		var capturedUpdate *study.SRSUpdate

		meaningRepo := &mockMeaningRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Meaning, error) {
				return existingMeaning, nil
			},
		}

		srsRepo := &mockSRSRepository{
			UpdateSRSFunc: func(ctx context.Context, id int64, srs *study.SRSUpdate) error {
				capturedUpdate = srs
				return nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      srsRepo,
			Clock:    &mockClock{now: now},
		})

		result, err := svc.ReviewMeaning(ctx, 1, 1) // grade = 1 (incorrect)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Ответ неправильный - интервал сбрасывается
		if result.Interval == nil || *result.Interval != 1 {
			t.Errorf("expected Interval=1 after incorrect, got %v", result.Interval)
		}
		// ReviewCount увеличивается
		if result.ReviewCount == nil || *result.ReviewCount != 4 {
			t.Errorf("expected ReviewCount=4, got %v", result.ReviewCount)
		}

		// Проверяем, что Easiness уменьшился
		if capturedUpdate.EaseFactor == nil || *capturedUpdate.EaseFactor >= 2.5 {
			t.Errorf("expected EaseFactor to decrease, got %v", capturedUpdate.EaseFactor)
		}
	})

	t.Run("meaning not found", func(t *testing.T) {
		meaningRepo := &mockMeaningRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Meaning, error) {
				return model.Meaning{}, database.ErrNotFound
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		_, err := svc.ReviewMeaning(ctx, 999, 4)

		if !errors.Is(err, service.ErrMeaningNotFound) {
			t.Errorf("expected ErrMeaningNotFound, got %v", err)
		}
	})

	t.Run("invalid grade too low", func(t *testing.T) {
		svc := study.New(study.Deps{
			Meanings: &mockMeaningRepository{},
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		_, err := svc.ReviewMeaning(ctx, 1, 0)

		if !errors.Is(err, service.ErrInvalidGrade) {
			t.Errorf("expected ErrInvalidGrade, got %v", err)
		}
	})

	t.Run("invalid grade too high", func(t *testing.T) {
		svc := study.New(study.Deps{
			Meanings: &mockMeaningRepository{},
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		_, err := svc.ReviewMeaning(ctx, 1, 6)

		if !errors.Is(err, service.ErrInvalidGrade) {
			t.Errorf("expected ErrInvalidGrade, got %v", err)
		}
	})

	t.Run("becomes mastered after long interval", func(t *testing.T) {
		now := time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)

		// Meaning уже в статусе Review с хорошим интервалом
		existingMeaning := model.Meaning{
			ID:             1,
			WordID:         1,
			TranslationRu:  "привет",
			LearningStatus: model.LearningStatusReview,
			EaseFactor:     floatPtr(2.5),
			Interval:       intPtr(15), // интервал 15 дней
			ReviewCount:    intPtr(5),
		}

		meaningRepo := &mockMeaningRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Meaning, error) {
				return existingMeaning, nil
			},
		}

		srsRepo := &mockSRSRepository{
			UpdateSRSFunc: func(ctx context.Context, id int64, srs *study.SRSUpdate) error {
				return nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      srsRepo,
			Clock:    &mockClock{now: now},
		})

		result, err := svc.ReviewMeaning(ctx, 1, 5) // perfect answer

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// После успешного ответа с большим интервалом (15*2.5=37) должен стать Mastered
		if result.LearningStatus != model.LearningStatusMastered {
			t.Errorf("expected status Mastered, got %v", result.LearningStatus)
		}
	})

	t.Run("correct answer increases interval", func(t *testing.T) {
		now := time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC)

		existingMeaning := model.Meaning{
			ID:             1,
			WordID:         1,
			TranslationRu:  "привет",
			LearningStatus: model.LearningStatusLearning,
			EaseFactor:     floatPtr(2.5),
			Interval:       intPtr(1),
			ReviewCount:    intPtr(1),
		}

		meaningRepo := &mockMeaningRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Meaning, error) {
				return existingMeaning, nil
			},
		}

		srsRepo := &mockSRSRepository{
			UpdateSRSFunc: func(ctx context.Context, id int64, srs *study.SRSUpdate) error {
				return nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      srsRepo,
			Clock:    &mockClock{now: now},
		})

		result, err := svc.ReviewMeaning(ctx, 1, 4)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// После второго правильного ответа интервал должен быть 6
		if result.Interval == nil || *result.Interval != 6 {
			t.Errorf("expected Interval=6, got %v", result.Interval)
		}
	})
}


================================================================================

================================================================================
Файл: internal/service/study/service.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/service.go
================================================================================

package study

// Service содержит бизнес-логику для изучения слов (SRS).
type Service struct {
	meanings MeaningRepository
	srs      MeaningSRSRepository
	clock    Clock
}

// Deps — зависимости для создания сервиса.
type Deps struct {
	Meanings MeaningRepository
	SRS      MeaningSRSRepository
	Clock    Clock // опционально, по умолчанию RealClock
}

// New создаёт новый сервис.
func New(deps Deps) *Service {
	clock := deps.Clock
	if clock == nil {
		clock = RealClock{}
	}

	return &Service{
		meanings: deps.Meanings,
		srs:      deps.SRS,
		clock:    clock,
	}
}


================================================================================

================================================================================
Файл: internal/service/study/stats.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/stats.go
================================================================================

package study

import (
	"context"

	"github.com/heartmarshall/my-english/internal/model"
)

// GetStats возвращает статистику изучения.
func (s *Service) GetStats(ctx context.Context) (*model.Stats, error) {
	return s.meanings.GetStats(ctx)
}


================================================================================

================================================================================
Файл: internal/service/study/stats_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/study/stats_test.go
================================================================================

package study_test

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/study"
)

func TestService_GetStats(t *testing.T) {
	ctx := context.Background()

	t.Run("returns stats", func(t *testing.T) {
		expectedStats := &model.Stats{
			TotalWords:        100,
			MasteredCount:     50,
			LearningCount:     30,
			DueForReviewCount: 20,
		}

		meaningRepo := &mockMeaningRepository{
			GetStatsFunc: func(ctx context.Context) (*model.Stats, error) {
				return expectedStats, nil
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		stats, err := svc.GetStats(ctx)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if stats.TotalWords != 100 {
			t.Errorf("expected TotalWords=100, got %d", stats.TotalWords)
		}
		if stats.MasteredCount != 50 {
			t.Errorf("expected MasteredCount=50, got %d", stats.MasteredCount)
		}
	})

	t.Run("propagates error", func(t *testing.T) {
		expectedErr := errors.New("database error")
		meaningRepo := &mockMeaningRepository{
			GetStatsFunc: func(ctx context.Context) (*model.Stats, error) {
				return nil, expectedErr
			},
		}

		svc := study.New(study.Deps{
			Meanings: meaningRepo,
			SRS:      &mockSRSRepository{},
			Clock:    &mockClock{now: time.Now()},
		})

		_, err := svc.GetStats(ctx)

		if !errors.Is(err, expectedErr) {
			t.Errorf("expected error to be propagated, got %v", err)
		}
	})
}


================================================================================

================================================================================
Файл: internal/service/word/create.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/create.go
================================================================================

package word

import (
	"context"
	"errors"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

// Create создаёт новое слово со всеми связанными данными.
// Все операции выполняются в транзакции.
func (s *Service) Create(ctx context.Context, input CreateWordInput) (*WordWithRelations, error) {
	// Валидация
	text := strings.TrimSpace(strings.ToLower(input.Text))
	if text == "" {
		return nil, service.ErrInvalidInput
	}

	if len(input.Meanings) == 0 {
		return nil, service.ErrInvalidInput
	}

	// Проверяем, не существует ли слово (вне транзакции для быстрого отклонения)
	_, err := s.words.GetByText(ctx, text)
	if err == nil {
		return nil, service.ErrWordAlreadyExists
	}
	if !errors.Is(err, database.ErrNotFound) {
		return nil, err
	}

	var result *WordWithRelations

	// Выполняем создание в транзакции
	err = s.txRunner.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		txRepos := s.withTx(tx)

		// Создаём слово
		word := &model.Word{
			Text:          text,
			Transcription: input.Transcription,
			AudioURL:      input.AudioURL,
		}

		if err := txRepos.words.Create(ctx, word); err != nil {
			if errors.Is(err, database.ErrDuplicate) {
				return service.ErrWordAlreadyExists
			}
			return err
		}

		// Создаём meanings с примерами и тегами
		result = &WordWithRelations{
			Word:     *word,
			Meanings: make([]MeaningWithRelations, 0, len(input.Meanings)),
		}

		for _, meaningInput := range input.Meanings {
			mr, err := s.createMeaningTx(ctx, txRepos, word.ID, meaningInput)
			if err != nil {
				return err
			}
			result.Meanings = append(result.Meanings, *mr)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}

// createMeaningTx создаёт meaning с примерами и тегами в рамках транзакции.
func (s *Service) createMeaningTx(ctx context.Context, r *repos, wordID int64, input CreateMeaningInput) (*MeaningWithRelations, error) {
	if input.TranslationRu == "" {
		return nil, service.ErrInvalidInput
	}

	// Создаём meaning
	meaning := &model.Meaning{
		WordID:        wordID,
		PartOfSpeech:  input.PartOfSpeech,
		DefinitionEn:  input.DefinitionEn,
		TranslationRu: input.TranslationRu,
		CefrLevel:     input.CefrLevel,
		ImageURL:      input.ImageURL,
	}

	if err := r.meanings.Create(ctx, meaning); err != nil {
		return nil, err
	}

	result := MeaningWithRelations{
		Meaning:  *meaning,
		Examples: make([]model.Example, 0),
		Tags:     make([]model.Tag, 0),
	}

	// Создаём примеры
	if len(input.Examples) > 0 {
		examples := make([]*model.Example, 0, len(input.Examples))
		for _, exInput := range input.Examples {
			if exInput.SentenceEn == "" {
				continue
			}
			examples = append(examples, &model.Example{
				MeaningID:  meaning.ID,
				SentenceEn: exInput.SentenceEn,
				SentenceRu: exInput.SentenceRu,
				SourceName: exInput.SourceName,
			})
		}

		if len(examples) > 0 {
			if err := r.examples.CreateBatch(ctx, examples); err != nil {
				return nil, err
			}
			result.Examples = make([]model.Example, len(examples))
			for i, ex := range examples {
				result.Examples[i] = *ex
			}
		}
	}

	// Создаём/получаем теги и привязываем
	if len(input.Tags) > 0 {
		tagIDs := make([]int64, 0, len(input.Tags))
		tags := make([]model.Tag, 0, len(input.Tags))

		for _, tagName := range input.Tags {
			tag, err := r.tags.GetOrCreate(ctx, tagName)
			if err != nil {
				return nil, err
			}
			tagIDs = append(tagIDs, tag.ID)
			tags = append(tags, tag)
		}

		if err := r.meaningTag.AttachTags(ctx, meaning.ID, tagIDs); err != nil {
			return nil, err
		}
		result.Tags = tags
	}

	return &result, nil
}


================================================================================

================================================================================
Файл: internal/service/word/create_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/create_test.go
================================================================================

package word_test

import (
	"context"
	"errors"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/word"
)

func TestService_Create(t *testing.T) {
	ctx := context.Background()

	t.Run("success with all data", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			GetByTextFunc: func(ctx context.Context, text string) (model.Word, error) {
				return model.Word{}, database.ErrNotFound
			},
			CreateFunc: func(ctx context.Context, w *model.Word) error {
				w.ID = 1
				return nil
			},
		}

		meaningRepo := &mockMeaningRepository{
			CreateFunc: func(ctx context.Context, m *model.Meaning) error {
				m.ID = 1
				return nil
			},
		}

		exampleRepo := &mockExampleRepository{}
		tagRepo := &mockTagRepository{}
		meaningTagRepo := &mockMeaningTagRepository{}

		txRunner := &mockTxRunner{}
		repoFactory := &mockRepositoryFactory{
			wordRepo:       wordRepo,
			meaningRepo:    meaningRepo,
			exampleRepo:    exampleRepo,
			tagRepo:        tagRepo,
			meaningTagRepo: meaningTagRepo,
		}

		svc := word.New(word.Deps{
			Words:       wordRepo,
			Meanings:    meaningRepo,
			Examples:    exampleRepo,
			Tags:        tagRepo,
			MeaningTag:  meaningTagRepo,
			TxRunner:    txRunner,
			RepoFactory: repoFactory,
		})

		input := word.CreateWordInput{
			Text:          "Hello",
			Transcription: ptr("həˈloʊ"),
			Meanings: []word.CreateMeaningInput{
				{
					PartOfSpeech:  model.PartOfSpeechNoun,
					TranslationRu: "привет",
					Examples: []word.CreateExampleInput{
						{SentenceEn: "Hello, world!"},
					},
					Tags: []string{"greetings"},
				},
			},
		}

		result, err := svc.Create(ctx, input)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if result.Word.ID != 1 {
			t.Errorf("expected word ID=1, got %d", result.Word.ID)
		}
		if result.Word.Text != "hello" {
			t.Errorf("expected text='hello', got %q", result.Word.Text)
		}
		if len(result.Meanings) != 1 {
			t.Errorf("expected 1 meaning, got %d", len(result.Meanings))
		}
	})

	t.Run("empty text", func(t *testing.T) {
		svc := word.New(word.Deps{
			Words:      &mockWordRepository{},
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		input := word.CreateWordInput{
			Text:     "   ",
			Meanings: []word.CreateMeaningInput{{TranslationRu: "тест"}},
		}

		_, err := svc.Create(ctx, input)

		if !errors.Is(err, service.ErrInvalidInput) {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("no meanings", func(t *testing.T) {
		svc := word.New(word.Deps{
			Words:      &mockWordRepository{},
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		input := word.CreateWordInput{
			Text:     "hello",
			Meanings: []word.CreateMeaningInput{},
		}

		_, err := svc.Create(ctx, input)

		if !errors.Is(err, service.ErrInvalidInput) {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})

	t.Run("word already exists", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			GetByTextFunc: func(ctx context.Context, text string) (model.Word, error) {
				return model.Word{ID: 1, Text: "hello"}, nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		input := word.CreateWordInput{
			Text:     "hello",
			Meanings: []word.CreateMeaningInput{{TranslationRu: "привет"}},
		}

		_, err := svc.Create(ctx, input)

		if !errors.Is(err, service.ErrWordAlreadyExists) {
			t.Errorf("expected ErrWordAlreadyExists, got %v", err)
		}
	})

	t.Run("meaning without translation", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			GetByTextFunc: func(ctx context.Context, text string) (model.Word, error) {
				return model.Word{}, database.ErrNotFound
			},
			CreateFunc: func(ctx context.Context, w *model.Word) error {
				w.ID = 1
				return nil
			},
		}

		meaningRepo := &mockMeaningRepository{}
		exampleRepo := &mockExampleRepository{}
		tagRepo := &mockTagRepository{}
		meaningTagRepo := &mockMeaningTagRepository{}

		txRunner := &mockTxRunner{}
		repoFactory := &mockRepositoryFactory{
			wordRepo:       wordRepo,
			meaningRepo:    meaningRepo,
			exampleRepo:    exampleRepo,
			tagRepo:        tagRepo,
			meaningTagRepo: meaningTagRepo,
		}

		svc := word.New(word.Deps{
			Words:       wordRepo,
			Meanings:    meaningRepo,
			Examples:    exampleRepo,
			Tags:        tagRepo,
			MeaningTag:  meaningTagRepo,
			TxRunner:    txRunner,
			RepoFactory: repoFactory,
		})

		input := word.CreateWordInput{
			Text: "hello",
			Meanings: []word.CreateMeaningInput{
				{PartOfSpeech: model.PartOfSpeechNoun, TranslationRu: ""},
			},
		}

		_, err := svc.Create(ctx, input)

		if !errors.Is(err, service.ErrInvalidInput) {
			t.Errorf("expected ErrInvalidInput, got %v", err)
		}
	})
}

func ptr(s string) *string {
	return &s
}


================================================================================

================================================================================
Файл: internal/service/word/delete.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/delete.go
================================================================================

package word

import (
	"context"
	"errors"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/service"
)

// Delete удаляет слово и все связанные данные.
// Связанные данные удаляются каскадно на уровне БД.
func (s *Service) Delete(ctx context.Context, id int64) error {
	err := s.words.Delete(ctx, id)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return service.ErrWordNotFound
		}
		return err
	}

	return nil
}


================================================================================

================================================================================
Файл: internal/service/word/delete_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/delete_test.go
================================================================================

package word_test

import (
	"context"
	"errors"
	"testing"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/word"
)

func TestService_Delete(t *testing.T) {
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		deleted := false
		wordRepo := &mockWordRepository{
			DeleteFunc: func(ctx context.Context, id int64) error {
				deleted = true
				return nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		err := svc.Delete(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !deleted {
			t.Error("word was not deleted")
		}
	})

	t.Run("not found", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			DeleteFunc: func(ctx context.Context, id int64) error {
				return database.ErrNotFound
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		err := svc.Delete(ctx, 999)

		if !errors.Is(err, service.ErrWordNotFound) {
			t.Errorf("expected ErrWordNotFound, got %v", err)
		}
	})
}


================================================================================

================================================================================
Файл: internal/service/word/dto.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/dto.go
================================================================================

package word

import "github.com/heartmarshall/my-english/internal/model"

// CreateWordInput — входные данные для создания слова.
type CreateWordInput struct {
	Text          string
	Transcription *string
	AudioURL      *string
	Meanings      []CreateMeaningInput
}

// CreateMeaningInput — входные данные для создания значения.
type CreateMeaningInput struct {
	PartOfSpeech  model.PartOfSpeech
	DefinitionEn  *string
	TranslationRu string
	CefrLevel     *string
	ImageURL      *string
	Examples      []CreateExampleInput
	Tags          []string // Имена тегов, не ID
}

// CreateExampleInput — входные данные для создания примера.
type CreateExampleInput struct {
	SentenceEn string
	SentenceRu *string
	SourceName *model.ExampleSource
}

// UpdateWordInput — входные данные для обновления слова.
type UpdateWordInput struct {
	Text          string
	Transcription *string
	AudioURL      *string
	Meanings      []UpdateMeaningInput
}

// UpdateMeaningInput — входные данные для обновления значения.
type UpdateMeaningInput struct {
	ID            *int64 // Если nil — создаём новое, иначе обновляем
	PartOfSpeech  model.PartOfSpeech
	DefinitionEn  *string
	TranslationRu string
	CefrLevel     *string
	ImageURL      *string
	Examples      []CreateExampleInput // Примеры пересоздаются полностью
	Tags          []string
}

// WordFilter — параметры фильтрации для списка слов.
type WordFilter struct {
	Search *string
	// Дополнительные фильтры можно добавить позже
}

// WordWithRelations — слово со всеми связанными данными.
type WordWithRelations struct {
	Word     model.Word
	Meanings []MeaningWithRelations
}

// MeaningWithRelations — значение со всеми связанными данными.
type MeaningWithRelations struct {
	Meaning  model.Meaning
	Examples []model.Example
	Tags     []model.Tag
}


================================================================================

================================================================================
Файл: internal/service/word/interfaces.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/interfaces.go
================================================================================

package word

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
)

// WordRepository определяет интерфейс для работы со словами.
// Интерфейс определён здесь (у потребителя) согласно Go idiom.
type WordRepository interface {
	Create(ctx context.Context, word *model.Word) error
	GetByID(ctx context.Context, id int64) (model.Word, error)
	GetByText(ctx context.Context, text string) (model.Word, error)
	List(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error)
	Count(ctx context.Context, filter *model.WordFilter) (int, error)
	Update(ctx context.Context, word *model.Word) error
	Delete(ctx context.Context, id int64) error
}

// MeaningRepository определяет интерфейс для работы со значениями.
type MeaningRepository interface {
	Create(ctx context.Context, meaning *model.Meaning) error
	GetByID(ctx context.Context, id int64) (model.Meaning, error)
	GetByWordID(ctx context.Context, wordID int64) ([]model.Meaning, error)
	Update(ctx context.Context, meaning *model.Meaning) error
	Delete(ctx context.Context, id int64) error
	DeleteByWordID(ctx context.Context, wordID int64) (int64, error)
}

// ExampleRepository определяет интерфейс для работы с примерами.
type ExampleRepository interface {
	Create(ctx context.Context, example *model.Example) error
	CreateBatch(ctx context.Context, examples []*model.Example) error
	GetByMeaningID(ctx context.Context, meaningID int64) ([]model.Example, error)
	GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error)
	DeleteByMeaningID(ctx context.Context, meaningID int64) (int64, error)
}

// TagRepository определяет интерфейс для работы с тегами.
type TagRepository interface {
	GetByName(ctx context.Context, name string) (model.Tag, error)
	GetByNames(ctx context.Context, names []string) ([]model.Tag, error)
	GetByIDs(ctx context.Context, ids []int64) ([]model.Tag, error)
	GetOrCreate(ctx context.Context, name string) (model.Tag, error)
}

// MeaningTagRepository определяет интерфейс для связи meaning-tag.
type MeaningTagRepository interface {
	AttachTags(ctx context.Context, meaningID int64, tagIDs []int64) error
	GetTagIDsByMeaningID(ctx context.Context, meaningID int64) ([]int64, error)
	GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error)
	SyncTags(ctx context.Context, meaningID int64, tagIDs []int64) error
	DetachAllFromMeaning(ctx context.Context, meaningID int64) error
}

// RepositoryFactory создаёт репозитории с указанным Querier.
// Используется для работы в транзакциях.
type RepositoryFactory interface {
	Words(q database.Querier) WordRepository
	Meanings(q database.Querier) MeaningRepository
	Examples(q database.Querier) ExampleRepository
	Tags(q database.Querier) TagRepository
	MeaningTags(q database.Querier) MeaningTagRepository
}

// TxRunner определяет интерфейс для запуска транзакций.
type TxRunner interface {
	// RunInTx выполняет функцию в рамках транзакции.
	// Querier передаётся в функцию для создания репозиториев.
	RunInTx(ctx context.Context, fn func(ctx context.Context, tx database.Querier) error) error
}


================================================================================

================================================================================
Файл: internal/service/word/mocks_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/mocks_test.go
================================================================================

package word_test

import (
	"context"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service/word"
)

// --- Mock implementations ---

// mockTxRunner выполняет функцию без реальной транзакции.
type mockTxRunner struct {
	RunInTxFunc func(ctx context.Context, fn func(ctx context.Context, tx database.Querier) error) error
}

func (m *mockTxRunner) RunInTx(ctx context.Context, fn func(ctx context.Context, tx database.Querier) error) error {
	if m.RunInTxFunc != nil {
		return m.RunInTxFunc(ctx, fn)
	}
	// По умолчанию просто вызываем функцию с nil querier
	return fn(ctx, nil)
}

// mockRepositoryFactory создаёт mock репозитории.
type mockRepositoryFactory struct {
	wordRepo       word.WordRepository
	meaningRepo    word.MeaningRepository
	exampleRepo    word.ExampleRepository
	tagRepo        word.TagRepository
	meaningTagRepo word.MeaningTagRepository
}

func (f *mockRepositoryFactory) Words(_ database.Querier) word.WordRepository {
	return f.wordRepo
}

func (f *mockRepositoryFactory) Meanings(_ database.Querier) word.MeaningRepository {
	return f.meaningRepo
}

func (f *mockRepositoryFactory) Examples(_ database.Querier) word.ExampleRepository {
	return f.exampleRepo
}

func (f *mockRepositoryFactory) Tags(_ database.Querier) word.TagRepository {
	return f.tagRepo
}

func (f *mockRepositoryFactory) MeaningTags(_ database.Querier) word.MeaningTagRepository {
	return f.meaningTagRepo
}

type mockWordRepository struct {
	CreateFunc    func(ctx context.Context, word *model.Word) error
	GetByIDFunc   func(ctx context.Context, id int64) (model.Word, error)
	GetByTextFunc func(ctx context.Context, text string) (model.Word, error)
	ListFunc      func(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error)
	CountFunc     func(ctx context.Context, filter *model.WordFilter) (int, error)
	UpdateFunc    func(ctx context.Context, word *model.Word) error
	DeleteFunc    func(ctx context.Context, id int64) error
}

func (m *mockWordRepository) Create(ctx context.Context, word *model.Word) error {
	if m.CreateFunc != nil {
		return m.CreateFunc(ctx, word)
	}
	return nil
}

func (m *mockWordRepository) GetByID(ctx context.Context, id int64) (model.Word, error) {
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(ctx, id)
	}
	return model.Word{}, nil
}

func (m *mockWordRepository) GetByText(ctx context.Context, text string) (model.Word, error) {
	if m.GetByTextFunc != nil {
		return m.GetByTextFunc(ctx, text)
	}
	return model.Word{}, nil
}

func (m *mockWordRepository) List(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error) {
	if m.ListFunc != nil {
		return m.ListFunc(ctx, filter, limit, offset)
	}
	return nil, nil
}

func (m *mockWordRepository) Count(ctx context.Context, filter *model.WordFilter) (int, error) {
	if m.CountFunc != nil {
		return m.CountFunc(ctx, filter)
	}
	return 0, nil
}

func (m *mockWordRepository) Update(ctx context.Context, word *model.Word) error {
	if m.UpdateFunc != nil {
		return m.UpdateFunc(ctx, word)
	}
	return nil
}

func (m *mockWordRepository) Delete(ctx context.Context, id int64) error {
	if m.DeleteFunc != nil {
		return m.DeleteFunc(ctx, id)
	}
	return nil
}

type mockMeaningRepository struct {
	CreateFunc         func(ctx context.Context, meaning *model.Meaning) error
	GetByIDFunc        func(ctx context.Context, id int64) (model.Meaning, error)
	GetByWordIDFunc    func(ctx context.Context, wordID int64) ([]model.Meaning, error)
	UpdateFunc         func(ctx context.Context, meaning *model.Meaning) error
	DeleteFunc         func(ctx context.Context, id int64) error
	DeleteByWordIDFunc func(ctx context.Context, wordID int64) (int64, error)
}

func (m *mockMeaningRepository) Create(ctx context.Context, meaning *model.Meaning) error {
	if m.CreateFunc != nil {
		return m.CreateFunc(ctx, meaning)
	}
	meaning.ID = 1
	return nil
}

func (m *mockMeaningRepository) GetByID(ctx context.Context, id int64) (model.Meaning, error) {
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(ctx, id)
	}
	return model.Meaning{}, nil
}

func (m *mockMeaningRepository) GetByWordID(ctx context.Context, wordID int64) ([]model.Meaning, error) {
	if m.GetByWordIDFunc != nil {
		return m.GetByWordIDFunc(ctx, wordID)
	}
	return []model.Meaning{}, nil
}

func (m *mockMeaningRepository) Update(ctx context.Context, meaning *model.Meaning) error {
	if m.UpdateFunc != nil {
		return m.UpdateFunc(ctx, meaning)
	}
	return nil
}

func (m *mockMeaningRepository) Delete(ctx context.Context, id int64) error {
	if m.DeleteFunc != nil {
		return m.DeleteFunc(ctx, id)
	}
	return nil
}

func (m *mockMeaningRepository) DeleteByWordID(ctx context.Context, wordID int64) (int64, error) {
	if m.DeleteByWordIDFunc != nil {
		return m.DeleteByWordIDFunc(ctx, wordID)
	}
	return 0, nil
}

type mockExampleRepository struct {
	CreateFunc            func(ctx context.Context, example *model.Example) error
	CreateBatchFunc       func(ctx context.Context, examples []*model.Example) error
	GetByMeaningIDFunc    func(ctx context.Context, meaningID int64) ([]model.Example, error)
	GetByMeaningIDsFunc   func(ctx context.Context, meaningIDs []int64) ([]model.Example, error)
	DeleteByMeaningIDFunc func(ctx context.Context, meaningID int64) (int64, error)
}

func (m *mockExampleRepository) Create(ctx context.Context, example *model.Example) error {
	if m.CreateFunc != nil {
		return m.CreateFunc(ctx, example)
	}
	return nil
}

func (m *mockExampleRepository) CreateBatch(ctx context.Context, examples []*model.Example) error {
	if m.CreateBatchFunc != nil {
		return m.CreateBatchFunc(ctx, examples)
	}
	for i := range examples {
		examples[i].ID = int64(i + 1)
	}
	return nil
}

func (m *mockExampleRepository) GetByMeaningID(ctx context.Context, meaningID int64) ([]model.Example, error) {
	if m.GetByMeaningIDFunc != nil {
		return m.GetByMeaningIDFunc(ctx, meaningID)
	}
	return []model.Example{}, nil
}

func (m *mockExampleRepository) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.Example, error) {
	if m.GetByMeaningIDsFunc != nil {
		return m.GetByMeaningIDsFunc(ctx, meaningIDs)
	}
	return []model.Example{}, nil
}

func (m *mockExampleRepository) DeleteByMeaningID(ctx context.Context, meaningID int64) (int64, error) {
	if m.DeleteByMeaningIDFunc != nil {
		return m.DeleteByMeaningIDFunc(ctx, meaningID)
	}
	return 0, nil
}

type mockTagRepository struct {
	GetByNameFunc   func(ctx context.Context, name string) (model.Tag, error)
	GetByNamesFunc  func(ctx context.Context, names []string) ([]model.Tag, error)
	GetByIDsFunc    func(ctx context.Context, ids []int64) ([]model.Tag, error)
	GetOrCreateFunc func(ctx context.Context, name string) (model.Tag, error)
}

func (m *mockTagRepository) GetByName(ctx context.Context, name string) (model.Tag, error) {
	if m.GetByNameFunc != nil {
		return m.GetByNameFunc(ctx, name)
	}
	return model.Tag{}, nil
}

func (m *mockTagRepository) GetByNames(ctx context.Context, names []string) ([]model.Tag, error) {
	if m.GetByNamesFunc != nil {
		return m.GetByNamesFunc(ctx, names)
	}
	return []model.Tag{}, nil
}

func (m *mockTagRepository) GetByIDs(ctx context.Context, ids []int64) ([]model.Tag, error) {
	if m.GetByIDsFunc != nil {
		return m.GetByIDsFunc(ctx, ids)
	}
	return []model.Tag{}, nil
}

func (m *mockTagRepository) GetOrCreate(ctx context.Context, name string) (model.Tag, error) {
	if m.GetOrCreateFunc != nil {
		return m.GetOrCreateFunc(ctx, name)
	}
	return model.Tag{ID: 1, Name: name}, nil
}

type mockMeaningTagRepository struct {
	AttachTagsFunc           func(ctx context.Context, meaningID int64, tagIDs []int64) error
	GetTagIDsByMeaningIDFunc func(ctx context.Context, meaningID int64) ([]int64, error)
	GetByMeaningIDsFunc      func(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error)
	SyncTagsFunc             func(ctx context.Context, meaningID int64, tagIDs []int64) error
	DetachAllFromMeaningFunc func(ctx context.Context, meaningID int64) error
}

func (m *mockMeaningTagRepository) AttachTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	if m.AttachTagsFunc != nil {
		return m.AttachTagsFunc(ctx, meaningID, tagIDs)
	}
	return nil
}

func (m *mockMeaningTagRepository) GetTagIDsByMeaningID(ctx context.Context, meaningID int64) ([]int64, error) {
	if m.GetTagIDsByMeaningIDFunc != nil {
		return m.GetTagIDsByMeaningIDFunc(ctx, meaningID)
	}
	return []int64{}, nil
}

func (m *mockMeaningTagRepository) GetByMeaningIDs(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error) {
	if m.GetByMeaningIDsFunc != nil {
		return m.GetByMeaningIDsFunc(ctx, meaningIDs)
	}
	return []model.MeaningTag{}, nil
}

func (m *mockMeaningTagRepository) SyncTags(ctx context.Context, meaningID int64, tagIDs []int64) error {
	if m.SyncTagsFunc != nil {
		return m.SyncTagsFunc(ctx, meaningID, tagIDs)
	}
	return nil
}

func (m *mockMeaningTagRepository) DetachAllFromMeaning(ctx context.Context, meaningID int64) error {
	if m.DetachAllFromMeaningFunc != nil {
		return m.DetachAllFromMeaningFunc(ctx, meaningID)
	}
	return nil
}


================================================================================

================================================================================
Файл: internal/service/word/query.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/query.go
================================================================================

package word

import (
	"context"
	"errors"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

// GetByID возвращает слово по ID со всеми связанными данными.
func (s *Service) GetByID(ctx context.Context, id int64) (*WordWithRelations, error) {
	word, err := s.words.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, service.ErrWordNotFound
		}
		return nil, err
	}

	return s.loadRelations(ctx, word)
}

// GetByText возвращает слово по тексту со всеми связанными данными.
func (s *Service) GetByText(ctx context.Context, text string) (*WordWithRelations, error) {
	word, err := s.words.GetByText(ctx, text)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, service.ErrWordNotFound
		}
		return nil, err
	}

	return s.loadRelations(ctx, word)
}

// List возвращает список слов с пагинацией.
// Возвращает слова без связанных данных (для списка).
func (s *Service) List(ctx context.Context, filter *WordFilter, limit, offset int) ([]model.Word, error) {
	var modelFilter *model.WordFilter
	if filter != nil {
		modelFilter = &model.WordFilter{
			Search: filter.Search,
		}
	}

	return s.words.List(ctx, modelFilter, limit, offset)
}

// Count возвращает количество слов, соответствующих фильтру.
func (s *Service) Count(ctx context.Context, filter *WordFilter) (int, error) {
	var modelFilter *model.WordFilter
	if filter != nil {
		modelFilter = &model.WordFilter{
			Search: filter.Search,
		}
	}

	return s.words.Count(ctx, modelFilter)
}

// loadRelations загружает связанные данные для слова.
func (s *Service) loadRelations(ctx context.Context, word model.Word) (*WordWithRelations, error) {
	meanings, err := s.meanings.GetByWordID(ctx, word.ID)
	if err != nil {
		return nil, err
	}

	result := &WordWithRelations{
		Word:     word,
		Meanings: make([]MeaningWithRelations, 0, len(meanings)),
	}

	if len(meanings) == 0 {
		return result, nil
	}

	// Собираем ID meanings для batch loading
	meaningIDs := make([]int64, len(meanings))
	for i, m := range meanings {
		meaningIDs[i] = m.ID
	}

	// Загружаем примеры для всех meanings
	examples, err := s.examples.GetByMeaningIDs(ctx, meaningIDs)
	if err != nil {
		return nil, err
	}

	// Загружаем связи meaning-tag
	meaningTags, err := s.meaningTag.GetByMeaningIDs(ctx, meaningIDs)
	if err != nil {
		return nil, err
	}

	// Собираем уникальные tag IDs
	tagIDSet := make(map[int64]struct{})
	for _, mt := range meaningTags {
		tagIDSet[mt.TagID] = struct{}{}
	}

	tagIDs := make([]int64, 0, len(tagIDSet))
	for id := range tagIDSet {
		tagIDs = append(tagIDs, id)
	}

	// Загружаем теги
	var tags []model.Tag
	if len(tagIDs) > 0 {
		tags, err = s.tags.GetByIDs(ctx, tagIDs)
		if err != nil {
			return nil, err
		}
	}

	// Создаём мапы для быстрого доступа
	examplesByMeaning := make(map[int64][]model.Example)
	for _, ex := range examples {
		examplesByMeaning[ex.MeaningID] = append(examplesByMeaning[ex.MeaningID], ex)
	}

	tagsByID := make(map[int64]model.Tag)
	for _, t := range tags {
		tagsByID[t.ID] = t
	}

	tagIDsByMeaning := make(map[int64][]int64)
	for _, mt := range meaningTags {
		tagIDsByMeaning[mt.MeaningID] = append(tagIDsByMeaning[mt.MeaningID], mt.TagID)
	}

	// Собираем результат
	for _, m := range meanings {
		mr := MeaningWithRelations{
			Meaning:  m,
			Examples: examplesByMeaning[m.ID],
			Tags:     make([]model.Tag, 0),
		}

		if mr.Examples == nil {
			mr.Examples = make([]model.Example, 0)
		}

		for _, tagID := range tagIDsByMeaning[m.ID] {
			if tag, ok := tagsByID[tagID]; ok {
				mr.Tags = append(mr.Tags, tag)
			}
		}

		result.Meanings = append(result.Meanings, mr)
	}

	return result, nil
}

// LoadMeaningsForWords загружает meanings для списка слов (для batch loading в GraphQL).
func (s *Service) LoadMeaningsForWords(ctx context.Context, wordIDs []int64) (map[int64][]model.Meaning, error) {
	result := make(map[int64][]model.Meaning)

	for _, wordID := range wordIDs {
		meanings, err := s.meanings.GetByWordID(ctx, wordID)
		if err != nil {
			return nil, err
		}
		result[wordID] = meanings
	}

	return result, nil
}


================================================================================

================================================================================
Файл: internal/service/word/query_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/query_test.go
================================================================================

package word_test

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/word"
)

func TestService_GetByID(t *testing.T) {
	ctx := context.Background()

	t.Run("found with relations", func(t *testing.T) {
		now := time.Now()
		testWord := model.Word{ID: 1, Text: "hello", CreatedAt: now}
		testMeaning := model.Meaning{ID: 1, WordID: 1, TranslationRu: "привет"}
		testExample := model.Example{ID: 1, MeaningID: 1, SentenceEn: "Hello!"}
		testTag := model.Tag{ID: 1, Name: "greetings"}

		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				if id == 1 {
					return testWord, nil
				}
				return model.Word{}, database.ErrNotFound
			},
		}

		meaningRepo := &mockMeaningRepository{
			GetByWordIDFunc: func(ctx context.Context, wordID int64) ([]model.Meaning, error) {
				return []model.Meaning{testMeaning}, nil
			},
		}

		exampleRepo := &mockExampleRepository{
			GetByMeaningIDsFunc: func(ctx context.Context, meaningIDs []int64) ([]model.Example, error) {
				return []model.Example{testExample}, nil
			},
		}

		tagRepo := &mockTagRepository{
			GetByIDsFunc: func(ctx context.Context, ids []int64) ([]model.Tag, error) {
				return []model.Tag{testTag}, nil
			},
		}

		meaningTagRepo := &mockMeaningTagRepository{
			GetByMeaningIDsFunc: func(ctx context.Context, meaningIDs []int64) ([]model.MeaningTag, error) {
				return []model.MeaningTag{{MeaningID: 1, TagID: 1}}, nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   meaningRepo,
			Examples:   exampleRepo,
			Tags:       tagRepo,
			MeaningTag: meaningTagRepo,
		})

		result, err := svc.GetByID(ctx, 1)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if result.Word.Text != "hello" {
			t.Errorf("expected text='hello', got %q", result.Word.Text)
		}
		if len(result.Meanings) != 1 {
			t.Fatalf("expected 1 meaning, got %d", len(result.Meanings))
		}
		if len(result.Meanings[0].Examples) != 1 {
			t.Errorf("expected 1 example, got %d", len(result.Meanings[0].Examples))
		}
		if len(result.Meanings[0].Tags) != 1 {
			t.Errorf("expected 1 tag, got %d", len(result.Meanings[0].Tags))
		}
	})

	t.Run("not found", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				return model.Word{}, database.ErrNotFound
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		_, err := svc.GetByID(ctx, 999)

		if !errors.Is(err, service.ErrWordNotFound) {
			t.Errorf("expected ErrWordNotFound, got %v", err)
		}
	})
}

func TestService_List(t *testing.T) {
	ctx := context.Background()

	t.Run("returns words", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			ListFunc: func(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error) {
				return []model.Word{
					{ID: 1, Text: "hello"},
					{ID: 2, Text: "world"},
				}, nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		words, err := svc.List(ctx, nil, 20, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(words) != 2 {
			t.Errorf("expected 2 words, got %d", len(words))
		}
	})

	t.Run("with filter", func(t *testing.T) {
		var capturedFilter *model.WordFilter

		wordRepo := &mockWordRepository{
			ListFunc: func(ctx context.Context, filter *model.WordFilter, limit, offset int) ([]model.Word, error) {
				capturedFilter = filter
				return []model.Word{}, nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		search := "hel"
		filter := &word.WordFilter{Search: &search}

		_, err := svc.List(ctx, filter, 10, 0)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if capturedFilter == nil {
			t.Fatal("filter was not passed to repository")
		}
		if capturedFilter.Search == nil || *capturedFilter.Search != "hel" {
			t.Error("search filter was not passed correctly")
		}
	})
}

func TestService_Count(t *testing.T) {
	ctx := context.Background()

	t.Run("returns count", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			CountFunc: func(ctx context.Context, filter *model.WordFilter) (int, error) {
				return 42, nil
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		count, err := svc.Count(ctx, nil)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if count != 42 {
			t.Errorf("expected count=42, got %d", count)
		}
	})
}


================================================================================

================================================================================
Файл: internal/service/word/repos.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/repos.go
================================================================================

package word

import "github.com/heartmarshall/my-english/internal/database"

// repos — набор репозиториев для работы в транзакции.
type repos struct {
	words      WordRepository
	meanings   MeaningRepository
	examples   ExampleRepository
	tags       TagRepository
	meaningTag MeaningTagRepository
}

// withTx создаёт набор репозиториев, работающих в транзакции.
func (s *Service) withTx(tx database.Querier) *repos {
	return &repos{
		words:      s.repoFactory.Words(tx),
		meanings:   s.repoFactory.Meanings(tx),
		examples:   s.repoFactory.Examples(tx),
		tags:       s.repoFactory.Tags(tx),
		meaningTag: s.repoFactory.MeaningTags(tx),
	}
}


================================================================================

================================================================================
Файл: internal/service/word/service.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/service.go
================================================================================

package word

// Service содержит бизнес-логику для работы со словами.
type Service struct {
	words       WordRepository
	meanings    MeaningRepository
	examples    ExampleRepository
	tags        TagRepository
	meaningTag  MeaningTagRepository
	txRunner    TxRunner
	repoFactory RepositoryFactory
}

// Deps — зависимости для создания сервиса.
type Deps struct {
	Words       WordRepository
	Meanings    MeaningRepository
	Examples    ExampleRepository
	Tags        TagRepository
	MeaningTag  MeaningTagRepository
	TxRunner    TxRunner
	RepoFactory RepositoryFactory
}

// New создаёт новый сервис.
func New(deps Deps) *Service {
	return &Service{
		words:       deps.Words,
		meanings:    deps.Meanings,
		examples:    deps.Examples,
		tags:        deps.Tags,
		meaningTag:  deps.MeaningTag,
		txRunner:    deps.TxRunner,
		repoFactory: deps.RepoFactory,
	}
}


================================================================================

================================================================================
Файл: internal/service/word/update.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/update.go
================================================================================

package word

import (
	"context"
	"errors"
	"strings"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/service"
)

// Update обновляет слово и все связанные данные.
// Стратегия: полная замена meanings (удаляем старые, создаём новые).
// Все операции выполняются в транзакции.
func (s *Service) Update(ctx context.Context, id int64, input UpdateWordInput) (*WordWithRelations, error) {
	// Валидация
	text := strings.TrimSpace(strings.ToLower(input.Text))
	if text == "" {
		return nil, service.ErrInvalidInput
	}

	// Получаем существующее слово (вне транзакции для быстрого отклонения)
	word, err := s.words.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, database.ErrNotFound) {
			return nil, service.ErrWordNotFound
		}
		return nil, err
	}

	// Проверяем, не занят ли новый текст другим словом
	if text != word.Text {
		existing, err := s.words.GetByText(ctx, text)
		if err == nil && existing.ID != id {
			return nil, service.ErrWordAlreadyExists
		}
		if err != nil && !errors.Is(err, database.ErrNotFound) {
			return nil, err
		}
	}

	var result *WordWithRelations

	// Выполняем обновление в транзакции
	err = s.txRunner.RunInTx(ctx, func(ctx context.Context, tx database.Querier) error {
		txRepos := s.withTx(tx)

		// Обновляем слово
		word.Text = text
		word.Transcription = input.Transcription
		word.AudioURL = input.AudioURL

		if err := txRepos.words.Update(ctx, &word); err != nil {
			if errors.Is(err, database.ErrDuplicate) {
				return service.ErrWordAlreadyExists
			}
			return err
		}

		// Удаляем старые meanings (CASCADE удалит examples и meaning_tags)
		if _, err := txRepos.meanings.DeleteByWordID(ctx, id); err != nil {
			return err
		}

		// Создаём новые meanings
		result = &WordWithRelations{
			Word:     word,
			Meanings: make([]MeaningWithRelations, 0, len(input.Meanings)),
		}

		for _, meaningInput := range input.Meanings {
			createInput := CreateMeaningInput{
				PartOfSpeech:  meaningInput.PartOfSpeech,
				DefinitionEn:  meaningInput.DefinitionEn,
				TranslationRu: meaningInput.TranslationRu,
				CefrLevel:     meaningInput.CefrLevel,
				ImageURL:      meaningInput.ImageURL,
				Examples:      meaningInput.Examples,
				Tags:          meaningInput.Tags,
			}

			mr, err := s.createMeaningTx(ctx, txRepos, word.ID, createInput)
			if err != nil {
				return err
			}
			result.Meanings = append(result.Meanings, *mr)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return result, nil
}


================================================================================

================================================================================
Файл: internal/service/word/update_test.go
Полный путь: /home/alodi/playground/my-english/backend/internal/service/word/update_test.go
================================================================================

package word_test

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/heartmarshall/my-english/internal/database"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/heartmarshall/my-english/internal/service/word"
)

func TestService_Update(t *testing.T) {
	ctx := context.Background()

	t.Run("success", func(t *testing.T) {
		now := time.Now()
		existingWord := model.Word{
			ID:        1,
			Text:      "hello",
			CreatedAt: now,
		}

		var updatedWord *model.Word

		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				if id == 1 {
					return existingWord, nil
				}
				return model.Word{}, database.ErrNotFound
			},
			UpdateFunc: func(ctx context.Context, w *model.Word) error {
				updatedWord = w
				return nil
			},
		}

		meaningRepo := &mockMeaningRepository{
			DeleteByWordIDFunc: func(ctx context.Context, wordID int64) (int64, error) {
				return 1, nil
			},
			CreateFunc: func(ctx context.Context, m *model.Meaning) error {
				m.ID = 1
				return nil
			},
		}

		exampleRepo := &mockExampleRepository{}
		tagRepo := &mockTagRepository{}
		meaningTagRepo := &mockMeaningTagRepository{}

		txRunner := &mockTxRunner{}
		repoFactory := &mockRepositoryFactory{
			wordRepo:       wordRepo,
			meaningRepo:    meaningRepo,
			exampleRepo:    exampleRepo,
			tagRepo:        tagRepo,
			meaningTagRepo: meaningTagRepo,
		}

		svc := word.New(word.Deps{
			Words:       wordRepo,
			Meanings:    meaningRepo,
			Examples:    exampleRepo,
			Tags:        tagRepo,
			MeaningTag:  meaningTagRepo,
			TxRunner:    txRunner,
			RepoFactory: repoFactory,
		})

		newTranscription := "həˈloʊ"
		input := word.UpdateWordInput{
			Text:          "hello",
			Transcription: &newTranscription,
			Meanings: []word.UpdateMeaningInput{
				{TranslationRu: "привет"},
			},
		}

		result, err := svc.Update(ctx, 1, input)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if updatedWord == nil {
			t.Fatal("word was not updated")
		}
		if updatedWord.Transcription == nil || *updatedWord.Transcription != newTranscription {
			t.Errorf("transcription was not updated correctly")
		}
		if result.Word.Text != "hello" {
			t.Errorf("expected text='hello', got %q", result.Word.Text)
		}
	})

	t.Run("not found", func(t *testing.T) {
		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				return model.Word{}, database.ErrNotFound
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		input := word.UpdateWordInput{
			Text:     "hello",
			Meanings: []word.UpdateMeaningInput{{TranslationRu: "привет"}},
		}
		_, err := svc.Update(ctx, 999, input)

		if !errors.Is(err, service.ErrWordNotFound) {
			t.Errorf("expected ErrWordNotFound, got %v", err)
		}
	})

	t.Run("clear transcription", func(t *testing.T) {
		transcription := "həˈloʊ"
		existingWord := model.Word{
			ID:            1,
			Text:          "hello",
			Transcription: &transcription,
		}

		var updatedWord *model.Word

		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				return existingWord, nil
			},
			UpdateFunc: func(ctx context.Context, w *model.Word) error {
				updatedWord = w
				return nil
			},
		}

		meaningRepo := &mockMeaningRepository{
			DeleteByWordIDFunc: func(ctx context.Context, wordID int64) (int64, error) {
				return 0, nil
			},
			CreateFunc: func(ctx context.Context, m *model.Meaning) error {
				m.ID = 1
				return nil
			},
		}

		exampleRepo := &mockExampleRepository{}
		tagRepo := &mockTagRepository{}
		meaningTagRepo := &mockMeaningTagRepository{}

		txRunner := &mockTxRunner{}
		repoFactory := &mockRepositoryFactory{
			wordRepo:       wordRepo,
			meaningRepo:    meaningRepo,
			exampleRepo:    exampleRepo,
			tagRepo:        tagRepo,
			meaningTagRepo: meaningTagRepo,
		}

		svc := word.New(word.Deps{
			Words:       wordRepo,
			Meanings:    meaningRepo,
			Examples:    exampleRepo,
			Tags:        tagRepo,
			MeaningTag:  meaningTagRepo,
			TxRunner:    txRunner,
			RepoFactory: repoFactory,
		})

		// Передаём nil для очистки transcription
		input := word.UpdateWordInput{
			Text:          "hello",
			Transcription: nil,
			Meanings: []word.UpdateMeaningInput{
				{TranslationRu: "привет"},
			},
		}

		_, err := svc.Update(ctx, 1, input)

		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if updatedWord.Transcription != nil {
			t.Errorf("expected transcription to be nil, got %v", *updatedWord.Transcription)
		}
	})

	t.Run("change text to already existing word", func(t *testing.T) {
		existingWord := model.Word{ID: 1, Text: "hello"}
		anotherWord := model.Word{ID: 2, Text: "world"}

		wordRepo := &mockWordRepository{
			GetByIDFunc: func(ctx context.Context, id int64) (model.Word, error) {
				if id == 1 {
					return existingWord, nil
				}
				return model.Word{}, database.ErrNotFound
			},
			GetByTextFunc: func(ctx context.Context, text string) (model.Word, error) {
				if text == "world" {
					return anotherWord, nil
				}
				return model.Word{}, database.ErrNotFound
			},
		}

		svc := word.New(word.Deps{
			Words:      wordRepo,
			Meanings:   &mockMeaningRepository{},
			Examples:   &mockExampleRepository{},
			Tags:       &mockTagRepository{},
			MeaningTag: &mockMeaningTagRepository{},
		})

		input := word.UpdateWordInput{
			Text:     "world", // пытаемся изменить на уже существующее слово
			Meanings: []word.UpdateMeaningInput{{TranslationRu: "мир"}},
		}

		_, err := svc.Update(ctx, 1, input)

		if !errors.Is(err, service.ErrWordAlreadyExists) {
			t.Errorf("expected ErrWordAlreadyExists, got %v", err)
		}
	})
}


================================================================================

================================================================================
Файл: internal/transport/errors.go
Полный путь: /home/alodi/playground/my-english/backend/internal/transport/errors.go
================================================================================

package transport

import (
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/heartmarshall/my-english/internal/service"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// ErrorCode — коды ошибок для GraphQL.
type ErrorCode string

const (
	CodeNotFound      ErrorCode = "NOT_FOUND"
	CodeAlreadyExists ErrorCode = "ALREADY_EXISTS"
	CodeInvalidInput  ErrorCode = "INVALID_INPUT"
	CodeInternal      ErrorCode = "INTERNAL_ERROR"
)

// NewGraphQLError создаёт GraphQL ошибку с расширениями.
func NewGraphQLError(ctx context.Context, message string, code ErrorCode) *gqlerror.Error {
	return &gqlerror.Error{
		Message: message,
		Path:    graphql.GetPath(ctx),
		Extensions: map[string]interface{}{
			"code": string(code),
		},
	}
}

// HandleError преобразует service ошибки в GraphQL ошибки.
func HandleError(ctx context.Context, err error) error {
	if err == nil {
		return nil
	}

	switch {
	case errors.Is(err, service.ErrWordNotFound):
		return NewGraphQLError(ctx, "Word not found", CodeNotFound)

	case errors.Is(err, service.ErrMeaningNotFound):
		return NewGraphQLError(ctx, "Meaning not found", CodeNotFound)

	case errors.Is(err, service.ErrWordAlreadyExists):
		return NewGraphQLError(ctx, "Word already exists", CodeAlreadyExists)

	case errors.Is(err, service.ErrInvalidInput):
		return NewGraphQLError(ctx, "Invalid input", CodeInvalidInput)

	case errors.Is(err, service.ErrInvalidGrade):
		return NewGraphQLError(ctx, "Grade must be between 1 and 5", CodeInvalidInput)

	default:
		// Логируем реальную ошибку, но не показываем пользователю
		// TODO: добавить логирование
		return NewGraphQLError(ctx, "Internal server error", CodeInternal)
	}
}


================================================================================

================================================================================
Файл: migrations/20251223202429_create_enums.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202429_create_enums.sql
================================================================================

-- +goose Up
-- Создание ENUM типов

-- Статус изучения слова
CREATE TYPE learning_status AS ENUM ('new', 'learning', 'review', 'mastered');

-- Часть речи
CREATE TYPE part_of_speech AS ENUM ('noun', 'verb', 'adjective', 'adverb', 'other');

-- Источник примера
CREATE TYPE example_source AS ENUM ('film', 'book', 'chat', 'video', 'podcast');

-- +goose Down
DROP TYPE IF EXISTS example_source;
DROP TYPE IF EXISTS part_of_speech;
DROP TYPE IF EXISTS learning_status;



================================================================================

================================================================================
Файл: migrations/20251223202430_create_words_table.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202430_create_words_table.sql
================================================================================

-- +goose Up
-- Создание таблицы words

CREATE TABLE words (
    id SERIAL PRIMARY KEY,
    text VARCHAR NOT NULL UNIQUE,
    transcription VARCHAR,
    audio_url VARCHAR,
    frequency_rank INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Индекс для быстрого поиска по тексту
CREATE INDEX idx_words_text ON words(text);

-- Индекс для сортировки по дате создания
CREATE INDEX idx_words_created_at ON words(created_at);

-- +goose Down
DROP TABLE IF EXISTS words;



================================================================================

================================================================================
Файл: migrations/20251223202431_create_meanings_table.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202431_create_meanings_table.sql
================================================================================

-- +goose Up
-- Создание таблицы meanings

CREATE TABLE meanings (
    id SERIAL PRIMARY KEY,
    word_id INTEGER NOT NULL,
    
    -- Лингвистика
    part_of_speech part_of_speech NOT NULL,
    definition_en TEXT,
    translation_ru TEXT NOT NULL,
    cefr_level VARCHAR,
    image_url VARCHAR,
    
    -- SRS (Интервальное повторение)
    learning_status learning_status NOT NULL DEFAULT 'new',
    next_review_at TIMESTAMP,
    interval INTEGER,
    ease_factor DECIMAL(5, 2) DEFAULT 2.5,
    review_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_meanings_word_id FOREIGN KEY (word_id) REFERENCES words(id) ON DELETE CASCADE
);

-- Индексы
CREATE INDEX idx_meanings_word_id ON meanings(word_id);
CREATE INDEX idx_meanings_learning_status ON meanings(learning_status);
CREATE INDEX idx_meanings_next_review_at ON meanings(next_review_at);
CREATE INDEX idx_meanings_part_of_speech ON meanings(part_of_speech);

-- Триггер для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_meanings_updated_at BEFORE UPDATE ON meanings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- +goose Down
-- Удаление таблицы meanings

DROP TRIGGER IF EXISTS update_meanings_updated_at ON meanings;
DROP FUNCTION IF EXISTS update_updated_at_column();
DROP TABLE IF EXISTS meanings;



================================================================================

================================================================================
Файл: migrations/20251223202432_create_examples_table.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202432_create_examples_table.sql
================================================================================

-- +goose Up
-- Создание таблицы examples

CREATE TABLE examples (
    id SERIAL PRIMARY KEY,
    meaning_id INTEGER NOT NULL,
    sentence_en TEXT NOT NULL,
    sentence_ru TEXT,
    source_name example_source,
    
    CONSTRAINT fk_examples_meaning_id FOREIGN KEY (meaning_id) REFERENCES meanings(id) ON DELETE CASCADE
);

-- Индексы
CREATE INDEX idx_examples_meaning_id ON examples(meaning_id);
CREATE INDEX idx_examples_source_name ON examples(source_name);

-- +goose Down
-- Удаление таблицы examples

DROP TABLE IF EXISTS examples;



================================================================================

================================================================================
Файл: migrations/20251223202433_create_tags_table.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202433_create_tags_table.sql
================================================================================

-- +goose Up
-- Создание таблицы tags

CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL UNIQUE
);

-- Индекс для быстрого поиска по имени тега
CREATE INDEX idx_tags_name ON tags(name);

-- +goose Down
-- Удаление таблицы tags

DROP TABLE IF EXISTS tags;



================================================================================

================================================================================
Файл: migrations/20251223202434_create_meanings_tags_table.sql
Полный путь: /home/alodi/playground/my-english/backend/migrations/20251223202434_create_meanings_tags_table.sql
================================================================================

-- +goose Up
-- Создание таблицы связки Many-to-Many meanings_tags

CREATE TABLE meanings_tags (
    meaning_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    
    PRIMARY KEY (meaning_id, tag_id),
    CONSTRAINT fk_meanings_tags_meaning_id FOREIGN KEY (meaning_id) REFERENCES meanings(id) ON DELETE CASCADE,
    CONSTRAINT fk_meanings_tags_tag_id FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- Индексы
CREATE INDEX idx_meanings_tags_meaning_id ON meanings_tags(meaning_id);
CREATE INDEX idx_meanings_tags_tag_id ON meanings_tags(tag_id);

-- +goose Down
-- Удаление таблицы meanings_tags

DROP TABLE IF EXISTS meanings_tags;



================================================================================

================================================================================
Файл: migrations/README.md
Полный путь: /home/alodi/playground/my-english/backend/migrations/README.md
================================================================================

# Миграции базы данных

Этот каталог содержит миграции базы данных, управляемые с помощью [goose](https://github.com/pressly/goose).

## Структура миграций

Миграции следуют формату `YYYYMMDDHHMMSS_description.sql` и используют директивы goose:
- `-- +goose Up` - код для применения миграции
- `-- +goose Down` - код для отката миграции

Оба блока находятся в одном файле.

## Использование

### Применить все миграции
```bash
make migrate-up DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Откатить последнюю миграцию
```bash
make migrate-down DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Проверить статус миграций
```bash
make migrate-status DB_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable
```

### Создать новую миграцию
```bash
make migrate-create NAME=add_new_feature
```

## Порядок миграций

1. `20251223202429_create_enums` - создание ENUM типов
2. `20251223202430_create_words_table` - создание таблицы words
3. `20251223202431_create_meanings_table` - создание таблицы meanings
4. `20251223202432_create_examples_table` - создание таблицы examples
5. `20251223202433_create_tags_table` - создание таблицы tags
6. `20251223202434_create_meanings_tags_table` - создание таблицы связки meanings_tags

## Примечания

- Все миграции должны быть обратимыми (иметь соответствующий `.down.sql` файл)
- При создании новых миграций используйте команду `make migrate-create`
- Перед применением миграций убедитесь, что база данных существует



================================================================================


================================================================================
ПРОПУЩЕННЫЕ ФАЙЛЫ:
================================================================================

  - go.sum
  - graph/generated.go
