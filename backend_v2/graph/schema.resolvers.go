package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/heartmarshall/my-english/internal/model"
	"github.com/heartmarshall/my-english/internal/service"
)

// CreateCard is the resolver for the createCard field.
func (r *mutationResolver) CreateCard(ctx context.Context, input CreateCardInput) (*Card, error) {
	modelInput := toModelCreateCardInput(input)
	card, err := r.CardService.Create(ctx, modelInput)
	if err != nil {
		return nil, err
	}
	return toGraphQLCard(card), nil
}

// UpdateCard is the resolver for the updateCard field.
func (r *mutationResolver) UpdateCard(ctx context.Context, id string, input UpdateCardInput) (*Card, error) {
	uuidID, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid card ID: %w", err)
	}

	modelInput := toModelUpdateCardInput(input)
	card, err := r.CardService.Update(ctx, uuidID, modelInput)
	if err != nil {
		return nil, err
	}
	return toGraphQLCard(card), nil
}

// DeleteCard is the resolver for the deleteCard field.
func (r *mutationResolver) DeleteCard(ctx context.Context, id string) (bool, error) {
	uuidID, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid card ID: %w", err)
	}

	err = r.CardService.Delete(ctx, uuidID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// AddToInbox is the resolver for the addToInbox field.
func (r *mutationResolver) AddToInbox(ctx context.Context, text string, context *string) (*InboxItem, error) {
	item, err := r.InboxService.Create(ctx, text, context)
	if err != nil {
		return nil, err
	}
	return toGraphQLInboxItem(item), nil
}

// DeleteInboxItem is the resolver for the deleteInboxItem field.
func (r *mutationResolver) DeleteInboxItem(ctx context.Context, id string) (bool, error) {
	uuidID, err := parseUUID(id)
	if err != nil {
		return false, fmt.Errorf("invalid inbox item ID: %w", err)
	}

	err = r.InboxService.Delete(ctx, uuidID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ConvertInboxToCard is the resolver for the convertInboxToCard field.
func (r *mutationResolver) ConvertInboxToCard(ctx context.Context, inboxID string, input CreateCardInput) (*Card, error) {
	// Получаем элемент inbox
	uuidInboxID, err := parseUUID(inboxID)
	if err != nil {
		return nil, fmt.Errorf("invalid inbox item ID: %w", err)
	}

	inboxItem, err := r.InboxService.GetByID(ctx, uuidInboxID)
	if err != nil {
		return nil, err
	}

	// Если в input нет customText, используем текст из inbox
	modelInput := toModelCreateCardInput(input)
	if modelInput.CustomText == nil {
		modelInput.CustomText = &inboxItem.RawText
	}

	// Создаем карточку
	card, err := r.CardService.Create(ctx, modelInput)
	if err != nil {
		return nil, err
	}

	// Удаляем элемент inbox
	_ = r.InboxService.Delete(ctx, uuidInboxID) // Игнорируем ошибку удаления

	return toGraphQLCard(card), nil
}

// ReviewCard is the resolver for the reviewCard field.
func (r *mutationResolver) ReviewCard(ctx context.Context, cardID string, grade int, timeTakenMs *int) (*ReviewResult, error) {
	uuidCardID, err := parseUUID(cardID)
	if err != nil {
		return nil, fmt.Errorf("invalid card ID: %w", err)
	}

	durationMs := 0
	if timeTakenMs != nil {
		durationMs = *timeTakenMs
	}

	result, err := r.StudyService.Review(ctx, uuidCardID, grade, durationMs)
	if err != nil {
		return nil, err
	}

	nextReviewInDays := calculateNextReviewInDays(result.SRS.DueDate)

	return &ReviewResult{
		Card:             toGraphQLCard(&result.Card),
		NextReviewInDays: nextReviewInDays,
		StatusChanged:    result.StatusChanged,
	}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string) ([]*Lexeme, error) {
	lexemes, err := r.DictionaryService.Search(ctx, query)
	if err != nil {
		return nil, err
	}

	result := make([]*Lexeme, len(lexemes))
	for i, lexeme := range lexemes {
		result[i] = toGraphQLLexeme(&lexeme)
	}
	return result, nil
}

// Lexeme is the resolver for the lexeme field.
func (r *queryResolver) Lexeme(ctx context.Context, id string) (*Lexeme, error) {
	uuidID, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid lexeme ID: %w", err)
	}

	lexeme, err := r.DictionaryService.GetLexeme(ctx, uuidID)
	if err != nil {
		if err == service.ErrLexemeNotFound {
			return nil, nil
		}
		return nil, err
	}

	return toGraphQLLexeme(lexeme), nil
}

// MyCards is the resolver for the myCards field.
func (r *queryResolver) MyCards(ctx context.Context, filter *CardsFilter, limit *int, offset *int) ([]*Card, error) {
	limitVal := 20
	if limit != nil {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil {
		offsetVal = *offset
	}

	cardFilter := toModelCardFilter(filter)
	cards, err := r.CardService.List(ctx, cardFilter, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	result := make([]*Card, len(cards))
	for i := range cards {
		result[i] = toGraphQLCard(&cards[i])
	}
	return result, nil
}

// Card is the resolver for the card field.
func (r *queryResolver) Card(ctx context.Context, id string) (*Card, error) {
	uuidID, err := parseUUID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid card ID: %w", err)
	}

	card, err := r.CardService.GetByID(ctx, uuidID)
	if err != nil {
		if err == service.ErrCardNotFound {
			return nil, nil
		}
		return nil, err
	}

	return toGraphQLCard(card), nil
}

// InboxItems is the resolver for the inboxItems field.
func (r *queryResolver) InboxItems(ctx context.Context) ([]*InboxItem, error) {
	items, err := r.InboxService.List(ctx, 100) // Лимит 100 для inbox
	if err != nil {
		return nil, err
	}

	result := make([]*InboxItem, len(items))
	for i := range items {
		result[i] = toGraphQLInboxItem(&items[i])
	}
	return result, nil
}

// StudyQueue is the resolver for the studyQueue field.
func (r *queryResolver) StudyQueue(ctx context.Context, filter *StudyFilter) ([]*Card, error) {
	limit := 20
	if filter != nil && filter.Limit != nil {
		limit = *filter.Limit
	}

	studyFilter := toModelStudyFilter(filter)
	cards, err := r.StudyService.GetQueue(ctx, studyFilter, limit)
	if err != nil {
		return nil, err
	}

	result := make([]*Card, len(cards))
	for i := range cards {
		result[i] = toGraphQLCard(&cards[i])
	}
	return result, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*DashboardStats, error) {
	totalCards, masteredCount, learningCount, dueCount, err := r.StatsService.GetDashboardStats(ctx)
	if err != nil {
		return nil, err
	}

	return &DashboardStats{
		TotalCards:    totalCards,
		MasteredCount: masteredCount,
		LearningCount: learningCount,
		DueCount:      dueCount,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// ============================================================================
// FIELD RESOLVERS
// ============================================================================

// CardResolver интерфейс для field resolvers типа Card.
type CardResolver interface {
	Progress(ctx context.Context, obj *Card) (*CardProgress, error)
	Sense(ctx context.Context, obj *Card) (*Sense, error)
	Tags(ctx context.Context, obj *Card) ([]*Tag, error)
}

// LexemeResolver интерфейс для field resolvers типа Lexeme.
type LexemeResolver interface {
	Senses(ctx context.Context, obj *Lexeme) ([]*Sense, error)
	Pronunciations(ctx context.Context, obj *Lexeme) ([]*Pronunciation, error)
	Inflections(ctx context.Context, obj *Lexeme) ([]*Inflection, error)
	Lemma(ctx context.Context, obj *Lexeme) (*Lexeme, error)
}

// SenseResolver интерфейс для field resolvers типа Sense.
type SenseResolver interface {
	Lexeme(ctx context.Context, obj *Sense) (*Lexeme, error)
	Source(ctx context.Context, obj *Sense) (*DataSource, error)
	Translations(ctx context.Context, obj *Sense) ([]*Translation, error)
	Examples(ctx context.Context, obj *Sense) ([]*Example, error)
	Relations(ctx context.Context, obj *Sense) ([]*SenseRelation, error)
}

// Progress is the resolver for the Card.progress field.
func (r *cardResolver) Progress(ctx context.Context, obj *Card) (*CardProgress, error) {
	cardID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	srsState, err := loaders.SRSByCardID.Load(ctx, cardID)
	if err != nil {
		return nil, err
	}

	reviewCount, err := loaders.ReviewCountByCardID.Load(ctx, cardID)
	if err != nil {
		reviewCount = 0 // Игнорируем ошибку, используем 0
	}

	if srsState == nil {
		return &CardProgress{
			Status:        LearningStatusNew,
			NextReviewAt:  nil,
			ReviewCount:   reviewCount,
			LastReviewAt:  nil,
			AlgorithmData: map[string]interface{}{},
		}, nil
	}

	return &CardProgress{
		Status:        toGraphQLLearningStatus(srsState.Status),
		NextReviewAt:  srsState.DueDate,
		ReviewCount:   reviewCount,
		LastReviewAt:  srsState.LastReviewAt,
		AlgorithmData: srsState.AlgorithmData,
	}, nil
}

// Sense is the resolver for the Card.sense field.
func (r *cardResolver) Sense(ctx context.Context, obj *Card) (*Sense, error) {
	cardID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	card, err := r.CardService.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.SenseID == nil {
		return nil, nil
	}

	loaders := For(ctx)
	sense, err := loaders.SensesByID.Load(ctx, *card.SenseID)
	if err != nil {
		return nil, err
	}

	if sense == nil {
		return nil, nil
	}

	return toGraphQLSense(sense), nil
}

// Tags is the resolver for the Card.tags field.
func (r *cardResolver) Tags(ctx context.Context, obj *Card) ([]*Tag, error) {
	cardID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	tags, err := loaders.TagsByCardID.Load(ctx, cardID)
	if err != nil {
		return nil, err
	}

	result := make([]*Tag, len(tags))
	for i := range tags {
		result[i] = toGraphQLTag(&tags[i])
	}
	return result, nil
}

// Senses is the resolver for the Lexeme.senses field.
func (r *lexemeResolver) Senses(ctx context.Context, obj *Lexeme) ([]*Sense, error) {
	lexemeID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	senses, err := loaders.SensesByLexemeID.Load(ctx, lexemeID)
	if err != nil {
		return nil, err
	}

	result := make([]*Sense, len(senses))
	for i := range senses {
		result[i] = toGraphQLSense(&senses[i])
	}
	return result, nil
}

// Pronunciations is the resolver for the Lexeme.pronunciations field.
func (r *lexemeResolver) Pronunciations(ctx context.Context, obj *Lexeme) ([]*Pronunciation, error) {
	lexemeID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	pronunciations, err := loaders.PronunciationsByLexemeID.Load(ctx, lexemeID)
	if err != nil {
		return nil, err
	}

	result := make([]*Pronunciation, len(pronunciations))
	for i := range pronunciations {
		p := pronunciations[i]
		var source *DataSource
		if p.SourceID != nil {
			ds, err := loaders.DataSourcesByID.Load(ctx, *p.SourceID)
			if err == nil && ds != nil {
				source = toGraphQLDataSource(ds)
			}
		}
		result[i] = &Pronunciation{
			AudioURL:      p.AudioURL,
			Transcription: p.Transcription,
			Region:        AccentRegion(p.Region),
			Source:        source,
		}
	}
	return result, nil
}

// Inflections is the resolver for the Lexeme.inflections field.
func (r *lexemeResolver) Inflections(ctx context.Context, obj *Lexeme) ([]*Inflection, error) {
	lexemeID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	inflections, err := r.LoaderService.GetInflectionsByLemmaID(ctx, lexemeID)
	if err != nil {
		return nil, err
	}

	result := make([]*Inflection, len(inflections))
	for i := range inflections {
		inf := inflections[i]
		// Загружаем лексему-форму
		lexeme, err := r.LoaderService.GetLexemesByIDs(ctx, []uuid.UUID{inf.InflectedLexemeID})
		if err != nil || len(lexeme) == 0 {
			continue
		}
		result[i] = &Inflection{
			Word: toGraphQLLexeme(&lexeme[0]),
			Type: toGraphQLMorphologicalType(model.MorphologicalType(inf.Type)),
		}
	}
	return result, nil
}

// Lemma is the resolver for the Lexeme.lemma field.
func (r *lexemeResolver) Lemma(ctx context.Context, obj *Lexeme) (*Lexeme, error) {
	lexemeID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	inflection, err := r.LoaderService.GetLemmaByInflectedID(ctx, lexemeID)
	if err != nil || inflection == nil {
		return nil, nil
	}

	lexemes, err := r.LoaderService.GetLexemesByIDs(ctx, []uuid.UUID{inflection.LemmaLexemeID})
	if err != nil || len(lexemes) == 0 {
		return nil, nil
	}

	return toGraphQLLexeme(&lexemes[0]), nil
}

// Translations is the resolver for the Sense.translations field.
func (r *senseResolver) Translations(ctx context.Context, obj *Sense) ([]*Translation, error) {
	senseID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	translations, err := loaders.TranslationsBySenseID.Load(ctx, senseID)
	if err != nil {
		return nil, err
	}

	result := make([]*Translation, len(translations))
	for i := range translations {
		t := translations[i]
		var source *DataSource
		if t.SourceID != nil {
			ds, err := loaders.DataSourcesByID.Load(ctx, *t.SourceID)
			if err == nil && ds != nil {
				source = toGraphQLDataSource(ds)
			}
		}
		result[i] = &Translation{
			Text:   t.Translation,
			Source: source,
		}
	}
	return result, nil
}

// Examples is the resolver for the Sense.examples field.
func (r *senseResolver) Examples(ctx context.Context, obj *Sense) ([]*Example, error) {
	senseID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	examples, err := loaders.ExamplesBySenseID.Load(ctx, senseID)
	if err != nil {
		return nil, err
	}

	result := make([]*Example, len(examples))
	for i := range examples {
		e := examples[i]
		var sourceType *ExampleSourceType
		// SourceType не хранится в БД, можно определить по SourceName или оставить nil
		// Если нужно, можно добавить поле в модель Example
		result[i] = &Example{
			ID:             e.ID.String(),
			SentenceEn:     e.SentenceEn,
			SentenceRu:     e.SentenceRu,
			HighlightRange: e.TargetWordRange,
			SourceName:     e.SourceName,
			SourceType:     sourceType,
		}
	}
	return result, nil
}

// Lexeme is the resolver for the Sense.lexeme field.
func (r *senseResolver) Lexeme(ctx context.Context, obj *Sense) (*Lexeme, error) {
	// Получаем sense из БД, чтобы узнать lexemeID
	senseID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	sense, err := r.LoaderService.GetSensesByIDs(ctx, []uuid.UUID{senseID})
	if err != nil || len(sense) == 0 {
		return nil, nil
	}

	loaders := For(ctx)
	lexeme, err := loaders.LexemesByID.Load(ctx, sense[0].LexemeID)
	if err != nil || lexeme == nil {
		return nil, nil
	}

	return toGraphQLLexeme(lexeme), nil
}

// Relations is the resolver for the Sense.relations field.
func (r *senseResolver) Relations(ctx context.Context, obj *Sense) ([]*SenseRelation, error) {
	senseID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	loaders := For(ctx)
	relations, err := loaders.RelationsBySenseID.Load(ctx, senseID)
	if err != nil {
		return nil, err
	}

	if len(relations) == 0 {
		return []*SenseRelation{}, nil
	}

	// Собираем уникальные ID целевых смыслов для загрузки
	targetSenseIDsMap := make(map[uuid.UUID]bool)
	for _, rel := range relations {
		targetSenseIDsMap[rel.TargetSenseID] = true
	}

	targetSenseIDs := make([]uuid.UUID, 0, len(targetSenseIDsMap))
	for id := range targetSenseIDsMap {
		targetSenseIDs = append(targetSenseIDs, id)
	}

	// Загружаем целевые смыслы через DataLoader
	targetSensesMap := make(map[uuid.UUID]*Sense)
	for _, targetID := range targetSenseIDs {
		targetSense, err := loaders.SensesByID.Load(ctx, targetID)
		if err == nil && targetSense != nil {
			targetSensesMap[targetID] = toGraphQLSense(targetSense)
		}
	}

	// Формируем результат
	result := make([]*SenseRelation, 0, len(relations))
	for _, rel := range relations {
		targetSense := targetSensesMap[rel.TargetSenseID]
		if targetSense != nil {
			result = append(result, toGraphQLSenseRelation(&rel, targetSense))
		}
	}

	return result, nil
}

// Source is the resolver for the Sense.source field.
func (r *senseResolver) Source(ctx context.Context, obj *Sense) (*DataSource, error) {
	// Получаем sense из БД, чтобы узнать sourceID
	senseID, err := parseUUID(obj.ID)
	if err != nil {
		return nil, err
	}

	sense, err := r.LoaderService.GetSensesByIDs(ctx, []uuid.UUID{senseID})
	if err != nil || len(sense) == 0 {
		return nil, nil
	}

	loaders := For(ctx)
	source, err := loaders.DataSourcesByID.Load(ctx, sense[0].SourceID)
	if err != nil || source == nil {
		return nil, nil
	}

	return toGraphQLDataSource(source), nil
}

type cardResolver struct{ *Resolver }
type lexemeResolver struct{ *Resolver }
type senseResolver struct{ *Resolver }
