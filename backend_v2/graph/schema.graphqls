scalar Time
"""
JSON объект для хранения технических данных алгоритма интервального повторения.
Пример для FSRS: { "stability": 4.5, "difficulty": 1.2, "retrievability": 0.9 }
Пример для SM-2: { "interval": 6, "ease": 2.5 }
"""
scalar JSON

# ==========================================
# 1. ENUMS
# ==========================================

enum LearningStatus {
  NEW
  LEARNING
  REVIEW
  MASTERED
}

enum PartOfSpeech {
  NOUN
  VERB
  ADJECTIVE
  ADVERB
  PRONOUN
  PREPOSITION
  CONJUNCTION
  INTERJECTION
  PHRASE
  IDIOM
  OTHER
}

enum AccentRegion {
  US
  UK
  AU
  GENERAL
}

enum RelationType {
  SYNONYM
  ANTONYM
  COLLOCATION # Устойчивое выражение (make -> decision)
  RELATED
}

enum MorphologicalType {
  PLURAL           # mice
  PAST_TENSE       # went
  PAST_PARTICIPLE  # gone
  PRESENT_PARTICIPLE # going
  COMPARATIVE      # bigger
  SUPERLATIVE      # biggest
}

enum ExampleSourceType {
  FILM
  BOOK
  CHAT
  VIDEO
  PODCAST
}

# ==========================================
# 2. SYSTEM & METADATA
# ==========================================

"""
Источник данных (Oxford, FreeDict, User Manual, AI).
"""
type DataSource {
  id: ID!
  slug: String!        # "freedict", "user"
  displayName: String! # "Free Dictionary API"
  trustLevel: Int!     # 1-10
  websiteUrl: String
}

# ==========================================
# 3. LINGUISTIC LAYER (GLOBAL DICTIONARY)
# ==========================================

"""
Лексема (Lexeme) — единица языка. Общая для всех.
Хранит написание, произношение и связи форм.
"""
type Lexeme {
  id: ID!
  text: String! # Оригинальное написание
  
  # Список вариантов произношения (разные регионы/спикеры)
  pronunciations: [Pronunciation!]!
  
  # Значения слова (Смыслы)
  senses: [Sense!]!
  
  # --- Морфология ---
  # Если это "Go", вернет формы: [{word: "Went", type: PAST_TENSE}, ...]
  inflections: [Inflection!]!
  
  # Если это "Went", вернет ссылку на "Go"
  lemma: Lexeme
}

type Pronunciation {
  audioUrl: String!
  transcription: String # IPA
  region: AccentRegion!
  source: DataSource # Откуда взята озвучка
}

"""
Связь формы слова с текущим словом.
"""
type Inflection {
  word: Lexeme! # Ссылка на слово-форму
  type: MorphologicalType!
}

"""
Смысловое значение (Sense).
Именно эту сущность пользователь добавляет в "Мои слова".
"""
type Sense {
  id: ID!
  lexeme: Lexeme! # Ссылка назад на слово
  
  partOfSpeech: PartOfSpeech!
  definition: String!
  cefrLevel: String
  
  # Источник определения
  source: DataSource!
  
  translations: [Translation!]!
  examples: [Example!]!
  relations: [SenseRelation!]!
}

type Translation {
  text: String!
  source: DataSource
}

"""
Семантическая связь (Синоним/Антоним/Коллокация).
"""
type SenseRelation {
  sense: Sense!       # С каким значением связано
  type: RelationType! # Тип связи
  
  # Если false, связь работает только в одну сторону (Source -> Target).
  # Пример: Cause -> Result (Related), но не наоборот.
  isBidirectional: Boolean! 
}

type Example {
  id: ID!
  sentenceEn: String!
  sentenceRu: String
  
  # Индексы [start, end] для подсветки целевого слова.
  # Полезно для генерации упражнений "Вставь пропущенное".
  highlightRange: [Int!]
  
  sourceType: ExampleSourceType
  sourceName: String
}

# ==========================================
# 4. USER SPACE (PERSONAL PROGRESS)
# ==========================================

"""
Личная карточка (Card).
Связывает пользователя и Sense, хранит прогресс и личные правки.
"""
type Card {
  id: ID!
  
  # Ссылка на глобальный словарь (может быть null, если слово полностью кастомное)
  sense: Sense
  
  # --- User Overrides (Кастомные данные) ---
  # Если эти поля заполнены, UI показывает их вместо данных словаря
  customText: String
  customTranscription: String
  customTranslations: [String!] 
  customNote: String          # Личная заметка (Markdown)
  customImageUrl: String
  
  # --- Progress ---
  # Вынесен в отдельный объект для чистоты
  progress: CardProgress!
  
  tags: [Tag!]!
  createdAt: Time!
}

"""
Состояние изучения и статистика.
Соответствует таблице 'srs_states'.
"""
type CardProgress {
  status: LearningStatus!
  nextReviewAt: Time
  
  # Общие метрики
  reviewCount: Int!
  lastReviewAt: Time
  
  # Сырые данные алгоритма (FSRS / SM-2).
  # Frontend может использовать это для дебага или визуализации "сложности".
  algorithmData: JSON!
}

type Tag {
  id: ID!
  name: String!
  color: String
}

type InboxItem {
  id: ID!
  text: String!
  context: String
  createdAt: Time!
}

type DashboardStats {
  totalCards: Int!
  masteredCount: Int!
  learningCount: Int!
  dueCount: Int!
}

# ==========================================
# 5. INPUTS & FILTERS
# ==========================================

input CardsFilter {
  search: String
  tags: [String!]
  statuses: [LearningStatus!]
}

input StudyFilter {
  tags: [String!]
  statuses: [LearningStatus!]
  limit: Int = 20
}

"""
Входные данные для создания карточки.
"""
input CreateCardInput {
  # Вариант А: Добавляем из словаря (ссылка на Sense)
  senseId: ID
  
  # Вариант Б: Полностью свое слово (без связи со словарем)
  customText: String
  
  # Общие поля
  translations: [String!]!
  note: String
  transcription: String
  tags: [String!]
}

input UpdateCardInput {
  customTranscription: String
  customTranslations: [String!]
  customNote: String
  tags: [String!]
}

# ==========================================
# 6. OPERATIONS
# ==========================================

type Query {
  # --- Dictionary Access ---
  # Поиск по глобальному словарю (включая поиск во внешних API)
  search(query: String!): [Lexeme!]!
  
  # Получить детали лексемы
  lexeme(id: ID!): Lexeme

  # --- User Access ---
  # Мои карточки
  myCards(filter: CardsFilter, limit: Int = 20, offset: Int = 0): [Card!]!
  card(id: ID!): Card
  
  # Inbox
  inboxItems: [InboxItem!]!
  
  # --- Study Mode ---
  # Очередь на изучение
  studyQueue(filter: StudyFilter): [Card!]!
  
  stats: DashboardStats!
}

type Mutation {
  # --- Card Ops ---
  createCard(input: CreateCardInput!): Card!
  updateCard(id: ID!, input: UpdateCardInput!): Card!
  deleteCard(id: ID!): Boolean!
  
  # --- Inbox Ops ---
  addToInbox(text: String!, context: String): InboxItem!
  deleteInboxItem(id: ID!): Boolean!
  convertInboxToCard(inboxId: ID!, input: CreateCardInput!): Card!

  # --- Study Ops ---
  # Оценка карточки
  reviewCard(
    cardId: ID!, 
    grade: Int!,      # 1-5
    timeTakenMs: Int  # Время ответа (для аналитики сложности)
  ): ReviewResult!
}

type ReviewResult {
  card: Card!
  nextReviewInDays: Float! # "Увидимся через 2.5 дня"
  statusChanged: Boolean!
}