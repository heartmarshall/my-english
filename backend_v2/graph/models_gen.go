// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

// Личная карточка (Card).
// Связывает пользователя и Sense, хранит прогресс и личные правки.
type Card struct {
	ID                  string        `json:"id"`
	Sense               *Sense        `json:"sense,omitempty"`
	CustomText          *string       `json:"customText,omitempty"`
	CustomTranscription *string       `json:"customTranscription,omitempty"`
	CustomTranslations  []string      `json:"customTranslations,omitempty"`
	CustomNote          *string       `json:"customNote,omitempty"`
	CustomImageURL      *string       `json:"customImageUrl,omitempty"`
	Progress            *CardProgress `json:"progress"`
	Tags                []*Tag        `json:"tags"`
	CreatedAt           time.Time     `json:"createdAt"`
}

// Состояние изучения и статистика.
// Соответствует таблице 'srs_states'.
type CardProgress struct {
	Status        LearningStatus `json:"status"`
	NextReviewAt  *time.Time     `json:"nextReviewAt,omitempty"`
	ReviewCount   int            `json:"reviewCount"`
	LastReviewAt  *time.Time     `json:"lastReviewAt,omitempty"`
	AlgorithmData map[string]any `json:"algorithmData"`
}

type CardsFilter struct {
	Search   *string          `json:"search,omitempty"`
	Tags     []string         `json:"tags,omitempty"`
	Statuses []LearningStatus `json:"statuses,omitempty"`
}

// Входные данные для создания карточки.
type CreateCardInput struct {
	SenseID       *string  `json:"senseId,omitempty"`
	CustomText    *string  `json:"customText,omitempty"`
	Translations  []string `json:"translations"`
	Note          *string  `json:"note,omitempty"`
	Transcription *string  `json:"transcription,omitempty"`
	Tags          []string `json:"tags,omitempty"`
}

type DashboardStats struct {
	TotalCards    int `json:"totalCards"`
	MasteredCount int `json:"masteredCount"`
	LearningCount int `json:"learningCount"`
	DueCount      int `json:"dueCount"`
}

// Источник данных (Oxford, FreeDict, User Manual, AI).
type DataSource struct {
	ID          string  `json:"id"`
	Slug        string  `json:"slug"`
	DisplayName string  `json:"displayName"`
	TrustLevel  int     `json:"trustLevel"`
	WebsiteURL  *string `json:"websiteUrl,omitempty"`
}

type Example struct {
	ID             string             `json:"id"`
	SentenceEn     string             `json:"sentenceEn"`
	SentenceRu     *string            `json:"sentenceRu,omitempty"`
	HighlightRange []int              `json:"highlightRange,omitempty"`
	SourceType     *ExampleSourceType `json:"sourceType,omitempty"`
	SourceName     *string            `json:"sourceName,omitempty"`
}

type InboxItem struct {
	ID        string    `json:"id"`
	Text      string    `json:"text"`
	Context   *string   `json:"context,omitempty"`
	CreatedAt time.Time `json:"createdAt"`
}

// Связь формы слова с текущим словом.
type Inflection struct {
	Word *Lexeme           `json:"word"`
	Type MorphologicalType `json:"type"`
}

// Лексема (Lexeme) — единица языка. Общая для всех.
// Хранит написание, произношение и связи форм.
type Lexeme struct {
	ID             string           `json:"id"`
	Text           string           `json:"text"`
	Pronunciations []*Pronunciation `json:"pronunciations"`
	Senses         []*Sense         `json:"senses"`
	Inflections    []*Inflection    `json:"inflections"`
	Lemma          *Lexeme          `json:"lemma,omitempty"`
}

type Mutation struct {
}

type Pronunciation struct {
	AudioURL      string       `json:"audioUrl"`
	Transcription *string      `json:"transcription,omitempty"`
	Region        AccentRegion `json:"region"`
	Source        *DataSource  `json:"source,omitempty"`
}

type Query struct {
}

type ReviewResult struct {
	Card             *Card   `json:"card"`
	NextReviewInDays float64 `json:"nextReviewInDays"`
	StatusChanged    bool    `json:"statusChanged"`
}

// Смысловое значение (Sense).
// Именно эту сущность пользователь добавляет в "Мои слова".
type Sense struct {
	ID           string           `json:"id"`
	Lexeme       *Lexeme          `json:"lexeme"`
	PartOfSpeech PartOfSpeech     `json:"partOfSpeech"`
	Definition   string           `json:"definition"`
	CefrLevel    *string          `json:"cefrLevel,omitempty"`
	Source       *DataSource      `json:"source"`
	Translations []*Translation   `json:"translations"`
	Examples     []*Example       `json:"examples"`
	Relations    []*SenseRelation `json:"relations"`
}

// Семантическая связь (Синоним/Антоним/Коллокация).
type SenseRelation struct {
	Sense           *Sense       `json:"sense"`
	Type            RelationType `json:"type"`
	IsBidirectional bool         `json:"isBidirectional"`
}

type StudyFilter struct {
	Tags     []string         `json:"tags,omitempty"`
	Statuses []LearningStatus `json:"statuses,omitempty"`
	Limit    *int             `json:"limit,omitempty"`
}

type Tag struct {
	ID    string  `json:"id"`
	Name  string  `json:"name"`
	Color *string `json:"color,omitempty"`
}

type Translation struct {
	Text   string      `json:"text"`
	Source *DataSource `json:"source,omitempty"`
}

type UpdateCardInput struct {
	CustomTranscription *string  `json:"customTranscription,omitempty"`
	CustomTranslations  []string `json:"customTranslations,omitempty"`
	CustomNote          *string  `json:"customNote,omitempty"`
	Tags                []string `json:"tags,omitempty"`
}

type AccentRegion string

const (
	AccentRegionUs      AccentRegion = "US"
	AccentRegionUk      AccentRegion = "UK"
	AccentRegionAu      AccentRegion = "AU"
	AccentRegionGeneral AccentRegion = "GENERAL"
)

var AllAccentRegion = []AccentRegion{
	AccentRegionUs,
	AccentRegionUk,
	AccentRegionAu,
	AccentRegionGeneral,
}

func (e AccentRegion) IsValid() bool {
	switch e {
	case AccentRegionUs, AccentRegionUk, AccentRegionAu, AccentRegionGeneral:
		return true
	}
	return false
}

func (e AccentRegion) String() string {
	return string(e)
}

func (e *AccentRegion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccentRegion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccentRegion", str)
	}
	return nil
}

func (e AccentRegion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccentRegion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccentRegion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ExampleSourceType string

const (
	ExampleSourceTypeFilm    ExampleSourceType = "FILM"
	ExampleSourceTypeBook    ExampleSourceType = "BOOK"
	ExampleSourceTypeChat    ExampleSourceType = "CHAT"
	ExampleSourceTypeVideo   ExampleSourceType = "VIDEO"
	ExampleSourceTypePodcast ExampleSourceType = "PODCAST"
)

var AllExampleSourceType = []ExampleSourceType{
	ExampleSourceTypeFilm,
	ExampleSourceTypeBook,
	ExampleSourceTypeChat,
	ExampleSourceTypeVideo,
	ExampleSourceTypePodcast,
}

func (e ExampleSourceType) IsValid() bool {
	switch e {
	case ExampleSourceTypeFilm, ExampleSourceTypeBook, ExampleSourceTypeChat, ExampleSourceTypeVideo, ExampleSourceTypePodcast:
		return true
	}
	return false
}

func (e ExampleSourceType) String() string {
	return string(e)
}

func (e *ExampleSourceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExampleSourceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExampleSourceType", str)
	}
	return nil
}

func (e ExampleSourceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExampleSourceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExampleSourceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LearningStatus string

const (
	LearningStatusNew      LearningStatus = "NEW"
	LearningStatusLearning LearningStatus = "LEARNING"
	LearningStatusReview   LearningStatus = "REVIEW"
	LearningStatusMastered LearningStatus = "MASTERED"
)

var AllLearningStatus = []LearningStatus{
	LearningStatusNew,
	LearningStatusLearning,
	LearningStatusReview,
	LearningStatusMastered,
}

func (e LearningStatus) IsValid() bool {
	switch e {
	case LearningStatusNew, LearningStatusLearning, LearningStatusReview, LearningStatusMastered:
		return true
	}
	return false
}

func (e LearningStatus) String() string {
	return string(e)
}

func (e *LearningStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LearningStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LearningStatus", str)
	}
	return nil
}

func (e LearningStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LearningStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LearningStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MorphologicalType string

const (
	MorphologicalTypePlural            MorphologicalType = "PLURAL"
	MorphologicalTypePastTense         MorphologicalType = "PAST_TENSE"
	MorphologicalTypePastParticiple    MorphologicalType = "PAST_PARTICIPLE"
	MorphologicalTypePresentParticiple MorphologicalType = "PRESENT_PARTICIPLE"
	MorphologicalTypeComparative       MorphologicalType = "COMPARATIVE"
	MorphologicalTypeSuperlative       MorphologicalType = "SUPERLATIVE"
)

var AllMorphologicalType = []MorphologicalType{
	MorphologicalTypePlural,
	MorphologicalTypePastTense,
	MorphologicalTypePastParticiple,
	MorphologicalTypePresentParticiple,
	MorphologicalTypeComparative,
	MorphologicalTypeSuperlative,
}

func (e MorphologicalType) IsValid() bool {
	switch e {
	case MorphologicalTypePlural, MorphologicalTypePastTense, MorphologicalTypePastParticiple, MorphologicalTypePresentParticiple, MorphologicalTypeComparative, MorphologicalTypeSuperlative:
		return true
	}
	return false
}

func (e MorphologicalType) String() string {
	return string(e)
}

func (e *MorphologicalType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MorphologicalType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MorphologicalType", str)
	}
	return nil
}

func (e MorphologicalType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MorphologicalType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MorphologicalType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PartOfSpeech string

const (
	PartOfSpeechNoun         PartOfSpeech = "NOUN"
	PartOfSpeechVerb         PartOfSpeech = "VERB"
	PartOfSpeechAdjective    PartOfSpeech = "ADJECTIVE"
	PartOfSpeechAdverb       PartOfSpeech = "ADVERB"
	PartOfSpeechPronoun      PartOfSpeech = "PRONOUN"
	PartOfSpeechPreposition  PartOfSpeech = "PREPOSITION"
	PartOfSpeechConjunction  PartOfSpeech = "CONJUNCTION"
	PartOfSpeechInterjection PartOfSpeech = "INTERJECTION"
	PartOfSpeechPhrase       PartOfSpeech = "PHRASE"
	PartOfSpeechIdiom        PartOfSpeech = "IDIOM"
	PartOfSpeechOther        PartOfSpeech = "OTHER"
)

var AllPartOfSpeech = []PartOfSpeech{
	PartOfSpeechNoun,
	PartOfSpeechVerb,
	PartOfSpeechAdjective,
	PartOfSpeechAdverb,
	PartOfSpeechPronoun,
	PartOfSpeechPreposition,
	PartOfSpeechConjunction,
	PartOfSpeechInterjection,
	PartOfSpeechPhrase,
	PartOfSpeechIdiom,
	PartOfSpeechOther,
}

func (e PartOfSpeech) IsValid() bool {
	switch e {
	case PartOfSpeechNoun, PartOfSpeechVerb, PartOfSpeechAdjective, PartOfSpeechAdverb, PartOfSpeechPronoun, PartOfSpeechPreposition, PartOfSpeechConjunction, PartOfSpeechInterjection, PartOfSpeechPhrase, PartOfSpeechIdiom, PartOfSpeechOther:
		return true
	}
	return false
}

func (e PartOfSpeech) String() string {
	return string(e)
}

func (e *PartOfSpeech) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PartOfSpeech(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PartOfSpeech", str)
	}
	return nil
}

func (e PartOfSpeech) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PartOfSpeech) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PartOfSpeech) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RelationType string

const (
	RelationTypeSynonym     RelationType = "SYNONYM"
	RelationTypeAntonym     RelationType = "ANTONYM"
	RelationTypeCollocation RelationType = "COLLOCATION"
	RelationTypeRelated     RelationType = "RELATED"
)

var AllRelationType = []RelationType{
	RelationTypeSynonym,
	RelationTypeAntonym,
	RelationTypeCollocation,
	RelationTypeRelated,
}

func (e RelationType) IsValid() bool {
	switch e {
	case RelationTypeSynonym, RelationTypeAntonym, RelationTypeCollocation, RelationTypeRelated:
		return true
	}
	return false
}

func (e RelationType) String() string {
	return string(e)
}

func (e *RelationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RelationType", str)
	}
	return nil
}

func (e RelationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RelationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RelationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
